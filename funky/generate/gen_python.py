from funky.corelang.coretree import *
from funky.generate.gen import CodeGenerator, annotate_section
import datetime

python_runtime = """def eq(a):
    return lambda x: a == x

def neq(a):
    return lambda x: a != x

def less(a):
    return lambda x: a < x

def leq(a, b):
    return lambda x: a <= x

def greater(a, b):
    return lambda x: a > x

def geq(a, b):
    return lambda x: a >= x

def pow(a):
    return lambda x: a ** x

def add(a):
    return lambda x: a + x

def sub(a):
    return lambda x: a - x

def negate(a):
    return -a

def mul(a):
    return lambda x: a * x

def div(a):
    return lambda x: a / x

def logical_and(a):
    return lambda x: a and x

def logical_or(a):
    return lambda x: a or x
"""

class PythonCodeGenerator(CodeGenerator):

    def __init__(self):
        super().__init__()

    def code_header(self):
        self.comment("code generated by funky compiler")
        self.timestamp()
        self.emit("")

    @annotate_section
    def code_runtime(self):
        self.emit(python_runtime)
    
    @annotate_section
    def create_adts(self, typedefs):
        for typedef in typedefs:
            adt = typedef.typ
            superclass_name = adt.type_name
            self.emit("class {}:".format(superclass_name))
            self.docstring("ADT superclass.", d=4)
            self.emit("    pass")
            self.emit("")

            for constructor in adt.constructors:
                self.emit("class {}({}):".format(constructor.identifier,
                                                 superclass_name))
                if not constructor.parameters:
                    self.emit("    pass")
                    self.emit("")
                    continue

                varnames = ["v{}".format(i)
                            for i, _ in enumerate(constructor.parameters)]
                self.emit("")
                self.emit("    def __init__(self, {}):".format(", ".join(varnames)))
                for var in varnames:
                    self.emit("        self.{} = {}".format(var, var))

                self.emit("")

    def compile(self, core_tree):
        for bind in core_tree.binds:
            if isinstance(bind.bindee, CoreLiteral):
                self.emit("{} = {}".format(bind.identifier, bind.bindee.value))
        # self.emit("def main():")
        # self.docstring("Program entrypoint.", d=4)
        # self.emit("    pass")
        # self.emit("")
        # self.emit("if __name__ == \"__main__\":")
        # self.emit("    main()")

    def docstring(self, s, d=0):
        self.emit("{}\"\"\"{}\"\"\"".format(" " * d, s))

    def comment(self, s, d=0):
        self.emit("# {}".format(s))

    def do_generate_code(self, core_tree, typedefs):
        self.program = ""
        self.code_header()
        self.code_runtime()
        self.create_adts(typedefs)
        self.compile(core_tree)
        return self.program[:]
