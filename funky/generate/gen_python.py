from funky.corelang.coretree import *
from funky.generate.gen import CodeGenerator, annotate_section
from funky.util import get_registry_function
import datetime

python_runtime = """from contextlib import contextmanager
from inspect import currentframe, getouterframes

class ADT:
    \"\"\"Superclass for all ADTs.\"\"\"
    pass

def __eq(a):
    return lambda x: a == x

def __neq(a):
    return lambda x: a != x

def __less(a):
    return lambda x: a < x

def __leq(a):
    return lambda x: a <= x

def __greater(a):
    return lambda x: a > x

def __geq(a):
    return lambda x: a >= x

def __pow(a):
    return lambda x: a ** x

def __add(a):
    return lambda x: a + x

def __sub(a):
    return lambda x: a - x

def __negate(a):
    return -a

def __mul(a):
    return lambda x: a * x

def __div(a):
    return lambda x: a / x

def __logical_and(a):
    return lambda x: a and x

def __logical_or(a):
    return lambda x: a or x

def __match(scrutinee, outcomes):
    if isinstance(scrutinee, ADT):
        ans = __match_adt(scrutinee, outcomes)
    else:
        ans = __match_literal(scrutinee, outcomes)

    return ans

def __match_adt(scrutinee, outcomes):
    raise NotImplementedError()

def __match_literal(scrutinee, outcomes):
    for alt, expr in outcomes.items():
        if scrutinee == alt:
            return expr

def __let():

@contextmanager
def __let(**bindings):
    # special thanks to Vladimir Iakovlev
    # 2 because first frame in `contextmanager` decorator  
    frame = getouterframes(currentframe(), 2)[-1][0]
    locals_ = frame.f_locals
    original = {var: locals_.get(var) for var in bindings.keys()}
    locals_.update(bindings)
    yield
    locals_.update(original)
"""

builtins = {
    "=="      :  "__eq",
    "!="      :  "__neq",
    "<"       :  "__less",
    "<="      :  "__leq",
    ">"       :  "__greater",
    ">="      :  "__geq",
    "**"      :  "__pow",
    "+"       :  "__add",
    "-"       :  "__sub",
    "negate"  :  "__negate",
    "*"       :  "__mul",
    "/"       :  "__div",
    "&&"      :  "__logical_and",
    "||"      :  "__logical_or",
}

class PythonCodeGenerator(CodeGenerator):

    docstring = "\"\"\"{}\"\"\"".format
    comment = "# {}".format

    def __init__(self):
        super().__init__()

    def code_header(self):
        self.emit(self.comment("code generated by funky py_compiler"))
        self.emit(self.comment("generated {}".format(self.timestamp())))
        self.newline()

    @annotate_section
    def code_runtime(self):
        self.emit(python_runtime)

    @annotate_section
    def create_adts(self, typedefs):
        for typedef in typedefs:
            adt = typedef.typ
            superclass_name = adt.type_name
            self.emit("class {}(ADT):".format(superclass_name))
            self.emit(self.docstring("ADT superclass."), d=4)
            self.emit("    pass")
            self.newline()

            for constructor in adt.constructors:
                self.emit("class {}({}):".format(constructor.identifier,
                                                 superclass_name))
                if not constructor.parameters:
                    self.emit("    pass")
                    self.newline()
                    continue

                varnames = ["v{}".format(i)
                            for i, _ in enumerate(constructor.parameters)]
                self.newline()
                self.emit("    def __init__(self, {}):".format(", ".join(varnames)))
                for var in varnames:
                    self.emit("        self.{} = {}".format(var, var))

                self.newline()

                eq_cond = " and \\\n               ".join("self.{} == other.{}".format(v, v) for v in varnames)
                self.emit("    def __eq__(self, other):")
                self.emit("        if not isinstance(other, self.__class__):")
                self.emit("            return False")
                self.emit("        return {}".format(eq_cond))
                self.newline()

                s = ""
                for var in varnames:
                    s += "lambda {}: ".format(var)
                self.emit("__make_{} = {}{}({})".format(constructor.identifier,
                                                        s,
                                                        constructor.identifier,
                                                        ", ".join(varnames)))
                self.newline()

    def py_compile(self, node, context="toplevel"):
        if isinstance(node, CoreBind):
            if context == "toplevel":
                self.emit("{} = {}".format(node.identifier,
                                           self.py_compile(node.bindee)))
            else:
                return "something"

        elif isinstance(node, CoreCons):
            pass

        elif isinstance(node, CoreVariable):
            return node.identifier

        elif isinstance(node, CoreLiteral):
            return node.value

        elif isinstance(node, CoreApplication):
            if isinstance(node.expr, CoreVariable) and \
               node.expr.identifier in builtins:
                f = builtins[node.expr.identifier]
            else:
                f = self.py_compile(node.expr)
            return "({})({})".format(f, self.py_compile(node.arg))

        elif isinstance(node, CoreLambda):
            param = self.py_compile(node.param)
            expr = self.py_compile(node.expr)
            return "lambda {}: {}".format(param, expr)

        elif isinstance(node, CoreLet):
            if context == "toplevel":
                for bind in node.binds:
                    self.emit(self.py_compile(bind))
            else:
                pass

        elif isinstance(node, CoreMatch):
            scrutinee = self.py_compile(node.scrutinee)
            d = {self.py_compile(alt.altcon) : self.py_compile(alt.expr)
                 for alt in node.alts}
            
            wildcard = None
            if "_" in d:
                wildcard = d["_"]
                del d["_"]

            match = "__match({}, {{{}}})".format(scrutinee, ", ".join(
                "{} : {}".format(k, v) for k, v in d.items()
            ))
            return "{} if {} is not None else {}".format(match, match, wildcard)

    def do_generate_code(self, core_tree, typedefs):
        self.program = ""
        self.code_header()
        self.code_runtime()
        self.create_adts(typedefs)
        self.py_compile(core_tree)
        return self.program[:]
