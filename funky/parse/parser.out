Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    WHITESPACE

Grammar

Rule 0     S' -> MODULE_DEFINITION
Rule 1     MODULE_DEFINITION -> MODULE IDENTIFIER WHERE BODY
Rule 2     BODY -> OPEN_BRACE IMPORT_DECLARATIONS ENDSTATEMENT TOP_DECLARATIONS CLOSE_BRACE
Rule 3     BODY -> OPEN_BRACE TOP_DECLARATIONS CLOSE_BRACE
Rule 4     IMPORT_DECLARATIONS -> IMPORT_DECLARATIONS ENDSTATEMENT IMPORT_DECLARATION
Rule 5     IMPORT_DECLARATIONS -> IMPORT_DECLARATION
Rule 6     IMPORT_DECLARATION -> IMPORT IDENTIFIER
Rule 7     TOP_DECLARATIONS -> TOP_DECLARATIONS ENDSTATEMENT TOP_DECLARATION
Rule 8     TOP_DECLARATIONS -> TOP_DECLARATION
Rule 9     TOP_DECLARATION -> TYPE_DECLARATION
Rule 10    TOP_DECLARATION -> DECLARATION
Rule 11    TYPE_DECLARATION -> NEWTYPE TYPENAME TYVARS EQUALS CONSTRUCTORS
Rule 12    TYVARS -> TYVARS IDENTIFIER
Rule 13    TYVARS -> <empty>
Rule 14    CONSTRUCTORS -> CONSTRUCTORS PIPE CONSTRUCTOR
Rule 15    CONSTRUCTORS -> CONSTRUCTOR
Rule 16    CONSTRUCTOR -> TYPENAME ATYPES
Rule 17    DECLARATIONS -> OPEN_BRACE DECLARATIONS_LIST CLOSE_BRACE
Rule 18    DECLARATIONS -> OPEN_BRACE CLOSE_BRACE
Rule 19    DECLARATIONS_LIST -> DECLARATION ENDSTATEMENT DECLARATIONS_LIST
Rule 20    DECLARATIONS_LIST -> DECLARATION
Rule 21    DECLARATION -> GEN_DECLARATION
Rule 22    DECLARATION -> FUNCTION_LHS RHS
Rule 23    DECLARATION -> LPAT RHS
Rule 24    GEN_DECLARATION -> FIXITY_DECLARATION
Rule 25    GEN_DECLARATION -> <empty>
Rule 26    FIXITY_DECLARATION -> SETFIX ASSOCIATIVITY INTEGER OP
Rule 27    ASSOCIATIVITY -> LEFTASSOC
Rule 28    ASSOCIATIVITY -> RIGHTASSOC
Rule 29    ASSOCIATIVITY -> NONASSOC
Rule 30    TYPE -> ATYPE
Rule 31    TYPE -> ATYPE ARROW TYPE
Rule 32    ATYPES -> ATYPES ATYPE
Rule 33    ATYPES -> <empty>
Rule 34    ATYPE -> TYPENAME
Rule 35    ATYPE -> IDENTIFIER
Rule 36    ATYPE -> OPEN_PAREN TYPE CLOSE_PAREN
Rule 37    FUNCTION_LHS -> IDENTIFIER APAT APATS
Rule 38    FUNCTION_LHS -> LPAT VAROP LPAT
Rule 39    FUNCTION_LHS -> OPEN_PAREN FUNCTION_LHS CLOSE_PAREN APAT APATS
Rule 40    RHS -> EQUALS EXP
Rule 41    RHS -> EQUALS EXP WHERE DECLARATIONS
Rule 42    RHS -> GDRHS
Rule 43    RHS -> GDRHS WHERE DECLARATIONS
Rule 44    GDRHS -> GIVEN EXP EQUALS EXP
Rule 45    GDRHS -> GIVEN EXP EQUALS EXP GDRHS
Rule 46    EXP -> INFIX_EXP
Rule 47    INFIX_EXP -> LEXP OP INFIX_EXP
Rule 48    INFIX_EXP -> MINUS INFIX_EXP
Rule 49    INFIX_EXP -> LEXP
Rule 50    LEXP -> LAMBDA APAT APATS ARROW EXP
Rule 51    LEXP -> LET DECLARATIONS IN EXP
Rule 52    LEXP -> EXP IF EXP ELSE EXP
Rule 53    LEXP -> MATCH EXP OF OPEN_BRACE ALTS CLOSE_BRACE
Rule 54    LEXP -> FEXP
Rule 55    FEXP -> FEXP AEXP
Rule 56    FEXP -> AEXP
Rule 57    AEXP -> USED_VAR
Rule 58    AEXP -> USED_TYPENAME
Rule 59    AEXP -> LITERAL
Rule 60    AEXP -> OPERATOR_FUNC
Rule 61    AEXP -> OPEN_PAREN EXP CLOSE_PAREN
Rule 62    OPERATOR_FUNC -> OPEN_PAREN OP CLOSE_PAREN
Rule 63    CONSTRUCTION_PARAMS -> CONSTRUCTION_PARAMS AEXP
Rule 64    CONSTRUCTION_PARAMS -> AEXP
Rule 65    ALTS -> ALT ENDSTATEMENT ALTS
Rule 66    ALTS -> ALT
Rule 67    ALT -> LPAT ARROW EXP
Rule 68    ALT -> <empty>
Rule 69    LPAT -> APAT
Rule 70    LPAT -> MINUS OPEN_PAREN INTEGER CLOSE_PAREN
Rule 71    LPAT -> MINUS OPEN_PAREN FLOAT CLOSE_PAREN
Rule 72    LPAT -> TYPENAME APAT APATS
Rule 73    APAT -> PARAM
Rule 74    APAT -> TYPENAME
Rule 75    APAT -> LITERAL
Rule 76    APAT -> OPEN_PAREN LPAT CLOSE_PAREN
Rule 77    VAROP -> VARSYM
Rule 78    VAROP -> BACKTICK IDENTIFIER BACKTICK
Rule 79    OP -> VAROP
Rule 80    APATS -> APAT APATS
Rule 81    APATS -> <empty>
Rule 82    VARSYM -> PLUS
Rule 83    VARSYM -> MINUS
Rule 84    VARSYM -> TIMES
Rule 85    VARSYM -> DIVIDE
Rule 86    VARSYM -> MODULO
Rule 87    VARSYM -> POW
Rule 88    VARSYM -> EQUALITY
Rule 89    VARSYM -> INEQUALITY
Rule 90    VARSYM -> LESS
Rule 91    VARSYM -> LEQ
Rule 92    VARSYM -> GREATER
Rule 93    VARSYM -> GEQ
Rule 94    VARSYM -> AND
Rule 95    VARSYM -> OR
Rule 96    LITERAL -> FLOAT
Rule 97    LITERAL -> INTEGER
Rule 98    LITERAL -> BOOL
Rule 99    LITERAL -> CHAR
Rule 100   LITERAL -> STRING
Rule 101   USED_VAR -> IDENTIFIER
Rule 102   USED_TYPENAME -> TYPENAME
Rule 103   PARAM -> IDENTIFIER

Terminals, with rules where they appear

AND                  : 94
ARROW                : 31 50 67
BACKTICK             : 78 78
BOOL                 : 98
CHAR                 : 99
CLOSE_BRACE          : 2 3 17 18 53
CLOSE_PAREN          : 36 39 61 62 70 71 76
DIVIDE               : 85
ELSE                 : 52
ENDSTATEMENT         : 2 4 7 19 65
EQUALITY             : 88
EQUALS               : 11 40 41 44 45
FLOAT                : 71 96
GEQ                  : 93
GIVEN                : 44 45
GREATER              : 92
IDENTIFIER           : 1 6 12 35 37 78 101 103
IF                   : 52
IMPORT               : 6
IN                   : 51
INEQUALITY           : 89
INTEGER              : 26 70 97
LAMBDA               : 50
LEFTASSOC            : 27
LEQ                  : 91
LESS                 : 90
LET                  : 51
MATCH                : 53
MINUS                : 48 70 71 83
MODULE               : 1
MODULO               : 86
NEWTYPE              : 11
NONASSOC             : 29
OF                   : 53
OPEN_BRACE           : 2 3 17 18 53
OPEN_PAREN           : 36 39 61 62 70 71 76
OR                   : 95
PIPE                 : 14
PLUS                 : 82
POW                  : 87
RIGHTASSOC           : 28
SETFIX               : 26
STRING               : 100
TIMES                : 84
TYPENAME             : 11 16 34 72 74 102
WHERE                : 1 41 43
WHITESPACE           : 
error                : 

Nonterminals, with rules where they appear

AEXP                 : 55 56 63 64
ALT                  : 65 66
ALTS                 : 53 65
APAT                 : 37 39 50 69 72 80
APATS                : 37 39 50 72 80
ASSOCIATIVITY        : 26
ATYPE                : 30 31 32
ATYPES               : 16 32
BODY                 : 1
CONSTRUCTION_PARAMS  : 63
CONSTRUCTOR          : 14 15
CONSTRUCTORS         : 11 14
DECLARATION          : 10 19 20
DECLARATIONS         : 41 43 51
DECLARATIONS_LIST    : 17 19
EXP                  : 40 41 44 44 45 45 50 51 52 52 52 53 61 67
FEXP                 : 54 55
FIXITY_DECLARATION   : 24
FUNCTION_LHS         : 22 39
GDRHS                : 42 43 45
GEN_DECLARATION      : 21
IMPORT_DECLARATION   : 4 5
IMPORT_DECLARATIONS  : 2 4
INFIX_EXP            : 46 47 48
LEXP                 : 47 49
LITERAL              : 59 75
LPAT                 : 23 38 38 67 76
MODULE_DEFINITION    : 0
OP                   : 26 47 62
OPERATOR_FUNC        : 60
PARAM                : 73
RHS                  : 22 23
TOP_DECLARATION      : 7 8
TOP_DECLARATIONS     : 2 3 7
TYPE                 : 31 36
TYPE_DECLARATION     : 9
TYVARS               : 11 12
USED_TYPENAME        : 58
USED_VAR             : 57
VAROP                : 38 79
VARSYM               : 77

Parsing method: LALR

state 0

    (0) S' -> . MODULE_DEFINITION
    (1) MODULE_DEFINITION -> . MODULE IDENTIFIER WHERE BODY

    MODULE          shift and go to state 2

    MODULE_DEFINITION              shift and go to state 1

state 1

    (0) S' -> MODULE_DEFINITION .



state 2

    (1) MODULE_DEFINITION -> MODULE . IDENTIFIER WHERE BODY

    IDENTIFIER      shift and go to state 3


state 3

    (1) MODULE_DEFINITION -> MODULE IDENTIFIER . WHERE BODY

    WHERE           shift and go to state 4


state 4

    (1) MODULE_DEFINITION -> MODULE IDENTIFIER WHERE . BODY
    (2) BODY -> . OPEN_BRACE IMPORT_DECLARATIONS ENDSTATEMENT TOP_DECLARATIONS CLOSE_BRACE
    (3) BODY -> . OPEN_BRACE TOP_DECLARATIONS CLOSE_BRACE

    OPEN_BRACE      shift and go to state 6

    BODY                           shift and go to state 5

state 5

    (1) MODULE_DEFINITION -> MODULE IDENTIFIER WHERE BODY .

    $end            reduce using rule 1 (MODULE_DEFINITION -> MODULE IDENTIFIER WHERE BODY .)


state 6

    (2) BODY -> OPEN_BRACE . IMPORT_DECLARATIONS ENDSTATEMENT TOP_DECLARATIONS CLOSE_BRACE
    (3) BODY -> OPEN_BRACE . TOP_DECLARATIONS CLOSE_BRACE
    (4) IMPORT_DECLARATIONS -> . IMPORT_DECLARATIONS ENDSTATEMENT IMPORT_DECLARATION
    (5) IMPORT_DECLARATIONS -> . IMPORT_DECLARATION
    (7) TOP_DECLARATIONS -> . TOP_DECLARATIONS ENDSTATEMENT TOP_DECLARATION
    (8) TOP_DECLARATIONS -> . TOP_DECLARATION
    (6) IMPORT_DECLARATION -> . IMPORT IDENTIFIER
    (9) TOP_DECLARATION -> . TYPE_DECLARATION
    (10) TOP_DECLARATION -> . DECLARATION
    (11) TYPE_DECLARATION -> . NEWTYPE TYPENAME TYVARS EQUALS CONSTRUCTORS
    (21) DECLARATION -> . GEN_DECLARATION
    (22) DECLARATION -> . FUNCTION_LHS RHS
    (23) DECLARATION -> . LPAT RHS
    (24) GEN_DECLARATION -> . FIXITY_DECLARATION
    (25) GEN_DECLARATION -> .
    (37) FUNCTION_LHS -> . IDENTIFIER APAT APATS
    (38) FUNCTION_LHS -> . LPAT VAROP LPAT
    (39) FUNCTION_LHS -> . OPEN_PAREN FUNCTION_LHS CLOSE_PAREN APAT APATS
    (69) LPAT -> . APAT
    (70) LPAT -> . MINUS OPEN_PAREN INTEGER CLOSE_PAREN
    (71) LPAT -> . MINUS OPEN_PAREN FLOAT CLOSE_PAREN
    (72) LPAT -> . TYPENAME APAT APATS
    (26) FIXITY_DECLARATION -> . SETFIX ASSOCIATIVITY INTEGER OP
    (73) APAT -> . PARAM
    (74) APAT -> . TYPENAME
    (75) APAT -> . LITERAL
    (76) APAT -> . OPEN_PAREN LPAT CLOSE_PAREN
    (103) PARAM -> . IDENTIFIER
    (96) LITERAL -> . FLOAT
    (97) LITERAL -> . INTEGER
    (98) LITERAL -> . BOOL
    (99) LITERAL -> . CHAR
    (100) LITERAL -> . STRING

    IMPORT          shift and go to state 11
    NEWTYPE         shift and go to state 15
    CLOSE_BRACE     reduce using rule 25 (GEN_DECLARATION -> .)
    ENDSTATEMENT    reduce using rule 25 (GEN_DECLARATION -> .)
    IDENTIFIER      shift and go to state 12
    OPEN_PAREN      shift and go to state 22
    MINUS           shift and go to state 23
    TYPENAME        shift and go to state 16
    SETFIX          shift and go to state 26
    FLOAT           shift and go to state 25
    INTEGER         shift and go to state 24
    BOOL            shift and go to state 29
    CHAR            shift and go to state 30
    STRING          shift and go to state 31

    IMPORT_DECLARATIONS            shift and go to state 7
    TOP_DECLARATIONS               shift and go to state 8
    IMPORT_DECLARATION             shift and go to state 9
    TOP_DECLARATION                shift and go to state 10
    TYPE_DECLARATION               shift and go to state 13
    DECLARATION                    shift and go to state 14
    GEN_DECLARATION                shift and go to state 17
    FUNCTION_LHS                   shift and go to state 18
    LPAT                           shift and go to state 19
    FIXITY_DECLARATION             shift and go to state 20
    APAT                           shift and go to state 21
    PARAM                          shift and go to state 27
    LITERAL                        shift and go to state 28

state 7

    (2) BODY -> OPEN_BRACE IMPORT_DECLARATIONS . ENDSTATEMENT TOP_DECLARATIONS CLOSE_BRACE
    (4) IMPORT_DECLARATIONS -> IMPORT_DECLARATIONS . ENDSTATEMENT IMPORT_DECLARATION

    ENDSTATEMENT    shift and go to state 32


state 8

    (3) BODY -> OPEN_BRACE TOP_DECLARATIONS . CLOSE_BRACE
    (7) TOP_DECLARATIONS -> TOP_DECLARATIONS . ENDSTATEMENT TOP_DECLARATION

    CLOSE_BRACE     shift and go to state 33
    ENDSTATEMENT    shift and go to state 34


state 9

    (5) IMPORT_DECLARATIONS -> IMPORT_DECLARATION .

    ENDSTATEMENT    reduce using rule 5 (IMPORT_DECLARATIONS -> IMPORT_DECLARATION .)


state 10

    (8) TOP_DECLARATIONS -> TOP_DECLARATION .

    CLOSE_BRACE     reduce using rule 8 (TOP_DECLARATIONS -> TOP_DECLARATION .)
    ENDSTATEMENT    reduce using rule 8 (TOP_DECLARATIONS -> TOP_DECLARATION .)


state 11

    (6) IMPORT_DECLARATION -> IMPORT . IDENTIFIER

    IDENTIFIER      shift and go to state 35


state 12

    (37) FUNCTION_LHS -> IDENTIFIER . APAT APATS
    (103) PARAM -> IDENTIFIER .
    (73) APAT -> . PARAM
    (74) APAT -> . TYPENAME
    (75) APAT -> . LITERAL
    (76) APAT -> . OPEN_PAREN LPAT CLOSE_PAREN
    (103) PARAM -> . IDENTIFIER
    (96) LITERAL -> . FLOAT
    (97) LITERAL -> . INTEGER
    (98) LITERAL -> . BOOL
    (99) LITERAL -> . CHAR
    (100) LITERAL -> . STRING

    EQUALS          reduce using rule 103 (PARAM -> IDENTIFIER .)
    BACKTICK        reduce using rule 103 (PARAM -> IDENTIFIER .)
    GIVEN           reduce using rule 103 (PARAM -> IDENTIFIER .)
    PLUS            reduce using rule 103 (PARAM -> IDENTIFIER .)
    MINUS           reduce using rule 103 (PARAM -> IDENTIFIER .)
    TIMES           reduce using rule 103 (PARAM -> IDENTIFIER .)
    DIVIDE          reduce using rule 103 (PARAM -> IDENTIFIER .)
    MODULO          reduce using rule 103 (PARAM -> IDENTIFIER .)
    POW             reduce using rule 103 (PARAM -> IDENTIFIER .)
    EQUALITY        reduce using rule 103 (PARAM -> IDENTIFIER .)
    INEQUALITY      reduce using rule 103 (PARAM -> IDENTIFIER .)
    LESS            reduce using rule 103 (PARAM -> IDENTIFIER .)
    LEQ             reduce using rule 103 (PARAM -> IDENTIFIER .)
    GREATER         reduce using rule 103 (PARAM -> IDENTIFIER .)
    GEQ             reduce using rule 103 (PARAM -> IDENTIFIER .)
    AND             reduce using rule 103 (PARAM -> IDENTIFIER .)
    OR              reduce using rule 103 (PARAM -> IDENTIFIER .)
    CLOSE_PAREN     reduce using rule 103 (PARAM -> IDENTIFIER .)
    TYPENAME        shift and go to state 38
    OPEN_PAREN      shift and go to state 39
    IDENTIFIER      shift and go to state 36
    FLOAT           shift and go to state 25
    INTEGER         shift and go to state 24
    BOOL            shift and go to state 29
    CHAR            shift and go to state 30
    STRING          shift and go to state 31

    APAT                           shift and go to state 37
    PARAM                          shift and go to state 27
    LITERAL                        shift and go to state 28

state 13

    (9) TOP_DECLARATION -> TYPE_DECLARATION .

    CLOSE_BRACE     reduce using rule 9 (TOP_DECLARATION -> TYPE_DECLARATION .)
    ENDSTATEMENT    reduce using rule 9 (TOP_DECLARATION -> TYPE_DECLARATION .)


state 14

    (10) TOP_DECLARATION -> DECLARATION .

    CLOSE_BRACE     reduce using rule 10 (TOP_DECLARATION -> DECLARATION .)
    ENDSTATEMENT    reduce using rule 10 (TOP_DECLARATION -> DECLARATION .)


state 15

    (11) TYPE_DECLARATION -> NEWTYPE . TYPENAME TYVARS EQUALS CONSTRUCTORS

    TYPENAME        shift and go to state 40


state 16

    (72) LPAT -> TYPENAME . APAT APATS
    (74) APAT -> TYPENAME .
    (73) APAT -> . PARAM
    (74) APAT -> . TYPENAME
    (75) APAT -> . LITERAL
    (76) APAT -> . OPEN_PAREN LPAT CLOSE_PAREN
    (103) PARAM -> . IDENTIFIER
    (96) LITERAL -> . FLOAT
    (97) LITERAL -> . INTEGER
    (98) LITERAL -> . BOOL
    (99) LITERAL -> . CHAR
    (100) LITERAL -> . STRING

    EQUALS          reduce using rule 74 (APAT -> TYPENAME .)
    BACKTICK        reduce using rule 74 (APAT -> TYPENAME .)
    GIVEN           reduce using rule 74 (APAT -> TYPENAME .)
    PLUS            reduce using rule 74 (APAT -> TYPENAME .)
    MINUS           reduce using rule 74 (APAT -> TYPENAME .)
    TIMES           reduce using rule 74 (APAT -> TYPENAME .)
    DIVIDE          reduce using rule 74 (APAT -> TYPENAME .)
    MODULO          reduce using rule 74 (APAT -> TYPENAME .)
    POW             reduce using rule 74 (APAT -> TYPENAME .)
    EQUALITY        reduce using rule 74 (APAT -> TYPENAME .)
    INEQUALITY      reduce using rule 74 (APAT -> TYPENAME .)
    LESS            reduce using rule 74 (APAT -> TYPENAME .)
    LEQ             reduce using rule 74 (APAT -> TYPENAME .)
    GREATER         reduce using rule 74 (APAT -> TYPENAME .)
    GEQ             reduce using rule 74 (APAT -> TYPENAME .)
    AND             reduce using rule 74 (APAT -> TYPENAME .)
    OR              reduce using rule 74 (APAT -> TYPENAME .)
    CLOSE_PAREN     reduce using rule 74 (APAT -> TYPENAME .)
    ARROW           reduce using rule 74 (APAT -> TYPENAME .)
    TYPENAME        shift and go to state 38
    OPEN_PAREN      shift and go to state 39
    IDENTIFIER      shift and go to state 36
    FLOAT           shift and go to state 25
    INTEGER         shift and go to state 24
    BOOL            shift and go to state 29
    CHAR            shift and go to state 30
    STRING          shift and go to state 31

    APAT                           shift and go to state 41
    PARAM                          shift and go to state 27
    LITERAL                        shift and go to state 28

state 17

    (21) DECLARATION -> GEN_DECLARATION .

    CLOSE_BRACE     reduce using rule 21 (DECLARATION -> GEN_DECLARATION .)
    ENDSTATEMENT    reduce using rule 21 (DECLARATION -> GEN_DECLARATION .)


state 18

    (22) DECLARATION -> FUNCTION_LHS . RHS
    (40) RHS -> . EQUALS EXP
    (41) RHS -> . EQUALS EXP WHERE DECLARATIONS
    (42) RHS -> . GDRHS
    (43) RHS -> . GDRHS WHERE DECLARATIONS
    (44) GDRHS -> . GIVEN EXP EQUALS EXP
    (45) GDRHS -> . GIVEN EXP EQUALS EXP GDRHS

    EQUALS          shift and go to state 43
    GIVEN           shift and go to state 45

    RHS                            shift and go to state 42
    GDRHS                          shift and go to state 44

state 19

    (23) DECLARATION -> LPAT . RHS
    (38) FUNCTION_LHS -> LPAT . VAROP LPAT
    (40) RHS -> . EQUALS EXP
    (41) RHS -> . EQUALS EXP WHERE DECLARATIONS
    (42) RHS -> . GDRHS
    (43) RHS -> . GDRHS WHERE DECLARATIONS
    (77) VAROP -> . VARSYM
    (78) VAROP -> . BACKTICK IDENTIFIER BACKTICK
    (44) GDRHS -> . GIVEN EXP EQUALS EXP
    (45) GDRHS -> . GIVEN EXP EQUALS EXP GDRHS
    (82) VARSYM -> . PLUS
    (83) VARSYM -> . MINUS
    (84) VARSYM -> . TIMES
    (85) VARSYM -> . DIVIDE
    (86) VARSYM -> . MODULO
    (87) VARSYM -> . POW
    (88) VARSYM -> . EQUALITY
    (89) VARSYM -> . INEQUALITY
    (90) VARSYM -> . LESS
    (91) VARSYM -> . LEQ
    (92) VARSYM -> . GREATER
    (93) VARSYM -> . GEQ
    (94) VARSYM -> . AND
    (95) VARSYM -> . OR

    EQUALS          shift and go to state 43
    BACKTICK        shift and go to state 49
    GIVEN           shift and go to state 45
    PLUS            shift and go to state 50
    MINUS           shift and go to state 51
    TIMES           shift and go to state 52
    DIVIDE          shift and go to state 53
    MODULO          shift and go to state 54
    POW             shift and go to state 55
    EQUALITY        shift and go to state 56
    INEQUALITY      shift and go to state 57
    LESS            shift and go to state 58
    LEQ             shift and go to state 59
    GREATER         shift and go to state 60
    GEQ             shift and go to state 61
    AND             shift and go to state 62
    OR              shift and go to state 63

    RHS                            shift and go to state 46
    VAROP                          shift and go to state 47
    GDRHS                          shift and go to state 44
    VARSYM                         shift and go to state 48

state 20

    (24) GEN_DECLARATION -> FIXITY_DECLARATION .

    CLOSE_BRACE     reduce using rule 24 (GEN_DECLARATION -> FIXITY_DECLARATION .)
    ENDSTATEMENT    reduce using rule 24 (GEN_DECLARATION -> FIXITY_DECLARATION .)


state 21

    (69) LPAT -> APAT .

    EQUALS          reduce using rule 69 (LPAT -> APAT .)
    BACKTICK        reduce using rule 69 (LPAT -> APAT .)
    GIVEN           reduce using rule 69 (LPAT -> APAT .)
    PLUS            reduce using rule 69 (LPAT -> APAT .)
    MINUS           reduce using rule 69 (LPAT -> APAT .)
    TIMES           reduce using rule 69 (LPAT -> APAT .)
    DIVIDE          reduce using rule 69 (LPAT -> APAT .)
    MODULO          reduce using rule 69 (LPAT -> APAT .)
    POW             reduce using rule 69 (LPAT -> APAT .)
    EQUALITY        reduce using rule 69 (LPAT -> APAT .)
    INEQUALITY      reduce using rule 69 (LPAT -> APAT .)
    LESS            reduce using rule 69 (LPAT -> APAT .)
    LEQ             reduce using rule 69 (LPAT -> APAT .)
    GREATER         reduce using rule 69 (LPAT -> APAT .)
    GEQ             reduce using rule 69 (LPAT -> APAT .)
    AND             reduce using rule 69 (LPAT -> APAT .)
    OR              reduce using rule 69 (LPAT -> APAT .)
    CLOSE_PAREN     reduce using rule 69 (LPAT -> APAT .)
    ARROW           reduce using rule 69 (LPAT -> APAT .)


state 22

    (39) FUNCTION_LHS -> OPEN_PAREN . FUNCTION_LHS CLOSE_PAREN APAT APATS
    (76) APAT -> OPEN_PAREN . LPAT CLOSE_PAREN
    (37) FUNCTION_LHS -> . IDENTIFIER APAT APATS
    (38) FUNCTION_LHS -> . LPAT VAROP LPAT
    (39) FUNCTION_LHS -> . OPEN_PAREN FUNCTION_LHS CLOSE_PAREN APAT APATS
    (69) LPAT -> . APAT
    (70) LPAT -> . MINUS OPEN_PAREN INTEGER CLOSE_PAREN
    (71) LPAT -> . MINUS OPEN_PAREN FLOAT CLOSE_PAREN
    (72) LPAT -> . TYPENAME APAT APATS
    (73) APAT -> . PARAM
    (74) APAT -> . TYPENAME
    (75) APAT -> . LITERAL
    (76) APAT -> . OPEN_PAREN LPAT CLOSE_PAREN
    (103) PARAM -> . IDENTIFIER
    (96) LITERAL -> . FLOAT
    (97) LITERAL -> . INTEGER
    (98) LITERAL -> . BOOL
    (99) LITERAL -> . CHAR
    (100) LITERAL -> . STRING

    IDENTIFIER      shift and go to state 12
    OPEN_PAREN      shift and go to state 22
    MINUS           shift and go to state 23
    TYPENAME        shift and go to state 16
    FLOAT           shift and go to state 25
    INTEGER         shift and go to state 24
    BOOL            shift and go to state 29
    CHAR            shift and go to state 30
    STRING          shift and go to state 31

    FUNCTION_LHS                   shift and go to state 64
    APAT                           shift and go to state 21
    LPAT                           shift and go to state 65
    PARAM                          shift and go to state 27
    LITERAL                        shift and go to state 28

state 23

    (70) LPAT -> MINUS . OPEN_PAREN INTEGER CLOSE_PAREN
    (71) LPAT -> MINUS . OPEN_PAREN FLOAT CLOSE_PAREN

    OPEN_PAREN      shift and go to state 66


state 24

    (97) LITERAL -> INTEGER .

    EQUALS          reduce using rule 97 (LITERAL -> INTEGER .)
    BACKTICK        reduce using rule 97 (LITERAL -> INTEGER .)
    GIVEN           reduce using rule 97 (LITERAL -> INTEGER .)
    PLUS            reduce using rule 97 (LITERAL -> INTEGER .)
    MINUS           reduce using rule 97 (LITERAL -> INTEGER .)
    TIMES           reduce using rule 97 (LITERAL -> INTEGER .)
    DIVIDE          reduce using rule 97 (LITERAL -> INTEGER .)
    MODULO          reduce using rule 97 (LITERAL -> INTEGER .)
    POW             reduce using rule 97 (LITERAL -> INTEGER .)
    EQUALITY        reduce using rule 97 (LITERAL -> INTEGER .)
    INEQUALITY      reduce using rule 97 (LITERAL -> INTEGER .)
    LESS            reduce using rule 97 (LITERAL -> INTEGER .)
    LEQ             reduce using rule 97 (LITERAL -> INTEGER .)
    GREATER         reduce using rule 97 (LITERAL -> INTEGER .)
    GEQ             reduce using rule 97 (LITERAL -> INTEGER .)
    AND             reduce using rule 97 (LITERAL -> INTEGER .)
    OR              reduce using rule 97 (LITERAL -> INTEGER .)
    TYPENAME        reduce using rule 97 (LITERAL -> INTEGER .)
    OPEN_PAREN      reduce using rule 97 (LITERAL -> INTEGER .)
    IDENTIFIER      reduce using rule 97 (LITERAL -> INTEGER .)
    FLOAT           reduce using rule 97 (LITERAL -> INTEGER .)
    INTEGER         reduce using rule 97 (LITERAL -> INTEGER .)
    BOOL            reduce using rule 97 (LITERAL -> INTEGER .)
    CHAR            reduce using rule 97 (LITERAL -> INTEGER .)
    STRING          reduce using rule 97 (LITERAL -> INTEGER .)
    CLOSE_PAREN     reduce using rule 97 (LITERAL -> INTEGER .)
    ARROW           reduce using rule 97 (LITERAL -> INTEGER .)
    WHERE           reduce using rule 97 (LITERAL -> INTEGER .)
    IF              reduce using rule 97 (LITERAL -> INTEGER .)
    CLOSE_BRACE     reduce using rule 97 (LITERAL -> INTEGER .)
    ENDSTATEMENT    reduce using rule 97 (LITERAL -> INTEGER .)
    OF              reduce using rule 97 (LITERAL -> INTEGER .)
    ELSE            reduce using rule 97 (LITERAL -> INTEGER .)


state 25

    (96) LITERAL -> FLOAT .

    EQUALS          reduce using rule 96 (LITERAL -> FLOAT .)
    BACKTICK        reduce using rule 96 (LITERAL -> FLOAT .)
    GIVEN           reduce using rule 96 (LITERAL -> FLOAT .)
    PLUS            reduce using rule 96 (LITERAL -> FLOAT .)
    MINUS           reduce using rule 96 (LITERAL -> FLOAT .)
    TIMES           reduce using rule 96 (LITERAL -> FLOAT .)
    DIVIDE          reduce using rule 96 (LITERAL -> FLOAT .)
    MODULO          reduce using rule 96 (LITERAL -> FLOAT .)
    POW             reduce using rule 96 (LITERAL -> FLOAT .)
    EQUALITY        reduce using rule 96 (LITERAL -> FLOAT .)
    INEQUALITY      reduce using rule 96 (LITERAL -> FLOAT .)
    LESS            reduce using rule 96 (LITERAL -> FLOAT .)
    LEQ             reduce using rule 96 (LITERAL -> FLOAT .)
    GREATER         reduce using rule 96 (LITERAL -> FLOAT .)
    GEQ             reduce using rule 96 (LITERAL -> FLOAT .)
    AND             reduce using rule 96 (LITERAL -> FLOAT .)
    OR              reduce using rule 96 (LITERAL -> FLOAT .)
    TYPENAME        reduce using rule 96 (LITERAL -> FLOAT .)
    OPEN_PAREN      reduce using rule 96 (LITERAL -> FLOAT .)
    IDENTIFIER      reduce using rule 96 (LITERAL -> FLOAT .)
    FLOAT           reduce using rule 96 (LITERAL -> FLOAT .)
    INTEGER         reduce using rule 96 (LITERAL -> FLOAT .)
    BOOL            reduce using rule 96 (LITERAL -> FLOAT .)
    CHAR            reduce using rule 96 (LITERAL -> FLOAT .)
    STRING          reduce using rule 96 (LITERAL -> FLOAT .)
    CLOSE_PAREN     reduce using rule 96 (LITERAL -> FLOAT .)
    ARROW           reduce using rule 96 (LITERAL -> FLOAT .)
    WHERE           reduce using rule 96 (LITERAL -> FLOAT .)
    IF              reduce using rule 96 (LITERAL -> FLOAT .)
    CLOSE_BRACE     reduce using rule 96 (LITERAL -> FLOAT .)
    ENDSTATEMENT    reduce using rule 96 (LITERAL -> FLOAT .)
    OF              reduce using rule 96 (LITERAL -> FLOAT .)
    ELSE            reduce using rule 96 (LITERAL -> FLOAT .)


state 26

    (26) FIXITY_DECLARATION -> SETFIX . ASSOCIATIVITY INTEGER OP
    (27) ASSOCIATIVITY -> . LEFTASSOC
    (28) ASSOCIATIVITY -> . RIGHTASSOC
    (29) ASSOCIATIVITY -> . NONASSOC

    LEFTASSOC       shift and go to state 68
    RIGHTASSOC      shift and go to state 69
    NONASSOC        shift and go to state 70

    ASSOCIATIVITY                  shift and go to state 67

state 27

    (73) APAT -> PARAM .

    EQUALS          reduce using rule 73 (APAT -> PARAM .)
    BACKTICK        reduce using rule 73 (APAT -> PARAM .)
    GIVEN           reduce using rule 73 (APAT -> PARAM .)
    PLUS            reduce using rule 73 (APAT -> PARAM .)
    MINUS           reduce using rule 73 (APAT -> PARAM .)
    TIMES           reduce using rule 73 (APAT -> PARAM .)
    DIVIDE          reduce using rule 73 (APAT -> PARAM .)
    MODULO          reduce using rule 73 (APAT -> PARAM .)
    POW             reduce using rule 73 (APAT -> PARAM .)
    EQUALITY        reduce using rule 73 (APAT -> PARAM .)
    INEQUALITY      reduce using rule 73 (APAT -> PARAM .)
    LESS            reduce using rule 73 (APAT -> PARAM .)
    LEQ             reduce using rule 73 (APAT -> PARAM .)
    GREATER         reduce using rule 73 (APAT -> PARAM .)
    GEQ             reduce using rule 73 (APAT -> PARAM .)
    AND             reduce using rule 73 (APAT -> PARAM .)
    OR              reduce using rule 73 (APAT -> PARAM .)
    TYPENAME        reduce using rule 73 (APAT -> PARAM .)
    OPEN_PAREN      reduce using rule 73 (APAT -> PARAM .)
    IDENTIFIER      reduce using rule 73 (APAT -> PARAM .)
    FLOAT           reduce using rule 73 (APAT -> PARAM .)
    INTEGER         reduce using rule 73 (APAT -> PARAM .)
    BOOL            reduce using rule 73 (APAT -> PARAM .)
    CHAR            reduce using rule 73 (APAT -> PARAM .)
    STRING          reduce using rule 73 (APAT -> PARAM .)
    CLOSE_PAREN     reduce using rule 73 (APAT -> PARAM .)
    ARROW           reduce using rule 73 (APAT -> PARAM .)


state 28

    (75) APAT -> LITERAL .

    EQUALS          reduce using rule 75 (APAT -> LITERAL .)
    BACKTICK        reduce using rule 75 (APAT -> LITERAL .)
    GIVEN           reduce using rule 75 (APAT -> LITERAL .)
    PLUS            reduce using rule 75 (APAT -> LITERAL .)
    MINUS           reduce using rule 75 (APAT -> LITERAL .)
    TIMES           reduce using rule 75 (APAT -> LITERAL .)
    DIVIDE          reduce using rule 75 (APAT -> LITERAL .)
    MODULO          reduce using rule 75 (APAT -> LITERAL .)
    POW             reduce using rule 75 (APAT -> LITERAL .)
    EQUALITY        reduce using rule 75 (APAT -> LITERAL .)
    INEQUALITY      reduce using rule 75 (APAT -> LITERAL .)
    LESS            reduce using rule 75 (APAT -> LITERAL .)
    LEQ             reduce using rule 75 (APAT -> LITERAL .)
    GREATER         reduce using rule 75 (APAT -> LITERAL .)
    GEQ             reduce using rule 75 (APAT -> LITERAL .)
    AND             reduce using rule 75 (APAT -> LITERAL .)
    OR              reduce using rule 75 (APAT -> LITERAL .)
    TYPENAME        reduce using rule 75 (APAT -> LITERAL .)
    OPEN_PAREN      reduce using rule 75 (APAT -> LITERAL .)
    IDENTIFIER      reduce using rule 75 (APAT -> LITERAL .)
    FLOAT           reduce using rule 75 (APAT -> LITERAL .)
    INTEGER         reduce using rule 75 (APAT -> LITERAL .)
    BOOL            reduce using rule 75 (APAT -> LITERAL .)
    CHAR            reduce using rule 75 (APAT -> LITERAL .)
    STRING          reduce using rule 75 (APAT -> LITERAL .)
    CLOSE_PAREN     reduce using rule 75 (APAT -> LITERAL .)
    ARROW           reduce using rule 75 (APAT -> LITERAL .)


state 29

    (98) LITERAL -> BOOL .

    EQUALS          reduce using rule 98 (LITERAL -> BOOL .)
    BACKTICK        reduce using rule 98 (LITERAL -> BOOL .)
    GIVEN           reduce using rule 98 (LITERAL -> BOOL .)
    PLUS            reduce using rule 98 (LITERAL -> BOOL .)
    MINUS           reduce using rule 98 (LITERAL -> BOOL .)
    TIMES           reduce using rule 98 (LITERAL -> BOOL .)
    DIVIDE          reduce using rule 98 (LITERAL -> BOOL .)
    MODULO          reduce using rule 98 (LITERAL -> BOOL .)
    POW             reduce using rule 98 (LITERAL -> BOOL .)
    EQUALITY        reduce using rule 98 (LITERAL -> BOOL .)
    INEQUALITY      reduce using rule 98 (LITERAL -> BOOL .)
    LESS            reduce using rule 98 (LITERAL -> BOOL .)
    LEQ             reduce using rule 98 (LITERAL -> BOOL .)
    GREATER         reduce using rule 98 (LITERAL -> BOOL .)
    GEQ             reduce using rule 98 (LITERAL -> BOOL .)
    AND             reduce using rule 98 (LITERAL -> BOOL .)
    OR              reduce using rule 98 (LITERAL -> BOOL .)
    TYPENAME        reduce using rule 98 (LITERAL -> BOOL .)
    OPEN_PAREN      reduce using rule 98 (LITERAL -> BOOL .)
    IDENTIFIER      reduce using rule 98 (LITERAL -> BOOL .)
    FLOAT           reduce using rule 98 (LITERAL -> BOOL .)
    INTEGER         reduce using rule 98 (LITERAL -> BOOL .)
    BOOL            reduce using rule 98 (LITERAL -> BOOL .)
    CHAR            reduce using rule 98 (LITERAL -> BOOL .)
    STRING          reduce using rule 98 (LITERAL -> BOOL .)
    CLOSE_PAREN     reduce using rule 98 (LITERAL -> BOOL .)
    ARROW           reduce using rule 98 (LITERAL -> BOOL .)
    WHERE           reduce using rule 98 (LITERAL -> BOOL .)
    IF              reduce using rule 98 (LITERAL -> BOOL .)
    CLOSE_BRACE     reduce using rule 98 (LITERAL -> BOOL .)
    ENDSTATEMENT    reduce using rule 98 (LITERAL -> BOOL .)
    OF              reduce using rule 98 (LITERAL -> BOOL .)
    ELSE            reduce using rule 98 (LITERAL -> BOOL .)


state 30

    (99) LITERAL -> CHAR .

    EQUALS          reduce using rule 99 (LITERAL -> CHAR .)
    BACKTICK        reduce using rule 99 (LITERAL -> CHAR .)
    GIVEN           reduce using rule 99 (LITERAL -> CHAR .)
    PLUS            reduce using rule 99 (LITERAL -> CHAR .)
    MINUS           reduce using rule 99 (LITERAL -> CHAR .)
    TIMES           reduce using rule 99 (LITERAL -> CHAR .)
    DIVIDE          reduce using rule 99 (LITERAL -> CHAR .)
    MODULO          reduce using rule 99 (LITERAL -> CHAR .)
    POW             reduce using rule 99 (LITERAL -> CHAR .)
    EQUALITY        reduce using rule 99 (LITERAL -> CHAR .)
    INEQUALITY      reduce using rule 99 (LITERAL -> CHAR .)
    LESS            reduce using rule 99 (LITERAL -> CHAR .)
    LEQ             reduce using rule 99 (LITERAL -> CHAR .)
    GREATER         reduce using rule 99 (LITERAL -> CHAR .)
    GEQ             reduce using rule 99 (LITERAL -> CHAR .)
    AND             reduce using rule 99 (LITERAL -> CHAR .)
    OR              reduce using rule 99 (LITERAL -> CHAR .)
    TYPENAME        reduce using rule 99 (LITERAL -> CHAR .)
    OPEN_PAREN      reduce using rule 99 (LITERAL -> CHAR .)
    IDENTIFIER      reduce using rule 99 (LITERAL -> CHAR .)
    FLOAT           reduce using rule 99 (LITERAL -> CHAR .)
    INTEGER         reduce using rule 99 (LITERAL -> CHAR .)
    BOOL            reduce using rule 99 (LITERAL -> CHAR .)
    CHAR            reduce using rule 99 (LITERAL -> CHAR .)
    STRING          reduce using rule 99 (LITERAL -> CHAR .)
    CLOSE_PAREN     reduce using rule 99 (LITERAL -> CHAR .)
    ARROW           reduce using rule 99 (LITERAL -> CHAR .)
    WHERE           reduce using rule 99 (LITERAL -> CHAR .)
    IF              reduce using rule 99 (LITERAL -> CHAR .)
    CLOSE_BRACE     reduce using rule 99 (LITERAL -> CHAR .)
    ENDSTATEMENT    reduce using rule 99 (LITERAL -> CHAR .)
    OF              reduce using rule 99 (LITERAL -> CHAR .)
    ELSE            reduce using rule 99 (LITERAL -> CHAR .)


state 31

    (100) LITERAL -> STRING .

    EQUALS          reduce using rule 100 (LITERAL -> STRING .)
    BACKTICK        reduce using rule 100 (LITERAL -> STRING .)
    GIVEN           reduce using rule 100 (LITERAL -> STRING .)
    PLUS            reduce using rule 100 (LITERAL -> STRING .)
    MINUS           reduce using rule 100 (LITERAL -> STRING .)
    TIMES           reduce using rule 100 (LITERAL -> STRING .)
    DIVIDE          reduce using rule 100 (LITERAL -> STRING .)
    MODULO          reduce using rule 100 (LITERAL -> STRING .)
    POW             reduce using rule 100 (LITERAL -> STRING .)
    EQUALITY        reduce using rule 100 (LITERAL -> STRING .)
    INEQUALITY      reduce using rule 100 (LITERAL -> STRING .)
    LESS            reduce using rule 100 (LITERAL -> STRING .)
    LEQ             reduce using rule 100 (LITERAL -> STRING .)
    GREATER         reduce using rule 100 (LITERAL -> STRING .)
    GEQ             reduce using rule 100 (LITERAL -> STRING .)
    AND             reduce using rule 100 (LITERAL -> STRING .)
    OR              reduce using rule 100 (LITERAL -> STRING .)
    TYPENAME        reduce using rule 100 (LITERAL -> STRING .)
    OPEN_PAREN      reduce using rule 100 (LITERAL -> STRING .)
    IDENTIFIER      reduce using rule 100 (LITERAL -> STRING .)
    FLOAT           reduce using rule 100 (LITERAL -> STRING .)
    INTEGER         reduce using rule 100 (LITERAL -> STRING .)
    BOOL            reduce using rule 100 (LITERAL -> STRING .)
    CHAR            reduce using rule 100 (LITERAL -> STRING .)
    STRING          reduce using rule 100 (LITERAL -> STRING .)
    CLOSE_PAREN     reduce using rule 100 (LITERAL -> STRING .)
    ARROW           reduce using rule 100 (LITERAL -> STRING .)
    WHERE           reduce using rule 100 (LITERAL -> STRING .)
    IF              reduce using rule 100 (LITERAL -> STRING .)
    CLOSE_BRACE     reduce using rule 100 (LITERAL -> STRING .)
    ENDSTATEMENT    reduce using rule 100 (LITERAL -> STRING .)
    OF              reduce using rule 100 (LITERAL -> STRING .)
    ELSE            reduce using rule 100 (LITERAL -> STRING .)


state 32

    (2) BODY -> OPEN_BRACE IMPORT_DECLARATIONS ENDSTATEMENT . TOP_DECLARATIONS CLOSE_BRACE
    (4) IMPORT_DECLARATIONS -> IMPORT_DECLARATIONS ENDSTATEMENT . IMPORT_DECLARATION
    (7) TOP_DECLARATIONS -> . TOP_DECLARATIONS ENDSTATEMENT TOP_DECLARATION
    (8) TOP_DECLARATIONS -> . TOP_DECLARATION
    (6) IMPORT_DECLARATION -> . IMPORT IDENTIFIER
    (9) TOP_DECLARATION -> . TYPE_DECLARATION
    (10) TOP_DECLARATION -> . DECLARATION
    (11) TYPE_DECLARATION -> . NEWTYPE TYPENAME TYVARS EQUALS CONSTRUCTORS
    (21) DECLARATION -> . GEN_DECLARATION
    (22) DECLARATION -> . FUNCTION_LHS RHS
    (23) DECLARATION -> . LPAT RHS
    (24) GEN_DECLARATION -> . FIXITY_DECLARATION
    (25) GEN_DECLARATION -> .
    (37) FUNCTION_LHS -> . IDENTIFIER APAT APATS
    (38) FUNCTION_LHS -> . LPAT VAROP LPAT
    (39) FUNCTION_LHS -> . OPEN_PAREN FUNCTION_LHS CLOSE_PAREN APAT APATS
    (69) LPAT -> . APAT
    (70) LPAT -> . MINUS OPEN_PAREN INTEGER CLOSE_PAREN
    (71) LPAT -> . MINUS OPEN_PAREN FLOAT CLOSE_PAREN
    (72) LPAT -> . TYPENAME APAT APATS
    (26) FIXITY_DECLARATION -> . SETFIX ASSOCIATIVITY INTEGER OP
    (73) APAT -> . PARAM
    (74) APAT -> . TYPENAME
    (75) APAT -> . LITERAL
    (76) APAT -> . OPEN_PAREN LPAT CLOSE_PAREN
    (103) PARAM -> . IDENTIFIER
    (96) LITERAL -> . FLOAT
    (97) LITERAL -> . INTEGER
    (98) LITERAL -> . BOOL
    (99) LITERAL -> . CHAR
    (100) LITERAL -> . STRING

    IMPORT          shift and go to state 11
    NEWTYPE         shift and go to state 15
    CLOSE_BRACE     reduce using rule 25 (GEN_DECLARATION -> .)
    ENDSTATEMENT    reduce using rule 25 (GEN_DECLARATION -> .)
    IDENTIFIER      shift and go to state 12
    OPEN_PAREN      shift and go to state 22
    MINUS           shift and go to state 23
    TYPENAME        shift and go to state 16
    SETFIX          shift and go to state 26
    FLOAT           shift and go to state 25
    INTEGER         shift and go to state 24
    BOOL            shift and go to state 29
    CHAR            shift and go to state 30
    STRING          shift and go to state 31

    TOP_DECLARATIONS               shift and go to state 71
    IMPORT_DECLARATION             shift and go to state 72
    TOP_DECLARATION                shift and go to state 10
    TYPE_DECLARATION               shift and go to state 13
    DECLARATION                    shift and go to state 14
    GEN_DECLARATION                shift and go to state 17
    FUNCTION_LHS                   shift and go to state 18
    LPAT                           shift and go to state 19
    FIXITY_DECLARATION             shift and go to state 20
    APAT                           shift and go to state 21
    PARAM                          shift and go to state 27
    LITERAL                        shift and go to state 28

state 33

    (3) BODY -> OPEN_BRACE TOP_DECLARATIONS CLOSE_BRACE .

    $end            reduce using rule 3 (BODY -> OPEN_BRACE TOP_DECLARATIONS CLOSE_BRACE .)


state 34

    (7) TOP_DECLARATIONS -> TOP_DECLARATIONS ENDSTATEMENT . TOP_DECLARATION
    (9) TOP_DECLARATION -> . TYPE_DECLARATION
    (10) TOP_DECLARATION -> . DECLARATION
    (11) TYPE_DECLARATION -> . NEWTYPE TYPENAME TYVARS EQUALS CONSTRUCTORS
    (21) DECLARATION -> . GEN_DECLARATION
    (22) DECLARATION -> . FUNCTION_LHS RHS
    (23) DECLARATION -> . LPAT RHS
    (24) GEN_DECLARATION -> . FIXITY_DECLARATION
    (25) GEN_DECLARATION -> .
    (37) FUNCTION_LHS -> . IDENTIFIER APAT APATS
    (38) FUNCTION_LHS -> . LPAT VAROP LPAT
    (39) FUNCTION_LHS -> . OPEN_PAREN FUNCTION_LHS CLOSE_PAREN APAT APATS
    (69) LPAT -> . APAT
    (70) LPAT -> . MINUS OPEN_PAREN INTEGER CLOSE_PAREN
    (71) LPAT -> . MINUS OPEN_PAREN FLOAT CLOSE_PAREN
    (72) LPAT -> . TYPENAME APAT APATS
    (26) FIXITY_DECLARATION -> . SETFIX ASSOCIATIVITY INTEGER OP
    (73) APAT -> . PARAM
    (74) APAT -> . TYPENAME
    (75) APAT -> . LITERAL
    (76) APAT -> . OPEN_PAREN LPAT CLOSE_PAREN
    (103) PARAM -> . IDENTIFIER
    (96) LITERAL -> . FLOAT
    (97) LITERAL -> . INTEGER
    (98) LITERAL -> . BOOL
    (99) LITERAL -> . CHAR
    (100) LITERAL -> . STRING

    NEWTYPE         shift and go to state 15
    CLOSE_BRACE     reduce using rule 25 (GEN_DECLARATION -> .)
    ENDSTATEMENT    reduce using rule 25 (GEN_DECLARATION -> .)
    IDENTIFIER      shift and go to state 12
    OPEN_PAREN      shift and go to state 22
    MINUS           shift and go to state 23
    TYPENAME        shift and go to state 16
    SETFIX          shift and go to state 26
    FLOAT           shift and go to state 25
    INTEGER         shift and go to state 24
    BOOL            shift and go to state 29
    CHAR            shift and go to state 30
    STRING          shift and go to state 31

    TOP_DECLARATION                shift and go to state 73
    TYPE_DECLARATION               shift and go to state 13
    DECLARATION                    shift and go to state 14
    GEN_DECLARATION                shift and go to state 17
    FUNCTION_LHS                   shift and go to state 18
    LPAT                           shift and go to state 19
    FIXITY_DECLARATION             shift and go to state 20
    APAT                           shift and go to state 21
    PARAM                          shift and go to state 27
    LITERAL                        shift and go to state 28

state 35

    (6) IMPORT_DECLARATION -> IMPORT IDENTIFIER .

    ENDSTATEMENT    reduce using rule 6 (IMPORT_DECLARATION -> IMPORT IDENTIFIER .)


state 36

    (103) PARAM -> IDENTIFIER .

    TYPENAME        reduce using rule 103 (PARAM -> IDENTIFIER .)
    OPEN_PAREN      reduce using rule 103 (PARAM -> IDENTIFIER .)
    IDENTIFIER      reduce using rule 103 (PARAM -> IDENTIFIER .)
    FLOAT           reduce using rule 103 (PARAM -> IDENTIFIER .)
    INTEGER         reduce using rule 103 (PARAM -> IDENTIFIER .)
    BOOL            reduce using rule 103 (PARAM -> IDENTIFIER .)
    CHAR            reduce using rule 103 (PARAM -> IDENTIFIER .)
    STRING          reduce using rule 103 (PARAM -> IDENTIFIER .)
    EQUALS          reduce using rule 103 (PARAM -> IDENTIFIER .)
    GIVEN           reduce using rule 103 (PARAM -> IDENTIFIER .)
    CLOSE_PAREN     reduce using rule 103 (PARAM -> IDENTIFIER .)
    BACKTICK        reduce using rule 103 (PARAM -> IDENTIFIER .)
    PLUS            reduce using rule 103 (PARAM -> IDENTIFIER .)
    MINUS           reduce using rule 103 (PARAM -> IDENTIFIER .)
    TIMES           reduce using rule 103 (PARAM -> IDENTIFIER .)
    DIVIDE          reduce using rule 103 (PARAM -> IDENTIFIER .)
    MODULO          reduce using rule 103 (PARAM -> IDENTIFIER .)
    POW             reduce using rule 103 (PARAM -> IDENTIFIER .)
    EQUALITY        reduce using rule 103 (PARAM -> IDENTIFIER .)
    INEQUALITY      reduce using rule 103 (PARAM -> IDENTIFIER .)
    LESS            reduce using rule 103 (PARAM -> IDENTIFIER .)
    LEQ             reduce using rule 103 (PARAM -> IDENTIFIER .)
    GREATER         reduce using rule 103 (PARAM -> IDENTIFIER .)
    GEQ             reduce using rule 103 (PARAM -> IDENTIFIER .)
    AND             reduce using rule 103 (PARAM -> IDENTIFIER .)
    OR              reduce using rule 103 (PARAM -> IDENTIFIER .)
    ARROW           reduce using rule 103 (PARAM -> IDENTIFIER .)


state 37

    (37) FUNCTION_LHS -> IDENTIFIER APAT . APATS
    (80) APATS -> . APAT APATS
    (81) APATS -> .
    (73) APAT -> . PARAM
    (74) APAT -> . TYPENAME
    (75) APAT -> . LITERAL
    (76) APAT -> . OPEN_PAREN LPAT CLOSE_PAREN
    (103) PARAM -> . IDENTIFIER
    (96) LITERAL -> . FLOAT
    (97) LITERAL -> . INTEGER
    (98) LITERAL -> . BOOL
    (99) LITERAL -> . CHAR
    (100) LITERAL -> . STRING

    EQUALS          reduce using rule 81 (APATS -> .)
    GIVEN           reduce using rule 81 (APATS -> .)
    CLOSE_PAREN     reduce using rule 81 (APATS -> .)
    TYPENAME        shift and go to state 38
    OPEN_PAREN      shift and go to state 39
    IDENTIFIER      shift and go to state 36
    FLOAT           shift and go to state 25
    INTEGER         shift and go to state 24
    BOOL            shift and go to state 29
    CHAR            shift and go to state 30
    STRING          shift and go to state 31

    APAT                           shift and go to state 74
    APATS                          shift and go to state 75
    PARAM                          shift and go to state 27
    LITERAL                        shift and go to state 28

state 38

    (74) APAT -> TYPENAME .

    TYPENAME        reduce using rule 74 (APAT -> TYPENAME .)
    OPEN_PAREN      reduce using rule 74 (APAT -> TYPENAME .)
    IDENTIFIER      reduce using rule 74 (APAT -> TYPENAME .)
    FLOAT           reduce using rule 74 (APAT -> TYPENAME .)
    INTEGER         reduce using rule 74 (APAT -> TYPENAME .)
    BOOL            reduce using rule 74 (APAT -> TYPENAME .)
    CHAR            reduce using rule 74 (APAT -> TYPENAME .)
    STRING          reduce using rule 74 (APAT -> TYPENAME .)
    EQUALS          reduce using rule 74 (APAT -> TYPENAME .)
    GIVEN           reduce using rule 74 (APAT -> TYPENAME .)
    CLOSE_PAREN     reduce using rule 74 (APAT -> TYPENAME .)
    BACKTICK        reduce using rule 74 (APAT -> TYPENAME .)
    PLUS            reduce using rule 74 (APAT -> TYPENAME .)
    MINUS           reduce using rule 74 (APAT -> TYPENAME .)
    TIMES           reduce using rule 74 (APAT -> TYPENAME .)
    DIVIDE          reduce using rule 74 (APAT -> TYPENAME .)
    MODULO          reduce using rule 74 (APAT -> TYPENAME .)
    POW             reduce using rule 74 (APAT -> TYPENAME .)
    EQUALITY        reduce using rule 74 (APAT -> TYPENAME .)
    INEQUALITY      reduce using rule 74 (APAT -> TYPENAME .)
    LESS            reduce using rule 74 (APAT -> TYPENAME .)
    LEQ             reduce using rule 74 (APAT -> TYPENAME .)
    GREATER         reduce using rule 74 (APAT -> TYPENAME .)
    GEQ             reduce using rule 74 (APAT -> TYPENAME .)
    AND             reduce using rule 74 (APAT -> TYPENAME .)
    OR              reduce using rule 74 (APAT -> TYPENAME .)
    ARROW           reduce using rule 74 (APAT -> TYPENAME .)


state 39

    (76) APAT -> OPEN_PAREN . LPAT CLOSE_PAREN
    (69) LPAT -> . APAT
    (70) LPAT -> . MINUS OPEN_PAREN INTEGER CLOSE_PAREN
    (71) LPAT -> . MINUS OPEN_PAREN FLOAT CLOSE_PAREN
    (72) LPAT -> . TYPENAME APAT APATS
    (73) APAT -> . PARAM
    (74) APAT -> . TYPENAME
    (75) APAT -> . LITERAL
    (76) APAT -> . OPEN_PAREN LPAT CLOSE_PAREN
    (103) PARAM -> . IDENTIFIER
    (96) LITERAL -> . FLOAT
    (97) LITERAL -> . INTEGER
    (98) LITERAL -> . BOOL
    (99) LITERAL -> . CHAR
    (100) LITERAL -> . STRING

    MINUS           shift and go to state 23
    TYPENAME        shift and go to state 16
    OPEN_PAREN      shift and go to state 39
    IDENTIFIER      shift and go to state 36
    FLOAT           shift and go to state 25
    INTEGER         shift and go to state 24
    BOOL            shift and go to state 29
    CHAR            shift and go to state 30
    STRING          shift and go to state 31

    LPAT                           shift and go to state 76
    APAT                           shift and go to state 21
    PARAM                          shift and go to state 27
    LITERAL                        shift and go to state 28

state 40

    (11) TYPE_DECLARATION -> NEWTYPE TYPENAME . TYVARS EQUALS CONSTRUCTORS
    (12) TYVARS -> . TYVARS IDENTIFIER
    (13) TYVARS -> .

    EQUALS          reduce using rule 13 (TYVARS -> .)
    IDENTIFIER      reduce using rule 13 (TYVARS -> .)

    TYVARS                         shift and go to state 77

state 41

    (72) LPAT -> TYPENAME APAT . APATS
    (80) APATS -> . APAT APATS
    (81) APATS -> .
    (73) APAT -> . PARAM
    (74) APAT -> . TYPENAME
    (75) APAT -> . LITERAL
    (76) APAT -> . OPEN_PAREN LPAT CLOSE_PAREN
    (103) PARAM -> . IDENTIFIER
    (96) LITERAL -> . FLOAT
    (97) LITERAL -> . INTEGER
    (98) LITERAL -> . BOOL
    (99) LITERAL -> . CHAR
    (100) LITERAL -> . STRING

    EQUALS          reduce using rule 81 (APATS -> .)
    BACKTICK        reduce using rule 81 (APATS -> .)
    GIVEN           reduce using rule 81 (APATS -> .)
    PLUS            reduce using rule 81 (APATS -> .)
    MINUS           reduce using rule 81 (APATS -> .)
    TIMES           reduce using rule 81 (APATS -> .)
    DIVIDE          reduce using rule 81 (APATS -> .)
    MODULO          reduce using rule 81 (APATS -> .)
    POW             reduce using rule 81 (APATS -> .)
    EQUALITY        reduce using rule 81 (APATS -> .)
    INEQUALITY      reduce using rule 81 (APATS -> .)
    LESS            reduce using rule 81 (APATS -> .)
    LEQ             reduce using rule 81 (APATS -> .)
    GREATER         reduce using rule 81 (APATS -> .)
    GEQ             reduce using rule 81 (APATS -> .)
    AND             reduce using rule 81 (APATS -> .)
    OR              reduce using rule 81 (APATS -> .)
    CLOSE_PAREN     reduce using rule 81 (APATS -> .)
    ARROW           reduce using rule 81 (APATS -> .)
    TYPENAME        shift and go to state 38
    OPEN_PAREN      shift and go to state 39
    IDENTIFIER      shift and go to state 36
    FLOAT           shift and go to state 25
    INTEGER         shift and go to state 24
    BOOL            shift and go to state 29
    CHAR            shift and go to state 30
    STRING          shift and go to state 31

    APAT                           shift and go to state 74
    APATS                          shift and go to state 78
    PARAM                          shift and go to state 27
    LITERAL                        shift and go to state 28

state 42

    (22) DECLARATION -> FUNCTION_LHS RHS .

    CLOSE_BRACE     reduce using rule 22 (DECLARATION -> FUNCTION_LHS RHS .)
    ENDSTATEMENT    reduce using rule 22 (DECLARATION -> FUNCTION_LHS RHS .)


state 43

    (40) RHS -> EQUALS . EXP
    (41) RHS -> EQUALS . EXP WHERE DECLARATIONS
    (46) EXP -> . INFIX_EXP
    (47) INFIX_EXP -> . LEXP OP INFIX_EXP
    (48) INFIX_EXP -> . MINUS INFIX_EXP
    (49) INFIX_EXP -> . LEXP
    (50) LEXP -> . LAMBDA APAT APATS ARROW EXP
    (51) LEXP -> . LET DECLARATIONS IN EXP
    (52) LEXP -> . EXP IF EXP ELSE EXP
    (53) LEXP -> . MATCH EXP OF OPEN_BRACE ALTS CLOSE_BRACE
    (54) LEXP -> . FEXP
    (55) FEXP -> . FEXP AEXP
    (56) FEXP -> . AEXP
    (57) AEXP -> . USED_VAR
    (58) AEXP -> . USED_TYPENAME
    (59) AEXP -> . LITERAL
    (60) AEXP -> . OPERATOR_FUNC
    (61) AEXP -> . OPEN_PAREN EXP CLOSE_PAREN
    (101) USED_VAR -> . IDENTIFIER
    (102) USED_TYPENAME -> . TYPENAME
    (96) LITERAL -> . FLOAT
    (97) LITERAL -> . INTEGER
    (98) LITERAL -> . BOOL
    (99) LITERAL -> . CHAR
    (100) LITERAL -> . STRING
    (62) OPERATOR_FUNC -> . OPEN_PAREN OP CLOSE_PAREN

    MINUS           shift and go to state 82
    LAMBDA          shift and go to state 83
    LET             shift and go to state 84
    MATCH           shift and go to state 85
    OPEN_PAREN      shift and go to state 92
    IDENTIFIER      shift and go to state 93
    TYPENAME        shift and go to state 94
    FLOAT           shift and go to state 25
    INTEGER         shift and go to state 24
    BOOL            shift and go to state 29
    CHAR            shift and go to state 30
    STRING          shift and go to state 31

    EXP                            shift and go to state 79
    INFIX_EXP                      shift and go to state 80
    LEXP                           shift and go to state 81
    FEXP                           shift and go to state 86
    AEXP                           shift and go to state 87
    USED_VAR                       shift and go to state 88
    USED_TYPENAME                  shift and go to state 89
    LITERAL                        shift and go to state 90
    OPERATOR_FUNC                  shift and go to state 91

state 44

    (42) RHS -> GDRHS .
    (43) RHS -> GDRHS . WHERE DECLARATIONS

    CLOSE_BRACE     reduce using rule 42 (RHS -> GDRHS .)
    ENDSTATEMENT    reduce using rule 42 (RHS -> GDRHS .)
    WHERE           shift and go to state 95


state 45

    (44) GDRHS -> GIVEN . EXP EQUALS EXP
    (45) GDRHS -> GIVEN . EXP EQUALS EXP GDRHS
    (46) EXP -> . INFIX_EXP
    (47) INFIX_EXP -> . LEXP OP INFIX_EXP
    (48) INFIX_EXP -> . MINUS INFIX_EXP
    (49) INFIX_EXP -> . LEXP
    (50) LEXP -> . LAMBDA APAT APATS ARROW EXP
    (51) LEXP -> . LET DECLARATIONS IN EXP
    (52) LEXP -> . EXP IF EXP ELSE EXP
    (53) LEXP -> . MATCH EXP OF OPEN_BRACE ALTS CLOSE_BRACE
    (54) LEXP -> . FEXP
    (55) FEXP -> . FEXP AEXP
    (56) FEXP -> . AEXP
    (57) AEXP -> . USED_VAR
    (58) AEXP -> . USED_TYPENAME
    (59) AEXP -> . LITERAL
    (60) AEXP -> . OPERATOR_FUNC
    (61) AEXP -> . OPEN_PAREN EXP CLOSE_PAREN
    (101) USED_VAR -> . IDENTIFIER
    (102) USED_TYPENAME -> . TYPENAME
    (96) LITERAL -> . FLOAT
    (97) LITERAL -> . INTEGER
    (98) LITERAL -> . BOOL
    (99) LITERAL -> . CHAR
    (100) LITERAL -> . STRING
    (62) OPERATOR_FUNC -> . OPEN_PAREN OP CLOSE_PAREN

    MINUS           shift and go to state 82
    LAMBDA          shift and go to state 83
    LET             shift and go to state 84
    MATCH           shift and go to state 85
    OPEN_PAREN      shift and go to state 92
    IDENTIFIER      shift and go to state 93
    TYPENAME        shift and go to state 94
    FLOAT           shift and go to state 25
    INTEGER         shift and go to state 24
    BOOL            shift and go to state 29
    CHAR            shift and go to state 30
    STRING          shift and go to state 31

    EXP                            shift and go to state 96
    INFIX_EXP                      shift and go to state 80
    LEXP                           shift and go to state 81
    FEXP                           shift and go to state 86
    AEXP                           shift and go to state 87
    USED_VAR                       shift and go to state 88
    USED_TYPENAME                  shift and go to state 89
    LITERAL                        shift and go to state 90
    OPERATOR_FUNC                  shift and go to state 91

state 46

    (23) DECLARATION -> LPAT RHS .

    CLOSE_BRACE     reduce using rule 23 (DECLARATION -> LPAT RHS .)
    ENDSTATEMENT    reduce using rule 23 (DECLARATION -> LPAT RHS .)


state 47

    (38) FUNCTION_LHS -> LPAT VAROP . LPAT
    (69) LPAT -> . APAT
    (70) LPAT -> . MINUS OPEN_PAREN INTEGER CLOSE_PAREN
    (71) LPAT -> . MINUS OPEN_PAREN FLOAT CLOSE_PAREN
    (72) LPAT -> . TYPENAME APAT APATS
    (73) APAT -> . PARAM
    (74) APAT -> . TYPENAME
    (75) APAT -> . LITERAL
    (76) APAT -> . OPEN_PAREN LPAT CLOSE_PAREN
    (103) PARAM -> . IDENTIFIER
    (96) LITERAL -> . FLOAT
    (97) LITERAL -> . INTEGER
    (98) LITERAL -> . BOOL
    (99) LITERAL -> . CHAR
    (100) LITERAL -> . STRING

    MINUS           shift and go to state 23
    TYPENAME        shift and go to state 16
    OPEN_PAREN      shift and go to state 39
    IDENTIFIER      shift and go to state 36
    FLOAT           shift and go to state 25
    INTEGER         shift and go to state 24
    BOOL            shift and go to state 29
    CHAR            shift and go to state 30
    STRING          shift and go to state 31

    LPAT                           shift and go to state 97
    APAT                           shift and go to state 21
    PARAM                          shift and go to state 27
    LITERAL                        shift and go to state 28

state 48

    (77) VAROP -> VARSYM .

    MINUS           reduce using rule 77 (VAROP -> VARSYM .)
    TYPENAME        reduce using rule 77 (VAROP -> VARSYM .)
    OPEN_PAREN      reduce using rule 77 (VAROP -> VARSYM .)
    IDENTIFIER      reduce using rule 77 (VAROP -> VARSYM .)
    FLOAT           reduce using rule 77 (VAROP -> VARSYM .)
    INTEGER         reduce using rule 77 (VAROP -> VARSYM .)
    BOOL            reduce using rule 77 (VAROP -> VARSYM .)
    CHAR            reduce using rule 77 (VAROP -> VARSYM .)
    STRING          reduce using rule 77 (VAROP -> VARSYM .)
    LAMBDA          reduce using rule 77 (VAROP -> VARSYM .)
    LET             reduce using rule 77 (VAROP -> VARSYM .)
    MATCH           reduce using rule 77 (VAROP -> VARSYM .)
    CLOSE_PAREN     reduce using rule 77 (VAROP -> VARSYM .)
    CLOSE_BRACE     reduce using rule 77 (VAROP -> VARSYM .)
    ENDSTATEMENT    reduce using rule 77 (VAROP -> VARSYM .)


state 49

    (78) VAROP -> BACKTICK . IDENTIFIER BACKTICK

    IDENTIFIER      shift and go to state 98


state 50

    (82) VARSYM -> PLUS .

    MINUS           reduce using rule 82 (VARSYM -> PLUS .)
    TYPENAME        reduce using rule 82 (VARSYM -> PLUS .)
    OPEN_PAREN      reduce using rule 82 (VARSYM -> PLUS .)
    IDENTIFIER      reduce using rule 82 (VARSYM -> PLUS .)
    FLOAT           reduce using rule 82 (VARSYM -> PLUS .)
    INTEGER         reduce using rule 82 (VARSYM -> PLUS .)
    BOOL            reduce using rule 82 (VARSYM -> PLUS .)
    CHAR            reduce using rule 82 (VARSYM -> PLUS .)
    STRING          reduce using rule 82 (VARSYM -> PLUS .)
    LAMBDA          reduce using rule 82 (VARSYM -> PLUS .)
    LET             reduce using rule 82 (VARSYM -> PLUS .)
    MATCH           reduce using rule 82 (VARSYM -> PLUS .)
    CLOSE_PAREN     reduce using rule 82 (VARSYM -> PLUS .)
    CLOSE_BRACE     reduce using rule 82 (VARSYM -> PLUS .)
    ENDSTATEMENT    reduce using rule 82 (VARSYM -> PLUS .)


state 51

    (83) VARSYM -> MINUS .

    MINUS           reduce using rule 83 (VARSYM -> MINUS .)
    TYPENAME        reduce using rule 83 (VARSYM -> MINUS .)
    OPEN_PAREN      reduce using rule 83 (VARSYM -> MINUS .)
    IDENTIFIER      reduce using rule 83 (VARSYM -> MINUS .)
    FLOAT           reduce using rule 83 (VARSYM -> MINUS .)
    INTEGER         reduce using rule 83 (VARSYM -> MINUS .)
    BOOL            reduce using rule 83 (VARSYM -> MINUS .)
    CHAR            reduce using rule 83 (VARSYM -> MINUS .)
    STRING          reduce using rule 83 (VARSYM -> MINUS .)
    LAMBDA          reduce using rule 83 (VARSYM -> MINUS .)
    LET             reduce using rule 83 (VARSYM -> MINUS .)
    MATCH           reduce using rule 83 (VARSYM -> MINUS .)
    CLOSE_BRACE     reduce using rule 83 (VARSYM -> MINUS .)
    ENDSTATEMENT    reduce using rule 83 (VARSYM -> MINUS .)


state 52

    (84) VARSYM -> TIMES .

    MINUS           reduce using rule 84 (VARSYM -> TIMES .)
    TYPENAME        reduce using rule 84 (VARSYM -> TIMES .)
    OPEN_PAREN      reduce using rule 84 (VARSYM -> TIMES .)
    IDENTIFIER      reduce using rule 84 (VARSYM -> TIMES .)
    FLOAT           reduce using rule 84 (VARSYM -> TIMES .)
    INTEGER         reduce using rule 84 (VARSYM -> TIMES .)
    BOOL            reduce using rule 84 (VARSYM -> TIMES .)
    CHAR            reduce using rule 84 (VARSYM -> TIMES .)
    STRING          reduce using rule 84 (VARSYM -> TIMES .)
    LAMBDA          reduce using rule 84 (VARSYM -> TIMES .)
    LET             reduce using rule 84 (VARSYM -> TIMES .)
    MATCH           reduce using rule 84 (VARSYM -> TIMES .)
    CLOSE_PAREN     reduce using rule 84 (VARSYM -> TIMES .)
    CLOSE_BRACE     reduce using rule 84 (VARSYM -> TIMES .)
    ENDSTATEMENT    reduce using rule 84 (VARSYM -> TIMES .)


state 53

    (85) VARSYM -> DIVIDE .

    MINUS           reduce using rule 85 (VARSYM -> DIVIDE .)
    TYPENAME        reduce using rule 85 (VARSYM -> DIVIDE .)
    OPEN_PAREN      reduce using rule 85 (VARSYM -> DIVIDE .)
    IDENTIFIER      reduce using rule 85 (VARSYM -> DIVIDE .)
    FLOAT           reduce using rule 85 (VARSYM -> DIVIDE .)
    INTEGER         reduce using rule 85 (VARSYM -> DIVIDE .)
    BOOL            reduce using rule 85 (VARSYM -> DIVIDE .)
    CHAR            reduce using rule 85 (VARSYM -> DIVIDE .)
    STRING          reduce using rule 85 (VARSYM -> DIVIDE .)
    LAMBDA          reduce using rule 85 (VARSYM -> DIVIDE .)
    LET             reduce using rule 85 (VARSYM -> DIVIDE .)
    MATCH           reduce using rule 85 (VARSYM -> DIVIDE .)
    CLOSE_PAREN     reduce using rule 85 (VARSYM -> DIVIDE .)
    CLOSE_BRACE     reduce using rule 85 (VARSYM -> DIVIDE .)
    ENDSTATEMENT    reduce using rule 85 (VARSYM -> DIVIDE .)


state 54

    (86) VARSYM -> MODULO .

    MINUS           reduce using rule 86 (VARSYM -> MODULO .)
    TYPENAME        reduce using rule 86 (VARSYM -> MODULO .)
    OPEN_PAREN      reduce using rule 86 (VARSYM -> MODULO .)
    IDENTIFIER      reduce using rule 86 (VARSYM -> MODULO .)
    FLOAT           reduce using rule 86 (VARSYM -> MODULO .)
    INTEGER         reduce using rule 86 (VARSYM -> MODULO .)
    BOOL            reduce using rule 86 (VARSYM -> MODULO .)
    CHAR            reduce using rule 86 (VARSYM -> MODULO .)
    STRING          reduce using rule 86 (VARSYM -> MODULO .)
    LAMBDA          reduce using rule 86 (VARSYM -> MODULO .)
    LET             reduce using rule 86 (VARSYM -> MODULO .)
    MATCH           reduce using rule 86 (VARSYM -> MODULO .)
    CLOSE_PAREN     reduce using rule 86 (VARSYM -> MODULO .)
    CLOSE_BRACE     reduce using rule 86 (VARSYM -> MODULO .)
    ENDSTATEMENT    reduce using rule 86 (VARSYM -> MODULO .)


state 55

    (87) VARSYM -> POW .

    MINUS           reduce using rule 87 (VARSYM -> POW .)
    TYPENAME        reduce using rule 87 (VARSYM -> POW .)
    OPEN_PAREN      reduce using rule 87 (VARSYM -> POW .)
    IDENTIFIER      reduce using rule 87 (VARSYM -> POW .)
    FLOAT           reduce using rule 87 (VARSYM -> POW .)
    INTEGER         reduce using rule 87 (VARSYM -> POW .)
    BOOL            reduce using rule 87 (VARSYM -> POW .)
    CHAR            reduce using rule 87 (VARSYM -> POW .)
    STRING          reduce using rule 87 (VARSYM -> POW .)
    LAMBDA          reduce using rule 87 (VARSYM -> POW .)
    LET             reduce using rule 87 (VARSYM -> POW .)
    MATCH           reduce using rule 87 (VARSYM -> POW .)
    CLOSE_PAREN     reduce using rule 87 (VARSYM -> POW .)
    CLOSE_BRACE     reduce using rule 87 (VARSYM -> POW .)
    ENDSTATEMENT    reduce using rule 87 (VARSYM -> POW .)


state 56

    (88) VARSYM -> EQUALITY .

    MINUS           reduce using rule 88 (VARSYM -> EQUALITY .)
    TYPENAME        reduce using rule 88 (VARSYM -> EQUALITY .)
    OPEN_PAREN      reduce using rule 88 (VARSYM -> EQUALITY .)
    IDENTIFIER      reduce using rule 88 (VARSYM -> EQUALITY .)
    FLOAT           reduce using rule 88 (VARSYM -> EQUALITY .)
    INTEGER         reduce using rule 88 (VARSYM -> EQUALITY .)
    BOOL            reduce using rule 88 (VARSYM -> EQUALITY .)
    CHAR            reduce using rule 88 (VARSYM -> EQUALITY .)
    STRING          reduce using rule 88 (VARSYM -> EQUALITY .)
    LAMBDA          reduce using rule 88 (VARSYM -> EQUALITY .)
    LET             reduce using rule 88 (VARSYM -> EQUALITY .)
    MATCH           reduce using rule 88 (VARSYM -> EQUALITY .)
    CLOSE_PAREN     reduce using rule 88 (VARSYM -> EQUALITY .)
    CLOSE_BRACE     reduce using rule 88 (VARSYM -> EQUALITY .)
    ENDSTATEMENT    reduce using rule 88 (VARSYM -> EQUALITY .)


state 57

    (89) VARSYM -> INEQUALITY .

    MINUS           reduce using rule 89 (VARSYM -> INEQUALITY .)
    TYPENAME        reduce using rule 89 (VARSYM -> INEQUALITY .)
    OPEN_PAREN      reduce using rule 89 (VARSYM -> INEQUALITY .)
    IDENTIFIER      reduce using rule 89 (VARSYM -> INEQUALITY .)
    FLOAT           reduce using rule 89 (VARSYM -> INEQUALITY .)
    INTEGER         reduce using rule 89 (VARSYM -> INEQUALITY .)
    BOOL            reduce using rule 89 (VARSYM -> INEQUALITY .)
    CHAR            reduce using rule 89 (VARSYM -> INEQUALITY .)
    STRING          reduce using rule 89 (VARSYM -> INEQUALITY .)
    LAMBDA          reduce using rule 89 (VARSYM -> INEQUALITY .)
    LET             reduce using rule 89 (VARSYM -> INEQUALITY .)
    MATCH           reduce using rule 89 (VARSYM -> INEQUALITY .)
    CLOSE_PAREN     reduce using rule 89 (VARSYM -> INEQUALITY .)
    CLOSE_BRACE     reduce using rule 89 (VARSYM -> INEQUALITY .)
    ENDSTATEMENT    reduce using rule 89 (VARSYM -> INEQUALITY .)


state 58

    (90) VARSYM -> LESS .

    MINUS           reduce using rule 90 (VARSYM -> LESS .)
    TYPENAME        reduce using rule 90 (VARSYM -> LESS .)
    OPEN_PAREN      reduce using rule 90 (VARSYM -> LESS .)
    IDENTIFIER      reduce using rule 90 (VARSYM -> LESS .)
    FLOAT           reduce using rule 90 (VARSYM -> LESS .)
    INTEGER         reduce using rule 90 (VARSYM -> LESS .)
    BOOL            reduce using rule 90 (VARSYM -> LESS .)
    CHAR            reduce using rule 90 (VARSYM -> LESS .)
    STRING          reduce using rule 90 (VARSYM -> LESS .)
    LAMBDA          reduce using rule 90 (VARSYM -> LESS .)
    LET             reduce using rule 90 (VARSYM -> LESS .)
    MATCH           reduce using rule 90 (VARSYM -> LESS .)
    CLOSE_PAREN     reduce using rule 90 (VARSYM -> LESS .)
    CLOSE_BRACE     reduce using rule 90 (VARSYM -> LESS .)
    ENDSTATEMENT    reduce using rule 90 (VARSYM -> LESS .)


state 59

    (91) VARSYM -> LEQ .

    MINUS           reduce using rule 91 (VARSYM -> LEQ .)
    TYPENAME        reduce using rule 91 (VARSYM -> LEQ .)
    OPEN_PAREN      reduce using rule 91 (VARSYM -> LEQ .)
    IDENTIFIER      reduce using rule 91 (VARSYM -> LEQ .)
    FLOAT           reduce using rule 91 (VARSYM -> LEQ .)
    INTEGER         reduce using rule 91 (VARSYM -> LEQ .)
    BOOL            reduce using rule 91 (VARSYM -> LEQ .)
    CHAR            reduce using rule 91 (VARSYM -> LEQ .)
    STRING          reduce using rule 91 (VARSYM -> LEQ .)
    LAMBDA          reduce using rule 91 (VARSYM -> LEQ .)
    LET             reduce using rule 91 (VARSYM -> LEQ .)
    MATCH           reduce using rule 91 (VARSYM -> LEQ .)
    CLOSE_PAREN     reduce using rule 91 (VARSYM -> LEQ .)
    CLOSE_BRACE     reduce using rule 91 (VARSYM -> LEQ .)
    ENDSTATEMENT    reduce using rule 91 (VARSYM -> LEQ .)


state 60

    (92) VARSYM -> GREATER .

    MINUS           reduce using rule 92 (VARSYM -> GREATER .)
    TYPENAME        reduce using rule 92 (VARSYM -> GREATER .)
    OPEN_PAREN      reduce using rule 92 (VARSYM -> GREATER .)
    IDENTIFIER      reduce using rule 92 (VARSYM -> GREATER .)
    FLOAT           reduce using rule 92 (VARSYM -> GREATER .)
    INTEGER         reduce using rule 92 (VARSYM -> GREATER .)
    BOOL            reduce using rule 92 (VARSYM -> GREATER .)
    CHAR            reduce using rule 92 (VARSYM -> GREATER .)
    STRING          reduce using rule 92 (VARSYM -> GREATER .)
    LAMBDA          reduce using rule 92 (VARSYM -> GREATER .)
    LET             reduce using rule 92 (VARSYM -> GREATER .)
    MATCH           reduce using rule 92 (VARSYM -> GREATER .)
    CLOSE_PAREN     reduce using rule 92 (VARSYM -> GREATER .)
    CLOSE_BRACE     reduce using rule 92 (VARSYM -> GREATER .)
    ENDSTATEMENT    reduce using rule 92 (VARSYM -> GREATER .)


state 61

    (93) VARSYM -> GEQ .

    MINUS           reduce using rule 93 (VARSYM -> GEQ .)
    TYPENAME        reduce using rule 93 (VARSYM -> GEQ .)
    OPEN_PAREN      reduce using rule 93 (VARSYM -> GEQ .)
    IDENTIFIER      reduce using rule 93 (VARSYM -> GEQ .)
    FLOAT           reduce using rule 93 (VARSYM -> GEQ .)
    INTEGER         reduce using rule 93 (VARSYM -> GEQ .)
    BOOL            reduce using rule 93 (VARSYM -> GEQ .)
    CHAR            reduce using rule 93 (VARSYM -> GEQ .)
    STRING          reduce using rule 93 (VARSYM -> GEQ .)
    LAMBDA          reduce using rule 93 (VARSYM -> GEQ .)
    LET             reduce using rule 93 (VARSYM -> GEQ .)
    MATCH           reduce using rule 93 (VARSYM -> GEQ .)
    CLOSE_PAREN     reduce using rule 93 (VARSYM -> GEQ .)
    CLOSE_BRACE     reduce using rule 93 (VARSYM -> GEQ .)
    ENDSTATEMENT    reduce using rule 93 (VARSYM -> GEQ .)


state 62

    (94) VARSYM -> AND .

    MINUS           reduce using rule 94 (VARSYM -> AND .)
    TYPENAME        reduce using rule 94 (VARSYM -> AND .)
    OPEN_PAREN      reduce using rule 94 (VARSYM -> AND .)
    IDENTIFIER      reduce using rule 94 (VARSYM -> AND .)
    FLOAT           reduce using rule 94 (VARSYM -> AND .)
    INTEGER         reduce using rule 94 (VARSYM -> AND .)
    BOOL            reduce using rule 94 (VARSYM -> AND .)
    CHAR            reduce using rule 94 (VARSYM -> AND .)
    STRING          reduce using rule 94 (VARSYM -> AND .)
    LAMBDA          reduce using rule 94 (VARSYM -> AND .)
    LET             reduce using rule 94 (VARSYM -> AND .)
    MATCH           reduce using rule 94 (VARSYM -> AND .)
    CLOSE_PAREN     reduce using rule 94 (VARSYM -> AND .)
    CLOSE_BRACE     reduce using rule 94 (VARSYM -> AND .)
    ENDSTATEMENT    reduce using rule 94 (VARSYM -> AND .)


state 63

    (95) VARSYM -> OR .

    MINUS           reduce using rule 95 (VARSYM -> OR .)
    TYPENAME        reduce using rule 95 (VARSYM -> OR .)
    OPEN_PAREN      reduce using rule 95 (VARSYM -> OR .)
    IDENTIFIER      reduce using rule 95 (VARSYM -> OR .)
    FLOAT           reduce using rule 95 (VARSYM -> OR .)
    INTEGER         reduce using rule 95 (VARSYM -> OR .)
    BOOL            reduce using rule 95 (VARSYM -> OR .)
    CHAR            reduce using rule 95 (VARSYM -> OR .)
    STRING          reduce using rule 95 (VARSYM -> OR .)
    LAMBDA          reduce using rule 95 (VARSYM -> OR .)
    LET             reduce using rule 95 (VARSYM -> OR .)
    MATCH           reduce using rule 95 (VARSYM -> OR .)
    CLOSE_PAREN     reduce using rule 95 (VARSYM -> OR .)
    CLOSE_BRACE     reduce using rule 95 (VARSYM -> OR .)
    ENDSTATEMENT    reduce using rule 95 (VARSYM -> OR .)


state 64

    (39) FUNCTION_LHS -> OPEN_PAREN FUNCTION_LHS . CLOSE_PAREN APAT APATS

    CLOSE_PAREN     shift and go to state 99


state 65

    (76) APAT -> OPEN_PAREN LPAT . CLOSE_PAREN
    (38) FUNCTION_LHS -> LPAT . VAROP LPAT
    (77) VAROP -> . VARSYM
    (78) VAROP -> . BACKTICK IDENTIFIER BACKTICK
    (82) VARSYM -> . PLUS
    (83) VARSYM -> . MINUS
    (84) VARSYM -> . TIMES
    (85) VARSYM -> . DIVIDE
    (86) VARSYM -> . MODULO
    (87) VARSYM -> . POW
    (88) VARSYM -> . EQUALITY
    (89) VARSYM -> . INEQUALITY
    (90) VARSYM -> . LESS
    (91) VARSYM -> . LEQ
    (92) VARSYM -> . GREATER
    (93) VARSYM -> . GEQ
    (94) VARSYM -> . AND
    (95) VARSYM -> . OR

    CLOSE_PAREN     shift and go to state 100
    BACKTICK        shift and go to state 49
    PLUS            shift and go to state 50
    MINUS           shift and go to state 51
    TIMES           shift and go to state 52
    DIVIDE          shift and go to state 53
    MODULO          shift and go to state 54
    POW             shift and go to state 55
    EQUALITY        shift and go to state 56
    INEQUALITY      shift and go to state 57
    LESS            shift and go to state 58
    LEQ             shift and go to state 59
    GREATER         shift and go to state 60
    GEQ             shift and go to state 61
    AND             shift and go to state 62
    OR              shift and go to state 63

    VAROP                          shift and go to state 47
    VARSYM                         shift and go to state 48

state 66

    (70) LPAT -> MINUS OPEN_PAREN . INTEGER CLOSE_PAREN
    (71) LPAT -> MINUS OPEN_PAREN . FLOAT CLOSE_PAREN

    INTEGER         shift and go to state 101
    FLOAT           shift and go to state 102


state 67

    (26) FIXITY_DECLARATION -> SETFIX ASSOCIATIVITY . INTEGER OP

    INTEGER         shift and go to state 103


state 68

    (27) ASSOCIATIVITY -> LEFTASSOC .

    INTEGER         reduce using rule 27 (ASSOCIATIVITY -> LEFTASSOC .)


state 69

    (28) ASSOCIATIVITY -> RIGHTASSOC .

    INTEGER         reduce using rule 28 (ASSOCIATIVITY -> RIGHTASSOC .)


state 70

    (29) ASSOCIATIVITY -> NONASSOC .

    INTEGER         reduce using rule 29 (ASSOCIATIVITY -> NONASSOC .)


state 71

    (2) BODY -> OPEN_BRACE IMPORT_DECLARATIONS ENDSTATEMENT TOP_DECLARATIONS . CLOSE_BRACE
    (7) TOP_DECLARATIONS -> TOP_DECLARATIONS . ENDSTATEMENT TOP_DECLARATION

    CLOSE_BRACE     shift and go to state 104
    ENDSTATEMENT    shift and go to state 34


state 72

    (4) IMPORT_DECLARATIONS -> IMPORT_DECLARATIONS ENDSTATEMENT IMPORT_DECLARATION .

    ENDSTATEMENT    reduce using rule 4 (IMPORT_DECLARATIONS -> IMPORT_DECLARATIONS ENDSTATEMENT IMPORT_DECLARATION .)


state 73

    (7) TOP_DECLARATIONS -> TOP_DECLARATIONS ENDSTATEMENT TOP_DECLARATION .

    CLOSE_BRACE     reduce using rule 7 (TOP_DECLARATIONS -> TOP_DECLARATIONS ENDSTATEMENT TOP_DECLARATION .)
    ENDSTATEMENT    reduce using rule 7 (TOP_DECLARATIONS -> TOP_DECLARATIONS ENDSTATEMENT TOP_DECLARATION .)


state 74

    (80) APATS -> APAT . APATS
    (80) APATS -> . APAT APATS
    (81) APATS -> .
    (73) APAT -> . PARAM
    (74) APAT -> . TYPENAME
    (75) APAT -> . LITERAL
    (76) APAT -> . OPEN_PAREN LPAT CLOSE_PAREN
    (103) PARAM -> . IDENTIFIER
    (96) LITERAL -> . FLOAT
    (97) LITERAL -> . INTEGER
    (98) LITERAL -> . BOOL
    (99) LITERAL -> . CHAR
    (100) LITERAL -> . STRING

    EQUALS          reduce using rule 81 (APATS -> .)
    GIVEN           reduce using rule 81 (APATS -> .)
    CLOSE_PAREN     reduce using rule 81 (APATS -> .)
    BACKTICK        reduce using rule 81 (APATS -> .)
    PLUS            reduce using rule 81 (APATS -> .)
    MINUS           reduce using rule 81 (APATS -> .)
    TIMES           reduce using rule 81 (APATS -> .)
    DIVIDE          reduce using rule 81 (APATS -> .)
    MODULO          reduce using rule 81 (APATS -> .)
    POW             reduce using rule 81 (APATS -> .)
    EQUALITY        reduce using rule 81 (APATS -> .)
    INEQUALITY      reduce using rule 81 (APATS -> .)
    LESS            reduce using rule 81 (APATS -> .)
    LEQ             reduce using rule 81 (APATS -> .)
    GREATER         reduce using rule 81 (APATS -> .)
    GEQ             reduce using rule 81 (APATS -> .)
    AND             reduce using rule 81 (APATS -> .)
    OR              reduce using rule 81 (APATS -> .)
    ARROW           reduce using rule 81 (APATS -> .)
    TYPENAME        shift and go to state 38
    OPEN_PAREN      shift and go to state 39
    IDENTIFIER      shift and go to state 36
    FLOAT           shift and go to state 25
    INTEGER         shift and go to state 24
    BOOL            shift and go to state 29
    CHAR            shift and go to state 30
    STRING          shift and go to state 31

    APAT                           shift and go to state 74
    APATS                          shift and go to state 105
    PARAM                          shift and go to state 27
    LITERAL                        shift and go to state 28

state 75

    (37) FUNCTION_LHS -> IDENTIFIER APAT APATS .

    EQUALS          reduce using rule 37 (FUNCTION_LHS -> IDENTIFIER APAT APATS .)
    GIVEN           reduce using rule 37 (FUNCTION_LHS -> IDENTIFIER APAT APATS .)
    CLOSE_PAREN     reduce using rule 37 (FUNCTION_LHS -> IDENTIFIER APAT APATS .)


state 76

    (76) APAT -> OPEN_PAREN LPAT . CLOSE_PAREN

    CLOSE_PAREN     shift and go to state 100


state 77

    (11) TYPE_DECLARATION -> NEWTYPE TYPENAME TYVARS . EQUALS CONSTRUCTORS
    (12) TYVARS -> TYVARS . IDENTIFIER

    EQUALS          shift and go to state 106
    IDENTIFIER      shift and go to state 107


state 78

    (72) LPAT -> TYPENAME APAT APATS .

    EQUALS          reduce using rule 72 (LPAT -> TYPENAME APAT APATS .)
    BACKTICK        reduce using rule 72 (LPAT -> TYPENAME APAT APATS .)
    GIVEN           reduce using rule 72 (LPAT -> TYPENAME APAT APATS .)
    PLUS            reduce using rule 72 (LPAT -> TYPENAME APAT APATS .)
    MINUS           reduce using rule 72 (LPAT -> TYPENAME APAT APATS .)
    TIMES           reduce using rule 72 (LPAT -> TYPENAME APAT APATS .)
    DIVIDE          reduce using rule 72 (LPAT -> TYPENAME APAT APATS .)
    MODULO          reduce using rule 72 (LPAT -> TYPENAME APAT APATS .)
    POW             reduce using rule 72 (LPAT -> TYPENAME APAT APATS .)
    EQUALITY        reduce using rule 72 (LPAT -> TYPENAME APAT APATS .)
    INEQUALITY      reduce using rule 72 (LPAT -> TYPENAME APAT APATS .)
    LESS            reduce using rule 72 (LPAT -> TYPENAME APAT APATS .)
    LEQ             reduce using rule 72 (LPAT -> TYPENAME APAT APATS .)
    GREATER         reduce using rule 72 (LPAT -> TYPENAME APAT APATS .)
    GEQ             reduce using rule 72 (LPAT -> TYPENAME APAT APATS .)
    AND             reduce using rule 72 (LPAT -> TYPENAME APAT APATS .)
    OR              reduce using rule 72 (LPAT -> TYPENAME APAT APATS .)
    CLOSE_PAREN     reduce using rule 72 (LPAT -> TYPENAME APAT APATS .)
    ARROW           reduce using rule 72 (LPAT -> TYPENAME APAT APATS .)


state 79

    (40) RHS -> EQUALS EXP .
    (41) RHS -> EQUALS EXP . WHERE DECLARATIONS
    (52) LEXP -> EXP . IF EXP ELSE EXP

    CLOSE_BRACE     reduce using rule 40 (RHS -> EQUALS EXP .)
    ENDSTATEMENT    reduce using rule 40 (RHS -> EQUALS EXP .)
    WHERE           shift and go to state 108
    IF              shift and go to state 109


state 80

    (46) EXP -> INFIX_EXP .

    WHERE           reduce using rule 46 (EXP -> INFIX_EXP .)
    IF              reduce using rule 46 (EXP -> INFIX_EXP .)
    CLOSE_BRACE     reduce using rule 46 (EXP -> INFIX_EXP .)
    ENDSTATEMENT    reduce using rule 46 (EXP -> INFIX_EXP .)
    EQUALS          reduce using rule 46 (EXP -> INFIX_EXP .)
    OF              reduce using rule 46 (EXP -> INFIX_EXP .)
    CLOSE_PAREN     reduce using rule 46 (EXP -> INFIX_EXP .)
    ELSE            reduce using rule 46 (EXP -> INFIX_EXP .)
    GIVEN           reduce using rule 46 (EXP -> INFIX_EXP .)
    BACKTICK        reduce using rule 46 (EXP -> INFIX_EXP .)
    PLUS            reduce using rule 46 (EXP -> INFIX_EXP .)
    MINUS           reduce using rule 46 (EXP -> INFIX_EXP .)
    TIMES           reduce using rule 46 (EXP -> INFIX_EXP .)
    DIVIDE          reduce using rule 46 (EXP -> INFIX_EXP .)
    MODULO          reduce using rule 46 (EXP -> INFIX_EXP .)
    POW             reduce using rule 46 (EXP -> INFIX_EXP .)
    EQUALITY        reduce using rule 46 (EXP -> INFIX_EXP .)
    INEQUALITY      reduce using rule 46 (EXP -> INFIX_EXP .)
    LESS            reduce using rule 46 (EXP -> INFIX_EXP .)
    LEQ             reduce using rule 46 (EXP -> INFIX_EXP .)
    GREATER         reduce using rule 46 (EXP -> INFIX_EXP .)
    GEQ             reduce using rule 46 (EXP -> INFIX_EXP .)
    AND             reduce using rule 46 (EXP -> INFIX_EXP .)
    OR              reduce using rule 46 (EXP -> INFIX_EXP .)


state 81

    (47) INFIX_EXP -> LEXP . OP INFIX_EXP
    (49) INFIX_EXP -> LEXP .
    (79) OP -> . VAROP
    (77) VAROP -> . VARSYM
    (78) VAROP -> . BACKTICK IDENTIFIER BACKTICK
    (82) VARSYM -> . PLUS
    (83) VARSYM -> . MINUS
    (84) VARSYM -> . TIMES
    (85) VARSYM -> . DIVIDE
    (86) VARSYM -> . MODULO
    (87) VARSYM -> . POW
    (88) VARSYM -> . EQUALITY
    (89) VARSYM -> . INEQUALITY
    (90) VARSYM -> . LESS
    (91) VARSYM -> . LEQ
    (92) VARSYM -> . GREATER
    (93) VARSYM -> . GEQ
    (94) VARSYM -> . AND
    (95) VARSYM -> . OR

  ! shift/reduce conflict for BACKTICK resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MODULO resolved as shift
  ! shift/reduce conflict for POW resolved as shift
  ! shift/reduce conflict for EQUALITY resolved as shift
  ! shift/reduce conflict for INEQUALITY resolved as shift
  ! shift/reduce conflict for LESS resolved as shift
  ! shift/reduce conflict for LEQ resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for GEQ resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    WHERE           reduce using rule 49 (INFIX_EXP -> LEXP .)
    IF              reduce using rule 49 (INFIX_EXP -> LEXP .)
    CLOSE_BRACE     reduce using rule 49 (INFIX_EXP -> LEXP .)
    ENDSTATEMENT    reduce using rule 49 (INFIX_EXP -> LEXP .)
    EQUALS          reduce using rule 49 (INFIX_EXP -> LEXP .)
    OF              reduce using rule 49 (INFIX_EXP -> LEXP .)
    ELSE            reduce using rule 49 (INFIX_EXP -> LEXP .)
    CLOSE_PAREN     reduce using rule 49 (INFIX_EXP -> LEXP .)
    GIVEN           reduce using rule 49 (INFIX_EXP -> LEXP .)
    BACKTICK        shift and go to state 49
    PLUS            shift and go to state 50
    MINUS           shift and go to state 51
    TIMES           shift and go to state 52
    DIVIDE          shift and go to state 53
    MODULO          shift and go to state 54
    POW             shift and go to state 55
    EQUALITY        shift and go to state 56
    INEQUALITY      shift and go to state 57
    LESS            shift and go to state 58
    LEQ             shift and go to state 59
    GREATER         shift and go to state 60
    GEQ             shift and go to state 61
    AND             shift and go to state 62
    OR              shift and go to state 63

  ! BACKTICK        [ reduce using rule 49 (INFIX_EXP -> LEXP .) ]
  ! PLUS            [ reduce using rule 49 (INFIX_EXP -> LEXP .) ]
  ! MINUS           [ reduce using rule 49 (INFIX_EXP -> LEXP .) ]
  ! TIMES           [ reduce using rule 49 (INFIX_EXP -> LEXP .) ]
  ! DIVIDE          [ reduce using rule 49 (INFIX_EXP -> LEXP .) ]
  ! MODULO          [ reduce using rule 49 (INFIX_EXP -> LEXP .) ]
  ! POW             [ reduce using rule 49 (INFIX_EXP -> LEXP .) ]
  ! EQUALITY        [ reduce using rule 49 (INFIX_EXP -> LEXP .) ]
  ! INEQUALITY      [ reduce using rule 49 (INFIX_EXP -> LEXP .) ]
  ! LESS            [ reduce using rule 49 (INFIX_EXP -> LEXP .) ]
  ! LEQ             [ reduce using rule 49 (INFIX_EXP -> LEXP .) ]
  ! GREATER         [ reduce using rule 49 (INFIX_EXP -> LEXP .) ]
  ! GEQ             [ reduce using rule 49 (INFIX_EXP -> LEXP .) ]
  ! AND             [ reduce using rule 49 (INFIX_EXP -> LEXP .) ]
  ! OR              [ reduce using rule 49 (INFIX_EXP -> LEXP .) ]

    OP                             shift and go to state 110
    VAROP                          shift and go to state 111
    VARSYM                         shift and go to state 48

state 82

    (48) INFIX_EXP -> MINUS . INFIX_EXP
    (47) INFIX_EXP -> . LEXP OP INFIX_EXP
    (48) INFIX_EXP -> . MINUS INFIX_EXP
    (49) INFIX_EXP -> . LEXP
    (50) LEXP -> . LAMBDA APAT APATS ARROW EXP
    (51) LEXP -> . LET DECLARATIONS IN EXP
    (52) LEXP -> . EXP IF EXP ELSE EXP
    (53) LEXP -> . MATCH EXP OF OPEN_BRACE ALTS CLOSE_BRACE
    (54) LEXP -> . FEXP
    (46) EXP -> . INFIX_EXP
    (55) FEXP -> . FEXP AEXP
    (56) FEXP -> . AEXP
    (57) AEXP -> . USED_VAR
    (58) AEXP -> . USED_TYPENAME
    (59) AEXP -> . LITERAL
    (60) AEXP -> . OPERATOR_FUNC
    (61) AEXP -> . OPEN_PAREN EXP CLOSE_PAREN
    (101) USED_VAR -> . IDENTIFIER
    (102) USED_TYPENAME -> . TYPENAME
    (96) LITERAL -> . FLOAT
    (97) LITERAL -> . INTEGER
    (98) LITERAL -> . BOOL
    (99) LITERAL -> . CHAR
    (100) LITERAL -> . STRING
    (62) OPERATOR_FUNC -> . OPEN_PAREN OP CLOSE_PAREN

    MINUS           shift and go to state 82
    LAMBDA          shift and go to state 83
    LET             shift and go to state 84
    MATCH           shift and go to state 85
    OPEN_PAREN      shift and go to state 92
    IDENTIFIER      shift and go to state 93
    TYPENAME        shift and go to state 94
    FLOAT           shift and go to state 25
    INTEGER         shift and go to state 24
    BOOL            shift and go to state 29
    CHAR            shift and go to state 30
    STRING          shift and go to state 31

    INFIX_EXP                      shift and go to state 112
    LEXP                           shift and go to state 81
    EXP                            shift and go to state 113
    FEXP                           shift and go to state 86
    AEXP                           shift and go to state 87
    USED_VAR                       shift and go to state 88
    USED_TYPENAME                  shift and go to state 89
    LITERAL                        shift and go to state 90
    OPERATOR_FUNC                  shift and go to state 91

state 83

    (50) LEXP -> LAMBDA . APAT APATS ARROW EXP
    (73) APAT -> . PARAM
    (74) APAT -> . TYPENAME
    (75) APAT -> . LITERAL
    (76) APAT -> . OPEN_PAREN LPAT CLOSE_PAREN
    (103) PARAM -> . IDENTIFIER
    (96) LITERAL -> . FLOAT
    (97) LITERAL -> . INTEGER
    (98) LITERAL -> . BOOL
    (99) LITERAL -> . CHAR
    (100) LITERAL -> . STRING

    TYPENAME        shift and go to state 38
    OPEN_PAREN      shift and go to state 39
    IDENTIFIER      shift and go to state 36
    FLOAT           shift and go to state 25
    INTEGER         shift and go to state 24
    BOOL            shift and go to state 29
    CHAR            shift and go to state 30
    STRING          shift and go to state 31

    APAT                           shift and go to state 114
    PARAM                          shift and go to state 27
    LITERAL                        shift and go to state 28

state 84

    (51) LEXP -> LET . DECLARATIONS IN EXP
    (17) DECLARATIONS -> . OPEN_BRACE DECLARATIONS_LIST CLOSE_BRACE
    (18) DECLARATIONS -> . OPEN_BRACE CLOSE_BRACE

    OPEN_BRACE      shift and go to state 116

    DECLARATIONS                   shift and go to state 115

state 85

    (53) LEXP -> MATCH . EXP OF OPEN_BRACE ALTS CLOSE_BRACE
    (46) EXP -> . INFIX_EXP
    (47) INFIX_EXP -> . LEXP OP INFIX_EXP
    (48) INFIX_EXP -> . MINUS INFIX_EXP
    (49) INFIX_EXP -> . LEXP
    (50) LEXP -> . LAMBDA APAT APATS ARROW EXP
    (51) LEXP -> . LET DECLARATIONS IN EXP
    (52) LEXP -> . EXP IF EXP ELSE EXP
    (53) LEXP -> . MATCH EXP OF OPEN_BRACE ALTS CLOSE_BRACE
    (54) LEXP -> . FEXP
    (55) FEXP -> . FEXP AEXP
    (56) FEXP -> . AEXP
    (57) AEXP -> . USED_VAR
    (58) AEXP -> . USED_TYPENAME
    (59) AEXP -> . LITERAL
    (60) AEXP -> . OPERATOR_FUNC
    (61) AEXP -> . OPEN_PAREN EXP CLOSE_PAREN
    (101) USED_VAR -> . IDENTIFIER
    (102) USED_TYPENAME -> . TYPENAME
    (96) LITERAL -> . FLOAT
    (97) LITERAL -> . INTEGER
    (98) LITERAL -> . BOOL
    (99) LITERAL -> . CHAR
    (100) LITERAL -> . STRING
    (62) OPERATOR_FUNC -> . OPEN_PAREN OP CLOSE_PAREN

    MINUS           shift and go to state 82
    LAMBDA          shift and go to state 83
    LET             shift and go to state 84
    MATCH           shift and go to state 85
    OPEN_PAREN      shift and go to state 92
    IDENTIFIER      shift and go to state 93
    TYPENAME        shift and go to state 94
    FLOAT           shift and go to state 25
    INTEGER         shift and go to state 24
    BOOL            shift and go to state 29
    CHAR            shift and go to state 30
    STRING          shift and go to state 31

    EXP                            shift and go to state 117
    INFIX_EXP                      shift and go to state 80
    LEXP                           shift and go to state 81
    FEXP                           shift and go to state 86
    AEXP                           shift and go to state 87
    USED_VAR                       shift and go to state 88
    USED_TYPENAME                  shift and go to state 89
    LITERAL                        shift and go to state 90
    OPERATOR_FUNC                  shift and go to state 91

state 86

    (54) LEXP -> FEXP .
    (55) FEXP -> FEXP . AEXP
    (57) AEXP -> . USED_VAR
    (58) AEXP -> . USED_TYPENAME
    (59) AEXP -> . LITERAL
    (60) AEXP -> . OPERATOR_FUNC
    (61) AEXP -> . OPEN_PAREN EXP CLOSE_PAREN
    (101) USED_VAR -> . IDENTIFIER
    (102) USED_TYPENAME -> . TYPENAME
    (96) LITERAL -> . FLOAT
    (97) LITERAL -> . INTEGER
    (98) LITERAL -> . BOOL
    (99) LITERAL -> . CHAR
    (100) LITERAL -> . STRING
    (62) OPERATOR_FUNC -> . OPEN_PAREN OP CLOSE_PAREN

    BACKTICK        reduce using rule 54 (LEXP -> FEXP .)
    PLUS            reduce using rule 54 (LEXP -> FEXP .)
    MINUS           reduce using rule 54 (LEXP -> FEXP .)
    TIMES           reduce using rule 54 (LEXP -> FEXP .)
    DIVIDE          reduce using rule 54 (LEXP -> FEXP .)
    MODULO          reduce using rule 54 (LEXP -> FEXP .)
    POW             reduce using rule 54 (LEXP -> FEXP .)
    EQUALITY        reduce using rule 54 (LEXP -> FEXP .)
    INEQUALITY      reduce using rule 54 (LEXP -> FEXP .)
    LESS            reduce using rule 54 (LEXP -> FEXP .)
    LEQ             reduce using rule 54 (LEXP -> FEXP .)
    GREATER         reduce using rule 54 (LEXP -> FEXP .)
    GEQ             reduce using rule 54 (LEXP -> FEXP .)
    AND             reduce using rule 54 (LEXP -> FEXP .)
    OR              reduce using rule 54 (LEXP -> FEXP .)
    WHERE           reduce using rule 54 (LEXP -> FEXP .)
    IF              reduce using rule 54 (LEXP -> FEXP .)
    CLOSE_BRACE     reduce using rule 54 (LEXP -> FEXP .)
    ENDSTATEMENT    reduce using rule 54 (LEXP -> FEXP .)
    EQUALS          reduce using rule 54 (LEXP -> FEXP .)
    OF              reduce using rule 54 (LEXP -> FEXP .)
    ELSE            reduce using rule 54 (LEXP -> FEXP .)
    CLOSE_PAREN     reduce using rule 54 (LEXP -> FEXP .)
    GIVEN           reduce using rule 54 (LEXP -> FEXP .)
    OPEN_PAREN      shift and go to state 92
    IDENTIFIER      shift and go to state 93
    TYPENAME        shift and go to state 94
    FLOAT           shift and go to state 25
    INTEGER         shift and go to state 24
    BOOL            shift and go to state 29
    CHAR            shift and go to state 30
    STRING          shift and go to state 31

    AEXP                           shift and go to state 118
    USED_VAR                       shift and go to state 88
    USED_TYPENAME                  shift and go to state 89
    LITERAL                        shift and go to state 90
    OPERATOR_FUNC                  shift and go to state 91

state 87

    (56) FEXP -> AEXP .

    OPEN_PAREN      reduce using rule 56 (FEXP -> AEXP .)
    IDENTIFIER      reduce using rule 56 (FEXP -> AEXP .)
    TYPENAME        reduce using rule 56 (FEXP -> AEXP .)
    FLOAT           reduce using rule 56 (FEXP -> AEXP .)
    INTEGER         reduce using rule 56 (FEXP -> AEXP .)
    BOOL            reduce using rule 56 (FEXP -> AEXP .)
    CHAR            reduce using rule 56 (FEXP -> AEXP .)
    STRING          reduce using rule 56 (FEXP -> AEXP .)
    BACKTICK        reduce using rule 56 (FEXP -> AEXP .)
    PLUS            reduce using rule 56 (FEXP -> AEXP .)
    MINUS           reduce using rule 56 (FEXP -> AEXP .)
    TIMES           reduce using rule 56 (FEXP -> AEXP .)
    DIVIDE          reduce using rule 56 (FEXP -> AEXP .)
    MODULO          reduce using rule 56 (FEXP -> AEXP .)
    POW             reduce using rule 56 (FEXP -> AEXP .)
    EQUALITY        reduce using rule 56 (FEXP -> AEXP .)
    INEQUALITY      reduce using rule 56 (FEXP -> AEXP .)
    LESS            reduce using rule 56 (FEXP -> AEXP .)
    LEQ             reduce using rule 56 (FEXP -> AEXP .)
    GREATER         reduce using rule 56 (FEXP -> AEXP .)
    GEQ             reduce using rule 56 (FEXP -> AEXP .)
    AND             reduce using rule 56 (FEXP -> AEXP .)
    OR              reduce using rule 56 (FEXP -> AEXP .)
    WHERE           reduce using rule 56 (FEXP -> AEXP .)
    IF              reduce using rule 56 (FEXP -> AEXP .)
    CLOSE_BRACE     reduce using rule 56 (FEXP -> AEXP .)
    ENDSTATEMENT    reduce using rule 56 (FEXP -> AEXP .)
    EQUALS          reduce using rule 56 (FEXP -> AEXP .)
    OF              reduce using rule 56 (FEXP -> AEXP .)
    ELSE            reduce using rule 56 (FEXP -> AEXP .)
    CLOSE_PAREN     reduce using rule 56 (FEXP -> AEXP .)
    GIVEN           reduce using rule 56 (FEXP -> AEXP .)


state 88

    (57) AEXP -> USED_VAR .

    OPEN_PAREN      reduce using rule 57 (AEXP -> USED_VAR .)
    IDENTIFIER      reduce using rule 57 (AEXP -> USED_VAR .)
    TYPENAME        reduce using rule 57 (AEXP -> USED_VAR .)
    FLOAT           reduce using rule 57 (AEXP -> USED_VAR .)
    INTEGER         reduce using rule 57 (AEXP -> USED_VAR .)
    BOOL            reduce using rule 57 (AEXP -> USED_VAR .)
    CHAR            reduce using rule 57 (AEXP -> USED_VAR .)
    STRING          reduce using rule 57 (AEXP -> USED_VAR .)
    BACKTICK        reduce using rule 57 (AEXP -> USED_VAR .)
    PLUS            reduce using rule 57 (AEXP -> USED_VAR .)
    MINUS           reduce using rule 57 (AEXP -> USED_VAR .)
    TIMES           reduce using rule 57 (AEXP -> USED_VAR .)
    DIVIDE          reduce using rule 57 (AEXP -> USED_VAR .)
    MODULO          reduce using rule 57 (AEXP -> USED_VAR .)
    POW             reduce using rule 57 (AEXP -> USED_VAR .)
    EQUALITY        reduce using rule 57 (AEXP -> USED_VAR .)
    INEQUALITY      reduce using rule 57 (AEXP -> USED_VAR .)
    LESS            reduce using rule 57 (AEXP -> USED_VAR .)
    LEQ             reduce using rule 57 (AEXP -> USED_VAR .)
    GREATER         reduce using rule 57 (AEXP -> USED_VAR .)
    GEQ             reduce using rule 57 (AEXP -> USED_VAR .)
    AND             reduce using rule 57 (AEXP -> USED_VAR .)
    OR              reduce using rule 57 (AEXP -> USED_VAR .)
    WHERE           reduce using rule 57 (AEXP -> USED_VAR .)
    IF              reduce using rule 57 (AEXP -> USED_VAR .)
    CLOSE_BRACE     reduce using rule 57 (AEXP -> USED_VAR .)
    ENDSTATEMENT    reduce using rule 57 (AEXP -> USED_VAR .)
    EQUALS          reduce using rule 57 (AEXP -> USED_VAR .)
    OF              reduce using rule 57 (AEXP -> USED_VAR .)
    ELSE            reduce using rule 57 (AEXP -> USED_VAR .)
    CLOSE_PAREN     reduce using rule 57 (AEXP -> USED_VAR .)
    GIVEN           reduce using rule 57 (AEXP -> USED_VAR .)


state 89

    (58) AEXP -> USED_TYPENAME .

    OPEN_PAREN      reduce using rule 58 (AEXP -> USED_TYPENAME .)
    IDENTIFIER      reduce using rule 58 (AEXP -> USED_TYPENAME .)
    TYPENAME        reduce using rule 58 (AEXP -> USED_TYPENAME .)
    FLOAT           reduce using rule 58 (AEXP -> USED_TYPENAME .)
    INTEGER         reduce using rule 58 (AEXP -> USED_TYPENAME .)
    BOOL            reduce using rule 58 (AEXP -> USED_TYPENAME .)
    CHAR            reduce using rule 58 (AEXP -> USED_TYPENAME .)
    STRING          reduce using rule 58 (AEXP -> USED_TYPENAME .)
    BACKTICK        reduce using rule 58 (AEXP -> USED_TYPENAME .)
    PLUS            reduce using rule 58 (AEXP -> USED_TYPENAME .)
    MINUS           reduce using rule 58 (AEXP -> USED_TYPENAME .)
    TIMES           reduce using rule 58 (AEXP -> USED_TYPENAME .)
    DIVIDE          reduce using rule 58 (AEXP -> USED_TYPENAME .)
    MODULO          reduce using rule 58 (AEXP -> USED_TYPENAME .)
    POW             reduce using rule 58 (AEXP -> USED_TYPENAME .)
    EQUALITY        reduce using rule 58 (AEXP -> USED_TYPENAME .)
    INEQUALITY      reduce using rule 58 (AEXP -> USED_TYPENAME .)
    LESS            reduce using rule 58 (AEXP -> USED_TYPENAME .)
    LEQ             reduce using rule 58 (AEXP -> USED_TYPENAME .)
    GREATER         reduce using rule 58 (AEXP -> USED_TYPENAME .)
    GEQ             reduce using rule 58 (AEXP -> USED_TYPENAME .)
    AND             reduce using rule 58 (AEXP -> USED_TYPENAME .)
    OR              reduce using rule 58 (AEXP -> USED_TYPENAME .)
    WHERE           reduce using rule 58 (AEXP -> USED_TYPENAME .)
    IF              reduce using rule 58 (AEXP -> USED_TYPENAME .)
    CLOSE_BRACE     reduce using rule 58 (AEXP -> USED_TYPENAME .)
    ENDSTATEMENT    reduce using rule 58 (AEXP -> USED_TYPENAME .)
    EQUALS          reduce using rule 58 (AEXP -> USED_TYPENAME .)
    OF              reduce using rule 58 (AEXP -> USED_TYPENAME .)
    ELSE            reduce using rule 58 (AEXP -> USED_TYPENAME .)
    CLOSE_PAREN     reduce using rule 58 (AEXP -> USED_TYPENAME .)
    GIVEN           reduce using rule 58 (AEXP -> USED_TYPENAME .)


state 90

    (59) AEXP -> LITERAL .

    OPEN_PAREN      reduce using rule 59 (AEXP -> LITERAL .)
    IDENTIFIER      reduce using rule 59 (AEXP -> LITERAL .)
    TYPENAME        reduce using rule 59 (AEXP -> LITERAL .)
    FLOAT           reduce using rule 59 (AEXP -> LITERAL .)
    INTEGER         reduce using rule 59 (AEXP -> LITERAL .)
    BOOL            reduce using rule 59 (AEXP -> LITERAL .)
    CHAR            reduce using rule 59 (AEXP -> LITERAL .)
    STRING          reduce using rule 59 (AEXP -> LITERAL .)
    BACKTICK        reduce using rule 59 (AEXP -> LITERAL .)
    PLUS            reduce using rule 59 (AEXP -> LITERAL .)
    MINUS           reduce using rule 59 (AEXP -> LITERAL .)
    TIMES           reduce using rule 59 (AEXP -> LITERAL .)
    DIVIDE          reduce using rule 59 (AEXP -> LITERAL .)
    MODULO          reduce using rule 59 (AEXP -> LITERAL .)
    POW             reduce using rule 59 (AEXP -> LITERAL .)
    EQUALITY        reduce using rule 59 (AEXP -> LITERAL .)
    INEQUALITY      reduce using rule 59 (AEXP -> LITERAL .)
    LESS            reduce using rule 59 (AEXP -> LITERAL .)
    LEQ             reduce using rule 59 (AEXP -> LITERAL .)
    GREATER         reduce using rule 59 (AEXP -> LITERAL .)
    GEQ             reduce using rule 59 (AEXP -> LITERAL .)
    AND             reduce using rule 59 (AEXP -> LITERAL .)
    OR              reduce using rule 59 (AEXP -> LITERAL .)
    WHERE           reduce using rule 59 (AEXP -> LITERAL .)
    IF              reduce using rule 59 (AEXP -> LITERAL .)
    CLOSE_BRACE     reduce using rule 59 (AEXP -> LITERAL .)
    ENDSTATEMENT    reduce using rule 59 (AEXP -> LITERAL .)
    EQUALS          reduce using rule 59 (AEXP -> LITERAL .)
    OF              reduce using rule 59 (AEXP -> LITERAL .)
    ELSE            reduce using rule 59 (AEXP -> LITERAL .)
    CLOSE_PAREN     reduce using rule 59 (AEXP -> LITERAL .)
    GIVEN           reduce using rule 59 (AEXP -> LITERAL .)


state 91

    (60) AEXP -> OPERATOR_FUNC .

    OPEN_PAREN      reduce using rule 60 (AEXP -> OPERATOR_FUNC .)
    IDENTIFIER      reduce using rule 60 (AEXP -> OPERATOR_FUNC .)
    TYPENAME        reduce using rule 60 (AEXP -> OPERATOR_FUNC .)
    FLOAT           reduce using rule 60 (AEXP -> OPERATOR_FUNC .)
    INTEGER         reduce using rule 60 (AEXP -> OPERATOR_FUNC .)
    BOOL            reduce using rule 60 (AEXP -> OPERATOR_FUNC .)
    CHAR            reduce using rule 60 (AEXP -> OPERATOR_FUNC .)
    STRING          reduce using rule 60 (AEXP -> OPERATOR_FUNC .)
    BACKTICK        reduce using rule 60 (AEXP -> OPERATOR_FUNC .)
    PLUS            reduce using rule 60 (AEXP -> OPERATOR_FUNC .)
    MINUS           reduce using rule 60 (AEXP -> OPERATOR_FUNC .)
    TIMES           reduce using rule 60 (AEXP -> OPERATOR_FUNC .)
    DIVIDE          reduce using rule 60 (AEXP -> OPERATOR_FUNC .)
    MODULO          reduce using rule 60 (AEXP -> OPERATOR_FUNC .)
    POW             reduce using rule 60 (AEXP -> OPERATOR_FUNC .)
    EQUALITY        reduce using rule 60 (AEXP -> OPERATOR_FUNC .)
    INEQUALITY      reduce using rule 60 (AEXP -> OPERATOR_FUNC .)
    LESS            reduce using rule 60 (AEXP -> OPERATOR_FUNC .)
    LEQ             reduce using rule 60 (AEXP -> OPERATOR_FUNC .)
    GREATER         reduce using rule 60 (AEXP -> OPERATOR_FUNC .)
    GEQ             reduce using rule 60 (AEXP -> OPERATOR_FUNC .)
    AND             reduce using rule 60 (AEXP -> OPERATOR_FUNC .)
    OR              reduce using rule 60 (AEXP -> OPERATOR_FUNC .)
    WHERE           reduce using rule 60 (AEXP -> OPERATOR_FUNC .)
    IF              reduce using rule 60 (AEXP -> OPERATOR_FUNC .)
    CLOSE_BRACE     reduce using rule 60 (AEXP -> OPERATOR_FUNC .)
    ENDSTATEMENT    reduce using rule 60 (AEXP -> OPERATOR_FUNC .)
    EQUALS          reduce using rule 60 (AEXP -> OPERATOR_FUNC .)
    OF              reduce using rule 60 (AEXP -> OPERATOR_FUNC .)
    ELSE            reduce using rule 60 (AEXP -> OPERATOR_FUNC .)
    CLOSE_PAREN     reduce using rule 60 (AEXP -> OPERATOR_FUNC .)
    GIVEN           reduce using rule 60 (AEXP -> OPERATOR_FUNC .)


state 92

    (61) AEXP -> OPEN_PAREN . EXP CLOSE_PAREN
    (62) OPERATOR_FUNC -> OPEN_PAREN . OP CLOSE_PAREN
    (46) EXP -> . INFIX_EXP
    (79) OP -> . VAROP
    (47) INFIX_EXP -> . LEXP OP INFIX_EXP
    (48) INFIX_EXP -> . MINUS INFIX_EXP
    (49) INFIX_EXP -> . LEXP
    (77) VAROP -> . VARSYM
    (78) VAROP -> . BACKTICK IDENTIFIER BACKTICK
    (50) LEXP -> . LAMBDA APAT APATS ARROW EXP
    (51) LEXP -> . LET DECLARATIONS IN EXP
    (52) LEXP -> . EXP IF EXP ELSE EXP
    (53) LEXP -> . MATCH EXP OF OPEN_BRACE ALTS CLOSE_BRACE
    (54) LEXP -> . FEXP
    (82) VARSYM -> . PLUS
    (83) VARSYM -> . MINUS
    (84) VARSYM -> . TIMES
    (85) VARSYM -> . DIVIDE
    (86) VARSYM -> . MODULO
    (87) VARSYM -> . POW
    (88) VARSYM -> . EQUALITY
    (89) VARSYM -> . INEQUALITY
    (90) VARSYM -> . LESS
    (91) VARSYM -> . LEQ
    (92) VARSYM -> . GREATER
    (93) VARSYM -> . GEQ
    (94) VARSYM -> . AND
    (95) VARSYM -> . OR
    (55) FEXP -> . FEXP AEXP
    (56) FEXP -> . AEXP
    (57) AEXP -> . USED_VAR
    (58) AEXP -> . USED_TYPENAME
    (59) AEXP -> . LITERAL
    (60) AEXP -> . OPERATOR_FUNC
    (61) AEXP -> . OPEN_PAREN EXP CLOSE_PAREN
    (101) USED_VAR -> . IDENTIFIER
    (102) USED_TYPENAME -> . TYPENAME
    (96) LITERAL -> . FLOAT
    (97) LITERAL -> . INTEGER
    (98) LITERAL -> . BOOL
    (99) LITERAL -> . CHAR
    (100) LITERAL -> . STRING
    (62) OPERATOR_FUNC -> . OPEN_PAREN OP CLOSE_PAREN

    MINUS           shift and go to state 121
    BACKTICK        shift and go to state 49
    LAMBDA          shift and go to state 83
    LET             shift and go to state 84
    MATCH           shift and go to state 85
    PLUS            shift and go to state 50
    TIMES           shift and go to state 52
    DIVIDE          shift and go to state 53
    MODULO          shift and go to state 54
    POW             shift and go to state 55
    EQUALITY        shift and go to state 56
    INEQUALITY      shift and go to state 57
    LESS            shift and go to state 58
    LEQ             shift and go to state 59
    GREATER         shift and go to state 60
    GEQ             shift and go to state 61
    AND             shift and go to state 62
    OR              shift and go to state 63
    OPEN_PAREN      shift and go to state 92
    IDENTIFIER      shift and go to state 93
    TYPENAME        shift and go to state 94
    FLOAT           shift and go to state 25
    INTEGER         shift and go to state 24
    BOOL            shift and go to state 29
    CHAR            shift and go to state 30
    STRING          shift and go to state 31

    EXP                            shift and go to state 119
    OP                             shift and go to state 120
    INFIX_EXP                      shift and go to state 80
    VAROP                          shift and go to state 111
    LEXP                           shift and go to state 81
    VARSYM                         shift and go to state 48
    FEXP                           shift and go to state 86
    AEXP                           shift and go to state 87
    USED_VAR                       shift and go to state 88
    USED_TYPENAME                  shift and go to state 89
    LITERAL                        shift and go to state 90
    OPERATOR_FUNC                  shift and go to state 91

state 93

    (101) USED_VAR -> IDENTIFIER .

    OPEN_PAREN      reduce using rule 101 (USED_VAR -> IDENTIFIER .)
    IDENTIFIER      reduce using rule 101 (USED_VAR -> IDENTIFIER .)
    TYPENAME        reduce using rule 101 (USED_VAR -> IDENTIFIER .)
    FLOAT           reduce using rule 101 (USED_VAR -> IDENTIFIER .)
    INTEGER         reduce using rule 101 (USED_VAR -> IDENTIFIER .)
    BOOL            reduce using rule 101 (USED_VAR -> IDENTIFIER .)
    CHAR            reduce using rule 101 (USED_VAR -> IDENTIFIER .)
    STRING          reduce using rule 101 (USED_VAR -> IDENTIFIER .)
    BACKTICK        reduce using rule 101 (USED_VAR -> IDENTIFIER .)
    PLUS            reduce using rule 101 (USED_VAR -> IDENTIFIER .)
    MINUS           reduce using rule 101 (USED_VAR -> IDENTIFIER .)
    TIMES           reduce using rule 101 (USED_VAR -> IDENTIFIER .)
    DIVIDE          reduce using rule 101 (USED_VAR -> IDENTIFIER .)
    MODULO          reduce using rule 101 (USED_VAR -> IDENTIFIER .)
    POW             reduce using rule 101 (USED_VAR -> IDENTIFIER .)
    EQUALITY        reduce using rule 101 (USED_VAR -> IDENTIFIER .)
    INEQUALITY      reduce using rule 101 (USED_VAR -> IDENTIFIER .)
    LESS            reduce using rule 101 (USED_VAR -> IDENTIFIER .)
    LEQ             reduce using rule 101 (USED_VAR -> IDENTIFIER .)
    GREATER         reduce using rule 101 (USED_VAR -> IDENTIFIER .)
    GEQ             reduce using rule 101 (USED_VAR -> IDENTIFIER .)
    AND             reduce using rule 101 (USED_VAR -> IDENTIFIER .)
    OR              reduce using rule 101 (USED_VAR -> IDENTIFIER .)
    WHERE           reduce using rule 101 (USED_VAR -> IDENTIFIER .)
    IF              reduce using rule 101 (USED_VAR -> IDENTIFIER .)
    CLOSE_BRACE     reduce using rule 101 (USED_VAR -> IDENTIFIER .)
    ENDSTATEMENT    reduce using rule 101 (USED_VAR -> IDENTIFIER .)
    EQUALS          reduce using rule 101 (USED_VAR -> IDENTIFIER .)
    OF              reduce using rule 101 (USED_VAR -> IDENTIFIER .)
    ELSE            reduce using rule 101 (USED_VAR -> IDENTIFIER .)
    CLOSE_PAREN     reduce using rule 101 (USED_VAR -> IDENTIFIER .)
    GIVEN           reduce using rule 101 (USED_VAR -> IDENTIFIER .)


state 94

    (102) USED_TYPENAME -> TYPENAME .

    OPEN_PAREN      reduce using rule 102 (USED_TYPENAME -> TYPENAME .)
    IDENTIFIER      reduce using rule 102 (USED_TYPENAME -> TYPENAME .)
    TYPENAME        reduce using rule 102 (USED_TYPENAME -> TYPENAME .)
    FLOAT           reduce using rule 102 (USED_TYPENAME -> TYPENAME .)
    INTEGER         reduce using rule 102 (USED_TYPENAME -> TYPENAME .)
    BOOL            reduce using rule 102 (USED_TYPENAME -> TYPENAME .)
    CHAR            reduce using rule 102 (USED_TYPENAME -> TYPENAME .)
    STRING          reduce using rule 102 (USED_TYPENAME -> TYPENAME .)
    BACKTICK        reduce using rule 102 (USED_TYPENAME -> TYPENAME .)
    PLUS            reduce using rule 102 (USED_TYPENAME -> TYPENAME .)
    MINUS           reduce using rule 102 (USED_TYPENAME -> TYPENAME .)
    TIMES           reduce using rule 102 (USED_TYPENAME -> TYPENAME .)
    DIVIDE          reduce using rule 102 (USED_TYPENAME -> TYPENAME .)
    MODULO          reduce using rule 102 (USED_TYPENAME -> TYPENAME .)
    POW             reduce using rule 102 (USED_TYPENAME -> TYPENAME .)
    EQUALITY        reduce using rule 102 (USED_TYPENAME -> TYPENAME .)
    INEQUALITY      reduce using rule 102 (USED_TYPENAME -> TYPENAME .)
    LESS            reduce using rule 102 (USED_TYPENAME -> TYPENAME .)
    LEQ             reduce using rule 102 (USED_TYPENAME -> TYPENAME .)
    GREATER         reduce using rule 102 (USED_TYPENAME -> TYPENAME .)
    GEQ             reduce using rule 102 (USED_TYPENAME -> TYPENAME .)
    AND             reduce using rule 102 (USED_TYPENAME -> TYPENAME .)
    OR              reduce using rule 102 (USED_TYPENAME -> TYPENAME .)
    WHERE           reduce using rule 102 (USED_TYPENAME -> TYPENAME .)
    IF              reduce using rule 102 (USED_TYPENAME -> TYPENAME .)
    CLOSE_BRACE     reduce using rule 102 (USED_TYPENAME -> TYPENAME .)
    ENDSTATEMENT    reduce using rule 102 (USED_TYPENAME -> TYPENAME .)
    EQUALS          reduce using rule 102 (USED_TYPENAME -> TYPENAME .)
    OF              reduce using rule 102 (USED_TYPENAME -> TYPENAME .)
    ELSE            reduce using rule 102 (USED_TYPENAME -> TYPENAME .)
    CLOSE_PAREN     reduce using rule 102 (USED_TYPENAME -> TYPENAME .)
    GIVEN           reduce using rule 102 (USED_TYPENAME -> TYPENAME .)


state 95

    (43) RHS -> GDRHS WHERE . DECLARATIONS
    (17) DECLARATIONS -> . OPEN_BRACE DECLARATIONS_LIST CLOSE_BRACE
    (18) DECLARATIONS -> . OPEN_BRACE CLOSE_BRACE

    OPEN_BRACE      shift and go to state 116

    DECLARATIONS                   shift and go to state 122

state 96

    (44) GDRHS -> GIVEN EXP . EQUALS EXP
    (45) GDRHS -> GIVEN EXP . EQUALS EXP GDRHS
    (52) LEXP -> EXP . IF EXP ELSE EXP

    EQUALS          shift and go to state 123
    IF              shift and go to state 109


state 97

    (38) FUNCTION_LHS -> LPAT VAROP LPAT .

    EQUALS          reduce using rule 38 (FUNCTION_LHS -> LPAT VAROP LPAT .)
    GIVEN           reduce using rule 38 (FUNCTION_LHS -> LPAT VAROP LPAT .)
    CLOSE_PAREN     reduce using rule 38 (FUNCTION_LHS -> LPAT VAROP LPAT .)


state 98

    (78) VAROP -> BACKTICK IDENTIFIER . BACKTICK

    BACKTICK        shift and go to state 124


state 99

    (39) FUNCTION_LHS -> OPEN_PAREN FUNCTION_LHS CLOSE_PAREN . APAT APATS
    (73) APAT -> . PARAM
    (74) APAT -> . TYPENAME
    (75) APAT -> . LITERAL
    (76) APAT -> . OPEN_PAREN LPAT CLOSE_PAREN
    (103) PARAM -> . IDENTIFIER
    (96) LITERAL -> . FLOAT
    (97) LITERAL -> . INTEGER
    (98) LITERAL -> . BOOL
    (99) LITERAL -> . CHAR
    (100) LITERAL -> . STRING

    TYPENAME        shift and go to state 38
    OPEN_PAREN      shift and go to state 39
    IDENTIFIER      shift and go to state 36
    FLOAT           shift and go to state 25
    INTEGER         shift and go to state 24
    BOOL            shift and go to state 29
    CHAR            shift and go to state 30
    STRING          shift and go to state 31

    APAT                           shift and go to state 125
    PARAM                          shift and go to state 27
    LITERAL                        shift and go to state 28

state 100

    (76) APAT -> OPEN_PAREN LPAT CLOSE_PAREN .

    EQUALS          reduce using rule 76 (APAT -> OPEN_PAREN LPAT CLOSE_PAREN .)
    BACKTICK        reduce using rule 76 (APAT -> OPEN_PAREN LPAT CLOSE_PAREN .)
    GIVEN           reduce using rule 76 (APAT -> OPEN_PAREN LPAT CLOSE_PAREN .)
    PLUS            reduce using rule 76 (APAT -> OPEN_PAREN LPAT CLOSE_PAREN .)
    MINUS           reduce using rule 76 (APAT -> OPEN_PAREN LPAT CLOSE_PAREN .)
    TIMES           reduce using rule 76 (APAT -> OPEN_PAREN LPAT CLOSE_PAREN .)
    DIVIDE          reduce using rule 76 (APAT -> OPEN_PAREN LPAT CLOSE_PAREN .)
    MODULO          reduce using rule 76 (APAT -> OPEN_PAREN LPAT CLOSE_PAREN .)
    POW             reduce using rule 76 (APAT -> OPEN_PAREN LPAT CLOSE_PAREN .)
    EQUALITY        reduce using rule 76 (APAT -> OPEN_PAREN LPAT CLOSE_PAREN .)
    INEQUALITY      reduce using rule 76 (APAT -> OPEN_PAREN LPAT CLOSE_PAREN .)
    LESS            reduce using rule 76 (APAT -> OPEN_PAREN LPAT CLOSE_PAREN .)
    LEQ             reduce using rule 76 (APAT -> OPEN_PAREN LPAT CLOSE_PAREN .)
    GREATER         reduce using rule 76 (APAT -> OPEN_PAREN LPAT CLOSE_PAREN .)
    GEQ             reduce using rule 76 (APAT -> OPEN_PAREN LPAT CLOSE_PAREN .)
    AND             reduce using rule 76 (APAT -> OPEN_PAREN LPAT CLOSE_PAREN .)
    OR              reduce using rule 76 (APAT -> OPEN_PAREN LPAT CLOSE_PAREN .)
    TYPENAME        reduce using rule 76 (APAT -> OPEN_PAREN LPAT CLOSE_PAREN .)
    OPEN_PAREN      reduce using rule 76 (APAT -> OPEN_PAREN LPAT CLOSE_PAREN .)
    IDENTIFIER      reduce using rule 76 (APAT -> OPEN_PAREN LPAT CLOSE_PAREN .)
    FLOAT           reduce using rule 76 (APAT -> OPEN_PAREN LPAT CLOSE_PAREN .)
    INTEGER         reduce using rule 76 (APAT -> OPEN_PAREN LPAT CLOSE_PAREN .)
    BOOL            reduce using rule 76 (APAT -> OPEN_PAREN LPAT CLOSE_PAREN .)
    CHAR            reduce using rule 76 (APAT -> OPEN_PAREN LPAT CLOSE_PAREN .)
    STRING          reduce using rule 76 (APAT -> OPEN_PAREN LPAT CLOSE_PAREN .)
    CLOSE_PAREN     reduce using rule 76 (APAT -> OPEN_PAREN LPAT CLOSE_PAREN .)
    ARROW           reduce using rule 76 (APAT -> OPEN_PAREN LPAT CLOSE_PAREN .)


state 101

    (70) LPAT -> MINUS OPEN_PAREN INTEGER . CLOSE_PAREN

    CLOSE_PAREN     shift and go to state 126


state 102

    (71) LPAT -> MINUS OPEN_PAREN FLOAT . CLOSE_PAREN

    CLOSE_PAREN     shift and go to state 127


state 103

    (26) FIXITY_DECLARATION -> SETFIX ASSOCIATIVITY INTEGER . OP
    (79) OP -> . VAROP
    (77) VAROP -> . VARSYM
    (78) VAROP -> . BACKTICK IDENTIFIER BACKTICK
    (82) VARSYM -> . PLUS
    (83) VARSYM -> . MINUS
    (84) VARSYM -> . TIMES
    (85) VARSYM -> . DIVIDE
    (86) VARSYM -> . MODULO
    (87) VARSYM -> . POW
    (88) VARSYM -> . EQUALITY
    (89) VARSYM -> . INEQUALITY
    (90) VARSYM -> . LESS
    (91) VARSYM -> . LEQ
    (92) VARSYM -> . GREATER
    (93) VARSYM -> . GEQ
    (94) VARSYM -> . AND
    (95) VARSYM -> . OR

    BACKTICK        shift and go to state 49
    PLUS            shift and go to state 50
    MINUS           shift and go to state 51
    TIMES           shift and go to state 52
    DIVIDE          shift and go to state 53
    MODULO          shift and go to state 54
    POW             shift and go to state 55
    EQUALITY        shift and go to state 56
    INEQUALITY      shift and go to state 57
    LESS            shift and go to state 58
    LEQ             shift and go to state 59
    GREATER         shift and go to state 60
    GEQ             shift and go to state 61
    AND             shift and go to state 62
    OR              shift and go to state 63

    OP                             shift and go to state 128
    VAROP                          shift and go to state 111
    VARSYM                         shift and go to state 48

state 104

    (2) BODY -> OPEN_BRACE IMPORT_DECLARATIONS ENDSTATEMENT TOP_DECLARATIONS CLOSE_BRACE .

    $end            reduce using rule 2 (BODY -> OPEN_BRACE IMPORT_DECLARATIONS ENDSTATEMENT TOP_DECLARATIONS CLOSE_BRACE .)


state 105

    (80) APATS -> APAT APATS .

    EQUALS          reduce using rule 80 (APATS -> APAT APATS .)
    GIVEN           reduce using rule 80 (APATS -> APAT APATS .)
    CLOSE_PAREN     reduce using rule 80 (APATS -> APAT APATS .)
    BACKTICK        reduce using rule 80 (APATS -> APAT APATS .)
    PLUS            reduce using rule 80 (APATS -> APAT APATS .)
    MINUS           reduce using rule 80 (APATS -> APAT APATS .)
    TIMES           reduce using rule 80 (APATS -> APAT APATS .)
    DIVIDE          reduce using rule 80 (APATS -> APAT APATS .)
    MODULO          reduce using rule 80 (APATS -> APAT APATS .)
    POW             reduce using rule 80 (APATS -> APAT APATS .)
    EQUALITY        reduce using rule 80 (APATS -> APAT APATS .)
    INEQUALITY      reduce using rule 80 (APATS -> APAT APATS .)
    LESS            reduce using rule 80 (APATS -> APAT APATS .)
    LEQ             reduce using rule 80 (APATS -> APAT APATS .)
    GREATER         reduce using rule 80 (APATS -> APAT APATS .)
    GEQ             reduce using rule 80 (APATS -> APAT APATS .)
    AND             reduce using rule 80 (APATS -> APAT APATS .)
    OR              reduce using rule 80 (APATS -> APAT APATS .)
    ARROW           reduce using rule 80 (APATS -> APAT APATS .)


state 106

    (11) TYPE_DECLARATION -> NEWTYPE TYPENAME TYVARS EQUALS . CONSTRUCTORS
    (14) CONSTRUCTORS -> . CONSTRUCTORS PIPE CONSTRUCTOR
    (15) CONSTRUCTORS -> . CONSTRUCTOR
    (16) CONSTRUCTOR -> . TYPENAME ATYPES

    TYPENAME        shift and go to state 129

    CONSTRUCTORS                   shift and go to state 130
    CONSTRUCTOR                    shift and go to state 131

state 107

    (12) TYVARS -> TYVARS IDENTIFIER .

    EQUALS          reduce using rule 12 (TYVARS -> TYVARS IDENTIFIER .)
    IDENTIFIER      reduce using rule 12 (TYVARS -> TYVARS IDENTIFIER .)


state 108

    (41) RHS -> EQUALS EXP WHERE . DECLARATIONS
    (17) DECLARATIONS -> . OPEN_BRACE DECLARATIONS_LIST CLOSE_BRACE
    (18) DECLARATIONS -> . OPEN_BRACE CLOSE_BRACE

    OPEN_BRACE      shift and go to state 116

    DECLARATIONS                   shift and go to state 132

state 109

    (52) LEXP -> EXP IF . EXP ELSE EXP
    (46) EXP -> . INFIX_EXP
    (47) INFIX_EXP -> . LEXP OP INFIX_EXP
    (48) INFIX_EXP -> . MINUS INFIX_EXP
    (49) INFIX_EXP -> . LEXP
    (50) LEXP -> . LAMBDA APAT APATS ARROW EXP
    (51) LEXP -> . LET DECLARATIONS IN EXP
    (52) LEXP -> . EXP IF EXP ELSE EXP
    (53) LEXP -> . MATCH EXP OF OPEN_BRACE ALTS CLOSE_BRACE
    (54) LEXP -> . FEXP
    (55) FEXP -> . FEXP AEXP
    (56) FEXP -> . AEXP
    (57) AEXP -> . USED_VAR
    (58) AEXP -> . USED_TYPENAME
    (59) AEXP -> . LITERAL
    (60) AEXP -> . OPERATOR_FUNC
    (61) AEXP -> . OPEN_PAREN EXP CLOSE_PAREN
    (101) USED_VAR -> . IDENTIFIER
    (102) USED_TYPENAME -> . TYPENAME
    (96) LITERAL -> . FLOAT
    (97) LITERAL -> . INTEGER
    (98) LITERAL -> . BOOL
    (99) LITERAL -> . CHAR
    (100) LITERAL -> . STRING
    (62) OPERATOR_FUNC -> . OPEN_PAREN OP CLOSE_PAREN

    MINUS           shift and go to state 82
    LAMBDA          shift and go to state 83
    LET             shift and go to state 84
    MATCH           shift and go to state 85
    OPEN_PAREN      shift and go to state 92
    IDENTIFIER      shift and go to state 93
    TYPENAME        shift and go to state 94
    FLOAT           shift and go to state 25
    INTEGER         shift and go to state 24
    BOOL            shift and go to state 29
    CHAR            shift and go to state 30
    STRING          shift and go to state 31

    EXP                            shift and go to state 133
    INFIX_EXP                      shift and go to state 80
    LEXP                           shift and go to state 81
    FEXP                           shift and go to state 86
    AEXP                           shift and go to state 87
    USED_VAR                       shift and go to state 88
    USED_TYPENAME                  shift and go to state 89
    LITERAL                        shift and go to state 90
    OPERATOR_FUNC                  shift and go to state 91

state 110

    (47) INFIX_EXP -> LEXP OP . INFIX_EXP
    (47) INFIX_EXP -> . LEXP OP INFIX_EXP
    (48) INFIX_EXP -> . MINUS INFIX_EXP
    (49) INFIX_EXP -> . LEXP
    (50) LEXP -> . LAMBDA APAT APATS ARROW EXP
    (51) LEXP -> . LET DECLARATIONS IN EXP
    (52) LEXP -> . EXP IF EXP ELSE EXP
    (53) LEXP -> . MATCH EXP OF OPEN_BRACE ALTS CLOSE_BRACE
    (54) LEXP -> . FEXP
    (46) EXP -> . INFIX_EXP
    (55) FEXP -> . FEXP AEXP
    (56) FEXP -> . AEXP
    (57) AEXP -> . USED_VAR
    (58) AEXP -> . USED_TYPENAME
    (59) AEXP -> . LITERAL
    (60) AEXP -> . OPERATOR_FUNC
    (61) AEXP -> . OPEN_PAREN EXP CLOSE_PAREN
    (101) USED_VAR -> . IDENTIFIER
    (102) USED_TYPENAME -> . TYPENAME
    (96) LITERAL -> . FLOAT
    (97) LITERAL -> . INTEGER
    (98) LITERAL -> . BOOL
    (99) LITERAL -> . CHAR
    (100) LITERAL -> . STRING
    (62) OPERATOR_FUNC -> . OPEN_PAREN OP CLOSE_PAREN

    MINUS           shift and go to state 82
    LAMBDA          shift and go to state 83
    LET             shift and go to state 84
    MATCH           shift and go to state 85
    OPEN_PAREN      shift and go to state 92
    IDENTIFIER      shift and go to state 93
    TYPENAME        shift and go to state 94
    FLOAT           shift and go to state 25
    INTEGER         shift and go to state 24
    BOOL            shift and go to state 29
    CHAR            shift and go to state 30
    STRING          shift and go to state 31

    LEXP                           shift and go to state 81
    INFIX_EXP                      shift and go to state 134
    EXP                            shift and go to state 113
    FEXP                           shift and go to state 86
    AEXP                           shift and go to state 87
    USED_VAR                       shift and go to state 88
    USED_TYPENAME                  shift and go to state 89
    LITERAL                        shift and go to state 90
    OPERATOR_FUNC                  shift and go to state 91

state 111

    (79) OP -> VAROP .

    MINUS           reduce using rule 79 (OP -> VAROP .)
    LAMBDA          reduce using rule 79 (OP -> VAROP .)
    LET             reduce using rule 79 (OP -> VAROP .)
    MATCH           reduce using rule 79 (OP -> VAROP .)
    OPEN_PAREN      reduce using rule 79 (OP -> VAROP .)
    IDENTIFIER      reduce using rule 79 (OP -> VAROP .)
    TYPENAME        reduce using rule 79 (OP -> VAROP .)
    FLOAT           reduce using rule 79 (OP -> VAROP .)
    INTEGER         reduce using rule 79 (OP -> VAROP .)
    BOOL            reduce using rule 79 (OP -> VAROP .)
    CHAR            reduce using rule 79 (OP -> VAROP .)
    STRING          reduce using rule 79 (OP -> VAROP .)
    CLOSE_PAREN     reduce using rule 79 (OP -> VAROP .)
    CLOSE_BRACE     reduce using rule 79 (OP -> VAROP .)
    ENDSTATEMENT    reduce using rule 79 (OP -> VAROP .)


state 112

    (48) INFIX_EXP -> MINUS INFIX_EXP .
    (46) EXP -> INFIX_EXP .

  ! reduce/reduce conflict for IF resolved using rule 46 (EXP -> INFIX_EXP .)
    WHERE           reduce using rule 48 (INFIX_EXP -> MINUS INFIX_EXP .)
    CLOSE_BRACE     reduce using rule 48 (INFIX_EXP -> MINUS INFIX_EXP .)
    ENDSTATEMENT    reduce using rule 48 (INFIX_EXP -> MINUS INFIX_EXP .)
    EQUALS          reduce using rule 48 (INFIX_EXP -> MINUS INFIX_EXP .)
    OF              reduce using rule 48 (INFIX_EXP -> MINUS INFIX_EXP .)
    ELSE            reduce using rule 48 (INFIX_EXP -> MINUS INFIX_EXP .)
    CLOSE_PAREN     reduce using rule 48 (INFIX_EXP -> MINUS INFIX_EXP .)
    GIVEN           reduce using rule 48 (INFIX_EXP -> MINUS INFIX_EXP .)
    BACKTICK        reduce using rule 48 (INFIX_EXP -> MINUS INFIX_EXP .)
    PLUS            reduce using rule 48 (INFIX_EXP -> MINUS INFIX_EXP .)
    MINUS           reduce using rule 48 (INFIX_EXP -> MINUS INFIX_EXP .)
    TIMES           reduce using rule 48 (INFIX_EXP -> MINUS INFIX_EXP .)
    DIVIDE          reduce using rule 48 (INFIX_EXP -> MINUS INFIX_EXP .)
    MODULO          reduce using rule 48 (INFIX_EXP -> MINUS INFIX_EXP .)
    POW             reduce using rule 48 (INFIX_EXP -> MINUS INFIX_EXP .)
    EQUALITY        reduce using rule 48 (INFIX_EXP -> MINUS INFIX_EXP .)
    INEQUALITY      reduce using rule 48 (INFIX_EXP -> MINUS INFIX_EXP .)
    LESS            reduce using rule 48 (INFIX_EXP -> MINUS INFIX_EXP .)
    LEQ             reduce using rule 48 (INFIX_EXP -> MINUS INFIX_EXP .)
    GREATER         reduce using rule 48 (INFIX_EXP -> MINUS INFIX_EXP .)
    GEQ             reduce using rule 48 (INFIX_EXP -> MINUS INFIX_EXP .)
    AND             reduce using rule 48 (INFIX_EXP -> MINUS INFIX_EXP .)
    OR              reduce using rule 48 (INFIX_EXP -> MINUS INFIX_EXP .)
    IF              reduce using rule 46 (EXP -> INFIX_EXP .)

  ! IF              [ reduce using rule 48 (INFIX_EXP -> MINUS INFIX_EXP .) ]


state 113

    (52) LEXP -> EXP . IF EXP ELSE EXP

    IF              shift and go to state 109


state 114

    (50) LEXP -> LAMBDA APAT . APATS ARROW EXP
    (80) APATS -> . APAT APATS
    (81) APATS -> .
    (73) APAT -> . PARAM
    (74) APAT -> . TYPENAME
    (75) APAT -> . LITERAL
    (76) APAT -> . OPEN_PAREN LPAT CLOSE_PAREN
    (103) PARAM -> . IDENTIFIER
    (96) LITERAL -> . FLOAT
    (97) LITERAL -> . INTEGER
    (98) LITERAL -> . BOOL
    (99) LITERAL -> . CHAR
    (100) LITERAL -> . STRING

    ARROW           reduce using rule 81 (APATS -> .)
    TYPENAME        shift and go to state 38
    OPEN_PAREN      shift and go to state 39
    IDENTIFIER      shift and go to state 36
    FLOAT           shift and go to state 25
    INTEGER         shift and go to state 24
    BOOL            shift and go to state 29
    CHAR            shift and go to state 30
    STRING          shift and go to state 31

    APAT                           shift and go to state 74
    APATS                          shift and go to state 135
    PARAM                          shift and go to state 27
    LITERAL                        shift and go to state 28

state 115

    (51) LEXP -> LET DECLARATIONS . IN EXP

    IN              shift and go to state 136


state 116

    (17) DECLARATIONS -> OPEN_BRACE . DECLARATIONS_LIST CLOSE_BRACE
    (18) DECLARATIONS -> OPEN_BRACE . CLOSE_BRACE
    (19) DECLARATIONS_LIST -> . DECLARATION ENDSTATEMENT DECLARATIONS_LIST
    (20) DECLARATIONS_LIST -> . DECLARATION
    (21) DECLARATION -> . GEN_DECLARATION
    (22) DECLARATION -> . FUNCTION_LHS RHS
    (23) DECLARATION -> . LPAT RHS
    (24) GEN_DECLARATION -> . FIXITY_DECLARATION
    (25) GEN_DECLARATION -> .
    (37) FUNCTION_LHS -> . IDENTIFIER APAT APATS
    (38) FUNCTION_LHS -> . LPAT VAROP LPAT
    (39) FUNCTION_LHS -> . OPEN_PAREN FUNCTION_LHS CLOSE_PAREN APAT APATS
    (69) LPAT -> . APAT
    (70) LPAT -> . MINUS OPEN_PAREN INTEGER CLOSE_PAREN
    (71) LPAT -> . MINUS OPEN_PAREN FLOAT CLOSE_PAREN
    (72) LPAT -> . TYPENAME APAT APATS
    (26) FIXITY_DECLARATION -> . SETFIX ASSOCIATIVITY INTEGER OP
    (73) APAT -> . PARAM
    (74) APAT -> . TYPENAME
    (75) APAT -> . LITERAL
    (76) APAT -> . OPEN_PAREN LPAT CLOSE_PAREN
    (103) PARAM -> . IDENTIFIER
    (96) LITERAL -> . FLOAT
    (97) LITERAL -> . INTEGER
    (98) LITERAL -> . BOOL
    (99) LITERAL -> . CHAR
    (100) LITERAL -> . STRING

  ! shift/reduce conflict for CLOSE_BRACE resolved as shift
    CLOSE_BRACE     shift and go to state 138
    ENDSTATEMENT    reduce using rule 25 (GEN_DECLARATION -> .)
    IDENTIFIER      shift and go to state 12
    OPEN_PAREN      shift and go to state 22
    MINUS           shift and go to state 23
    TYPENAME        shift and go to state 16
    SETFIX          shift and go to state 26
    FLOAT           shift and go to state 25
    INTEGER         shift and go to state 24
    BOOL            shift and go to state 29
    CHAR            shift and go to state 30
    STRING          shift and go to state 31

  ! CLOSE_BRACE     [ reduce using rule 25 (GEN_DECLARATION -> .) ]

    DECLARATIONS_LIST              shift and go to state 137
    DECLARATION                    shift and go to state 139
    GEN_DECLARATION                shift and go to state 17
    FUNCTION_LHS                   shift and go to state 18
    LPAT                           shift and go to state 19
    FIXITY_DECLARATION             shift and go to state 20
    APAT                           shift and go to state 21
    PARAM                          shift and go to state 27
    LITERAL                        shift and go to state 28

state 117

    (53) LEXP -> MATCH EXP . OF OPEN_BRACE ALTS CLOSE_BRACE
    (52) LEXP -> EXP . IF EXP ELSE EXP

    OF              shift and go to state 140
    IF              shift and go to state 109


state 118

    (55) FEXP -> FEXP AEXP .

    OPEN_PAREN      reduce using rule 55 (FEXP -> FEXP AEXP .)
    IDENTIFIER      reduce using rule 55 (FEXP -> FEXP AEXP .)
    TYPENAME        reduce using rule 55 (FEXP -> FEXP AEXP .)
    FLOAT           reduce using rule 55 (FEXP -> FEXP AEXP .)
    INTEGER         reduce using rule 55 (FEXP -> FEXP AEXP .)
    BOOL            reduce using rule 55 (FEXP -> FEXP AEXP .)
    CHAR            reduce using rule 55 (FEXP -> FEXP AEXP .)
    STRING          reduce using rule 55 (FEXP -> FEXP AEXP .)
    BACKTICK        reduce using rule 55 (FEXP -> FEXP AEXP .)
    PLUS            reduce using rule 55 (FEXP -> FEXP AEXP .)
    MINUS           reduce using rule 55 (FEXP -> FEXP AEXP .)
    TIMES           reduce using rule 55 (FEXP -> FEXP AEXP .)
    DIVIDE          reduce using rule 55 (FEXP -> FEXP AEXP .)
    MODULO          reduce using rule 55 (FEXP -> FEXP AEXP .)
    POW             reduce using rule 55 (FEXP -> FEXP AEXP .)
    EQUALITY        reduce using rule 55 (FEXP -> FEXP AEXP .)
    INEQUALITY      reduce using rule 55 (FEXP -> FEXP AEXP .)
    LESS            reduce using rule 55 (FEXP -> FEXP AEXP .)
    LEQ             reduce using rule 55 (FEXP -> FEXP AEXP .)
    GREATER         reduce using rule 55 (FEXP -> FEXP AEXP .)
    GEQ             reduce using rule 55 (FEXP -> FEXP AEXP .)
    AND             reduce using rule 55 (FEXP -> FEXP AEXP .)
    OR              reduce using rule 55 (FEXP -> FEXP AEXP .)
    WHERE           reduce using rule 55 (FEXP -> FEXP AEXP .)
    IF              reduce using rule 55 (FEXP -> FEXP AEXP .)
    CLOSE_BRACE     reduce using rule 55 (FEXP -> FEXP AEXP .)
    ENDSTATEMENT    reduce using rule 55 (FEXP -> FEXP AEXP .)
    EQUALS          reduce using rule 55 (FEXP -> FEXP AEXP .)
    OF              reduce using rule 55 (FEXP -> FEXP AEXP .)
    ELSE            reduce using rule 55 (FEXP -> FEXP AEXP .)
    CLOSE_PAREN     reduce using rule 55 (FEXP -> FEXP AEXP .)
    GIVEN           reduce using rule 55 (FEXP -> FEXP AEXP .)


state 119

    (61) AEXP -> OPEN_PAREN EXP . CLOSE_PAREN
    (52) LEXP -> EXP . IF EXP ELSE EXP

    CLOSE_PAREN     shift and go to state 141
    IF              shift and go to state 109


state 120

    (62) OPERATOR_FUNC -> OPEN_PAREN OP . CLOSE_PAREN

    CLOSE_PAREN     shift and go to state 142


state 121

    (48) INFIX_EXP -> MINUS . INFIX_EXP
    (83) VARSYM -> MINUS .
    (47) INFIX_EXP -> . LEXP OP INFIX_EXP
    (48) INFIX_EXP -> . MINUS INFIX_EXP
    (49) INFIX_EXP -> . LEXP
    (50) LEXP -> . LAMBDA APAT APATS ARROW EXP
    (51) LEXP -> . LET DECLARATIONS IN EXP
    (52) LEXP -> . EXP IF EXP ELSE EXP
    (53) LEXP -> . MATCH EXP OF OPEN_BRACE ALTS CLOSE_BRACE
    (54) LEXP -> . FEXP
    (46) EXP -> . INFIX_EXP
    (55) FEXP -> . FEXP AEXP
    (56) FEXP -> . AEXP
    (57) AEXP -> . USED_VAR
    (58) AEXP -> . USED_TYPENAME
    (59) AEXP -> . LITERAL
    (60) AEXP -> . OPERATOR_FUNC
    (61) AEXP -> . OPEN_PAREN EXP CLOSE_PAREN
    (101) USED_VAR -> . IDENTIFIER
    (102) USED_TYPENAME -> . TYPENAME
    (96) LITERAL -> . FLOAT
    (97) LITERAL -> . INTEGER
    (98) LITERAL -> . BOOL
    (99) LITERAL -> . CHAR
    (100) LITERAL -> . STRING
    (62) OPERATOR_FUNC -> . OPEN_PAREN OP CLOSE_PAREN

    CLOSE_PAREN     reduce using rule 83 (VARSYM -> MINUS .)
    MINUS           shift and go to state 82
    LAMBDA          shift and go to state 83
    LET             shift and go to state 84
    MATCH           shift and go to state 85
    OPEN_PAREN      shift and go to state 92
    IDENTIFIER      shift and go to state 93
    TYPENAME        shift and go to state 94
    FLOAT           shift and go to state 25
    INTEGER         shift and go to state 24
    BOOL            shift and go to state 29
    CHAR            shift and go to state 30
    STRING          shift and go to state 31

    INFIX_EXP                      shift and go to state 112
    LEXP                           shift and go to state 81
    EXP                            shift and go to state 113
    FEXP                           shift and go to state 86
    AEXP                           shift and go to state 87
    USED_VAR                       shift and go to state 88
    USED_TYPENAME                  shift and go to state 89
    LITERAL                        shift and go to state 90
    OPERATOR_FUNC                  shift and go to state 91

state 122

    (43) RHS -> GDRHS WHERE DECLARATIONS .

    CLOSE_BRACE     reduce using rule 43 (RHS -> GDRHS WHERE DECLARATIONS .)
    ENDSTATEMENT    reduce using rule 43 (RHS -> GDRHS WHERE DECLARATIONS .)


state 123

    (44) GDRHS -> GIVEN EXP EQUALS . EXP
    (45) GDRHS -> GIVEN EXP EQUALS . EXP GDRHS
    (46) EXP -> . INFIX_EXP
    (47) INFIX_EXP -> . LEXP OP INFIX_EXP
    (48) INFIX_EXP -> . MINUS INFIX_EXP
    (49) INFIX_EXP -> . LEXP
    (50) LEXP -> . LAMBDA APAT APATS ARROW EXP
    (51) LEXP -> . LET DECLARATIONS IN EXP
    (52) LEXP -> . EXP IF EXP ELSE EXP
    (53) LEXP -> . MATCH EXP OF OPEN_BRACE ALTS CLOSE_BRACE
    (54) LEXP -> . FEXP
    (55) FEXP -> . FEXP AEXP
    (56) FEXP -> . AEXP
    (57) AEXP -> . USED_VAR
    (58) AEXP -> . USED_TYPENAME
    (59) AEXP -> . LITERAL
    (60) AEXP -> . OPERATOR_FUNC
    (61) AEXP -> . OPEN_PAREN EXP CLOSE_PAREN
    (101) USED_VAR -> . IDENTIFIER
    (102) USED_TYPENAME -> . TYPENAME
    (96) LITERAL -> . FLOAT
    (97) LITERAL -> . INTEGER
    (98) LITERAL -> . BOOL
    (99) LITERAL -> . CHAR
    (100) LITERAL -> . STRING
    (62) OPERATOR_FUNC -> . OPEN_PAREN OP CLOSE_PAREN

    MINUS           shift and go to state 82
    LAMBDA          shift and go to state 83
    LET             shift and go to state 84
    MATCH           shift and go to state 85
    OPEN_PAREN      shift and go to state 92
    IDENTIFIER      shift and go to state 93
    TYPENAME        shift and go to state 94
    FLOAT           shift and go to state 25
    INTEGER         shift and go to state 24
    BOOL            shift and go to state 29
    CHAR            shift and go to state 30
    STRING          shift and go to state 31

    EXP                            shift and go to state 143
    INFIX_EXP                      shift and go to state 80
    LEXP                           shift and go to state 81
    FEXP                           shift and go to state 86
    AEXP                           shift and go to state 87
    USED_VAR                       shift and go to state 88
    USED_TYPENAME                  shift and go to state 89
    LITERAL                        shift and go to state 90
    OPERATOR_FUNC                  shift and go to state 91

state 124

    (78) VAROP -> BACKTICK IDENTIFIER BACKTICK .

    MINUS           reduce using rule 78 (VAROP -> BACKTICK IDENTIFIER BACKTICK .)
    TYPENAME        reduce using rule 78 (VAROP -> BACKTICK IDENTIFIER BACKTICK .)
    OPEN_PAREN      reduce using rule 78 (VAROP -> BACKTICK IDENTIFIER BACKTICK .)
    IDENTIFIER      reduce using rule 78 (VAROP -> BACKTICK IDENTIFIER BACKTICK .)
    FLOAT           reduce using rule 78 (VAROP -> BACKTICK IDENTIFIER BACKTICK .)
    INTEGER         reduce using rule 78 (VAROP -> BACKTICK IDENTIFIER BACKTICK .)
    BOOL            reduce using rule 78 (VAROP -> BACKTICK IDENTIFIER BACKTICK .)
    CHAR            reduce using rule 78 (VAROP -> BACKTICK IDENTIFIER BACKTICK .)
    STRING          reduce using rule 78 (VAROP -> BACKTICK IDENTIFIER BACKTICK .)
    LAMBDA          reduce using rule 78 (VAROP -> BACKTICK IDENTIFIER BACKTICK .)
    LET             reduce using rule 78 (VAROP -> BACKTICK IDENTIFIER BACKTICK .)
    MATCH           reduce using rule 78 (VAROP -> BACKTICK IDENTIFIER BACKTICK .)
    CLOSE_PAREN     reduce using rule 78 (VAROP -> BACKTICK IDENTIFIER BACKTICK .)
    CLOSE_BRACE     reduce using rule 78 (VAROP -> BACKTICK IDENTIFIER BACKTICK .)
    ENDSTATEMENT    reduce using rule 78 (VAROP -> BACKTICK IDENTIFIER BACKTICK .)


state 125

    (39) FUNCTION_LHS -> OPEN_PAREN FUNCTION_LHS CLOSE_PAREN APAT . APATS
    (80) APATS -> . APAT APATS
    (81) APATS -> .
    (73) APAT -> . PARAM
    (74) APAT -> . TYPENAME
    (75) APAT -> . LITERAL
    (76) APAT -> . OPEN_PAREN LPAT CLOSE_PAREN
    (103) PARAM -> . IDENTIFIER
    (96) LITERAL -> . FLOAT
    (97) LITERAL -> . INTEGER
    (98) LITERAL -> . BOOL
    (99) LITERAL -> . CHAR
    (100) LITERAL -> . STRING

    EQUALS          reduce using rule 81 (APATS -> .)
    GIVEN           reduce using rule 81 (APATS -> .)
    CLOSE_PAREN     reduce using rule 81 (APATS -> .)
    TYPENAME        shift and go to state 38
    OPEN_PAREN      shift and go to state 39
    IDENTIFIER      shift and go to state 36
    FLOAT           shift and go to state 25
    INTEGER         shift and go to state 24
    BOOL            shift and go to state 29
    CHAR            shift and go to state 30
    STRING          shift and go to state 31

    APAT                           shift and go to state 74
    APATS                          shift and go to state 144
    PARAM                          shift and go to state 27
    LITERAL                        shift and go to state 28

state 126

    (70) LPAT -> MINUS OPEN_PAREN INTEGER CLOSE_PAREN .

    EQUALS          reduce using rule 70 (LPAT -> MINUS OPEN_PAREN INTEGER CLOSE_PAREN .)
    BACKTICK        reduce using rule 70 (LPAT -> MINUS OPEN_PAREN INTEGER CLOSE_PAREN .)
    GIVEN           reduce using rule 70 (LPAT -> MINUS OPEN_PAREN INTEGER CLOSE_PAREN .)
    PLUS            reduce using rule 70 (LPAT -> MINUS OPEN_PAREN INTEGER CLOSE_PAREN .)
    MINUS           reduce using rule 70 (LPAT -> MINUS OPEN_PAREN INTEGER CLOSE_PAREN .)
    TIMES           reduce using rule 70 (LPAT -> MINUS OPEN_PAREN INTEGER CLOSE_PAREN .)
    DIVIDE          reduce using rule 70 (LPAT -> MINUS OPEN_PAREN INTEGER CLOSE_PAREN .)
    MODULO          reduce using rule 70 (LPAT -> MINUS OPEN_PAREN INTEGER CLOSE_PAREN .)
    POW             reduce using rule 70 (LPAT -> MINUS OPEN_PAREN INTEGER CLOSE_PAREN .)
    EQUALITY        reduce using rule 70 (LPAT -> MINUS OPEN_PAREN INTEGER CLOSE_PAREN .)
    INEQUALITY      reduce using rule 70 (LPAT -> MINUS OPEN_PAREN INTEGER CLOSE_PAREN .)
    LESS            reduce using rule 70 (LPAT -> MINUS OPEN_PAREN INTEGER CLOSE_PAREN .)
    LEQ             reduce using rule 70 (LPAT -> MINUS OPEN_PAREN INTEGER CLOSE_PAREN .)
    GREATER         reduce using rule 70 (LPAT -> MINUS OPEN_PAREN INTEGER CLOSE_PAREN .)
    GEQ             reduce using rule 70 (LPAT -> MINUS OPEN_PAREN INTEGER CLOSE_PAREN .)
    AND             reduce using rule 70 (LPAT -> MINUS OPEN_PAREN INTEGER CLOSE_PAREN .)
    OR              reduce using rule 70 (LPAT -> MINUS OPEN_PAREN INTEGER CLOSE_PAREN .)
    CLOSE_PAREN     reduce using rule 70 (LPAT -> MINUS OPEN_PAREN INTEGER CLOSE_PAREN .)
    ARROW           reduce using rule 70 (LPAT -> MINUS OPEN_PAREN INTEGER CLOSE_PAREN .)


state 127

    (71) LPAT -> MINUS OPEN_PAREN FLOAT CLOSE_PAREN .

    EQUALS          reduce using rule 71 (LPAT -> MINUS OPEN_PAREN FLOAT CLOSE_PAREN .)
    BACKTICK        reduce using rule 71 (LPAT -> MINUS OPEN_PAREN FLOAT CLOSE_PAREN .)
    GIVEN           reduce using rule 71 (LPAT -> MINUS OPEN_PAREN FLOAT CLOSE_PAREN .)
    PLUS            reduce using rule 71 (LPAT -> MINUS OPEN_PAREN FLOAT CLOSE_PAREN .)
    MINUS           reduce using rule 71 (LPAT -> MINUS OPEN_PAREN FLOAT CLOSE_PAREN .)
    TIMES           reduce using rule 71 (LPAT -> MINUS OPEN_PAREN FLOAT CLOSE_PAREN .)
    DIVIDE          reduce using rule 71 (LPAT -> MINUS OPEN_PAREN FLOAT CLOSE_PAREN .)
    MODULO          reduce using rule 71 (LPAT -> MINUS OPEN_PAREN FLOAT CLOSE_PAREN .)
    POW             reduce using rule 71 (LPAT -> MINUS OPEN_PAREN FLOAT CLOSE_PAREN .)
    EQUALITY        reduce using rule 71 (LPAT -> MINUS OPEN_PAREN FLOAT CLOSE_PAREN .)
    INEQUALITY      reduce using rule 71 (LPAT -> MINUS OPEN_PAREN FLOAT CLOSE_PAREN .)
    LESS            reduce using rule 71 (LPAT -> MINUS OPEN_PAREN FLOAT CLOSE_PAREN .)
    LEQ             reduce using rule 71 (LPAT -> MINUS OPEN_PAREN FLOAT CLOSE_PAREN .)
    GREATER         reduce using rule 71 (LPAT -> MINUS OPEN_PAREN FLOAT CLOSE_PAREN .)
    GEQ             reduce using rule 71 (LPAT -> MINUS OPEN_PAREN FLOAT CLOSE_PAREN .)
    AND             reduce using rule 71 (LPAT -> MINUS OPEN_PAREN FLOAT CLOSE_PAREN .)
    OR              reduce using rule 71 (LPAT -> MINUS OPEN_PAREN FLOAT CLOSE_PAREN .)
    CLOSE_PAREN     reduce using rule 71 (LPAT -> MINUS OPEN_PAREN FLOAT CLOSE_PAREN .)
    ARROW           reduce using rule 71 (LPAT -> MINUS OPEN_PAREN FLOAT CLOSE_PAREN .)


state 128

    (26) FIXITY_DECLARATION -> SETFIX ASSOCIATIVITY INTEGER OP .

    CLOSE_BRACE     reduce using rule 26 (FIXITY_DECLARATION -> SETFIX ASSOCIATIVITY INTEGER OP .)
    ENDSTATEMENT    reduce using rule 26 (FIXITY_DECLARATION -> SETFIX ASSOCIATIVITY INTEGER OP .)


state 129

    (16) CONSTRUCTOR -> TYPENAME . ATYPES
    (32) ATYPES -> . ATYPES ATYPE
    (33) ATYPES -> .

    TYPENAME        reduce using rule 33 (ATYPES -> .)
    IDENTIFIER      reduce using rule 33 (ATYPES -> .)
    OPEN_PAREN      reduce using rule 33 (ATYPES -> .)
    PIPE            reduce using rule 33 (ATYPES -> .)
    CLOSE_BRACE     reduce using rule 33 (ATYPES -> .)
    ENDSTATEMENT    reduce using rule 33 (ATYPES -> .)

    ATYPES                         shift and go to state 145

state 130

    (11) TYPE_DECLARATION -> NEWTYPE TYPENAME TYVARS EQUALS CONSTRUCTORS .
    (14) CONSTRUCTORS -> CONSTRUCTORS . PIPE CONSTRUCTOR

    CLOSE_BRACE     reduce using rule 11 (TYPE_DECLARATION -> NEWTYPE TYPENAME TYVARS EQUALS CONSTRUCTORS .)
    ENDSTATEMENT    reduce using rule 11 (TYPE_DECLARATION -> NEWTYPE TYPENAME TYVARS EQUALS CONSTRUCTORS .)
    PIPE            shift and go to state 146


state 131

    (15) CONSTRUCTORS -> CONSTRUCTOR .

    PIPE            reduce using rule 15 (CONSTRUCTORS -> CONSTRUCTOR .)
    CLOSE_BRACE     reduce using rule 15 (CONSTRUCTORS -> CONSTRUCTOR .)
    ENDSTATEMENT    reduce using rule 15 (CONSTRUCTORS -> CONSTRUCTOR .)


state 132

    (41) RHS -> EQUALS EXP WHERE DECLARATIONS .

    CLOSE_BRACE     reduce using rule 41 (RHS -> EQUALS EXP WHERE DECLARATIONS .)
    ENDSTATEMENT    reduce using rule 41 (RHS -> EQUALS EXP WHERE DECLARATIONS .)


state 133

    (52) LEXP -> EXP IF EXP . ELSE EXP
    (52) LEXP -> EXP . IF EXP ELSE EXP

    ELSE            shift and go to state 147
    IF              shift and go to state 109


state 134

    (47) INFIX_EXP -> LEXP OP INFIX_EXP .
    (46) EXP -> INFIX_EXP .

  ! reduce/reduce conflict for IF resolved using rule 46 (EXP -> INFIX_EXP .)
    WHERE           reduce using rule 47 (INFIX_EXP -> LEXP OP INFIX_EXP .)
    CLOSE_BRACE     reduce using rule 47 (INFIX_EXP -> LEXP OP INFIX_EXP .)
    ENDSTATEMENT    reduce using rule 47 (INFIX_EXP -> LEXP OP INFIX_EXP .)
    EQUALS          reduce using rule 47 (INFIX_EXP -> LEXP OP INFIX_EXP .)
    OF              reduce using rule 47 (INFIX_EXP -> LEXP OP INFIX_EXP .)
    ELSE            reduce using rule 47 (INFIX_EXP -> LEXP OP INFIX_EXP .)
    CLOSE_PAREN     reduce using rule 47 (INFIX_EXP -> LEXP OP INFIX_EXP .)
    GIVEN           reduce using rule 47 (INFIX_EXP -> LEXP OP INFIX_EXP .)
    BACKTICK        reduce using rule 47 (INFIX_EXP -> LEXP OP INFIX_EXP .)
    PLUS            reduce using rule 47 (INFIX_EXP -> LEXP OP INFIX_EXP .)
    MINUS           reduce using rule 47 (INFIX_EXP -> LEXP OP INFIX_EXP .)
    TIMES           reduce using rule 47 (INFIX_EXP -> LEXP OP INFIX_EXP .)
    DIVIDE          reduce using rule 47 (INFIX_EXP -> LEXP OP INFIX_EXP .)
    MODULO          reduce using rule 47 (INFIX_EXP -> LEXP OP INFIX_EXP .)
    POW             reduce using rule 47 (INFIX_EXP -> LEXP OP INFIX_EXP .)
    EQUALITY        reduce using rule 47 (INFIX_EXP -> LEXP OP INFIX_EXP .)
    INEQUALITY      reduce using rule 47 (INFIX_EXP -> LEXP OP INFIX_EXP .)
    LESS            reduce using rule 47 (INFIX_EXP -> LEXP OP INFIX_EXP .)
    LEQ             reduce using rule 47 (INFIX_EXP -> LEXP OP INFIX_EXP .)
    GREATER         reduce using rule 47 (INFIX_EXP -> LEXP OP INFIX_EXP .)
    GEQ             reduce using rule 47 (INFIX_EXP -> LEXP OP INFIX_EXP .)
    AND             reduce using rule 47 (INFIX_EXP -> LEXP OP INFIX_EXP .)
    OR              reduce using rule 47 (INFIX_EXP -> LEXP OP INFIX_EXP .)
    IF              reduce using rule 46 (EXP -> INFIX_EXP .)

  ! IF              [ reduce using rule 47 (INFIX_EXP -> LEXP OP INFIX_EXP .) ]


state 135

    (50) LEXP -> LAMBDA APAT APATS . ARROW EXP

    ARROW           shift and go to state 148


state 136

    (51) LEXP -> LET DECLARATIONS IN . EXP
    (46) EXP -> . INFIX_EXP
    (47) INFIX_EXP -> . LEXP OP INFIX_EXP
    (48) INFIX_EXP -> . MINUS INFIX_EXP
    (49) INFIX_EXP -> . LEXP
    (50) LEXP -> . LAMBDA APAT APATS ARROW EXP
    (51) LEXP -> . LET DECLARATIONS IN EXP
    (52) LEXP -> . EXP IF EXP ELSE EXP
    (53) LEXP -> . MATCH EXP OF OPEN_BRACE ALTS CLOSE_BRACE
    (54) LEXP -> . FEXP
    (55) FEXP -> . FEXP AEXP
    (56) FEXP -> . AEXP
    (57) AEXP -> . USED_VAR
    (58) AEXP -> . USED_TYPENAME
    (59) AEXP -> . LITERAL
    (60) AEXP -> . OPERATOR_FUNC
    (61) AEXP -> . OPEN_PAREN EXP CLOSE_PAREN
    (101) USED_VAR -> . IDENTIFIER
    (102) USED_TYPENAME -> . TYPENAME
    (96) LITERAL -> . FLOAT
    (97) LITERAL -> . INTEGER
    (98) LITERAL -> . BOOL
    (99) LITERAL -> . CHAR
    (100) LITERAL -> . STRING
    (62) OPERATOR_FUNC -> . OPEN_PAREN OP CLOSE_PAREN

    MINUS           shift and go to state 82
    LAMBDA          shift and go to state 83
    LET             shift and go to state 84
    MATCH           shift and go to state 85
    OPEN_PAREN      shift and go to state 92
    IDENTIFIER      shift and go to state 93
    TYPENAME        shift and go to state 94
    FLOAT           shift and go to state 25
    INTEGER         shift and go to state 24
    BOOL            shift and go to state 29
    CHAR            shift and go to state 30
    STRING          shift and go to state 31

    EXP                            shift and go to state 149
    INFIX_EXP                      shift and go to state 80
    LEXP                           shift and go to state 81
    FEXP                           shift and go to state 86
    AEXP                           shift and go to state 87
    USED_VAR                       shift and go to state 88
    USED_TYPENAME                  shift and go to state 89
    LITERAL                        shift and go to state 90
    OPERATOR_FUNC                  shift and go to state 91

state 137

    (17) DECLARATIONS -> OPEN_BRACE DECLARATIONS_LIST . CLOSE_BRACE

    CLOSE_BRACE     shift and go to state 150


state 138

    (18) DECLARATIONS -> OPEN_BRACE CLOSE_BRACE .

    IN              reduce using rule 18 (DECLARATIONS -> OPEN_BRACE CLOSE_BRACE .)
    CLOSE_BRACE     reduce using rule 18 (DECLARATIONS -> OPEN_BRACE CLOSE_BRACE .)
    ENDSTATEMENT    reduce using rule 18 (DECLARATIONS -> OPEN_BRACE CLOSE_BRACE .)


state 139

    (19) DECLARATIONS_LIST -> DECLARATION . ENDSTATEMENT DECLARATIONS_LIST
    (20) DECLARATIONS_LIST -> DECLARATION .

    ENDSTATEMENT    shift and go to state 151
    CLOSE_BRACE     reduce using rule 20 (DECLARATIONS_LIST -> DECLARATION .)


state 140

    (53) LEXP -> MATCH EXP OF . OPEN_BRACE ALTS CLOSE_BRACE

    OPEN_BRACE      shift and go to state 152


state 141

    (61) AEXP -> OPEN_PAREN EXP CLOSE_PAREN .

    OPEN_PAREN      reduce using rule 61 (AEXP -> OPEN_PAREN EXP CLOSE_PAREN .)
    IDENTIFIER      reduce using rule 61 (AEXP -> OPEN_PAREN EXP CLOSE_PAREN .)
    TYPENAME        reduce using rule 61 (AEXP -> OPEN_PAREN EXP CLOSE_PAREN .)
    FLOAT           reduce using rule 61 (AEXP -> OPEN_PAREN EXP CLOSE_PAREN .)
    INTEGER         reduce using rule 61 (AEXP -> OPEN_PAREN EXP CLOSE_PAREN .)
    BOOL            reduce using rule 61 (AEXP -> OPEN_PAREN EXP CLOSE_PAREN .)
    CHAR            reduce using rule 61 (AEXP -> OPEN_PAREN EXP CLOSE_PAREN .)
    STRING          reduce using rule 61 (AEXP -> OPEN_PAREN EXP CLOSE_PAREN .)
    BACKTICK        reduce using rule 61 (AEXP -> OPEN_PAREN EXP CLOSE_PAREN .)
    PLUS            reduce using rule 61 (AEXP -> OPEN_PAREN EXP CLOSE_PAREN .)
    MINUS           reduce using rule 61 (AEXP -> OPEN_PAREN EXP CLOSE_PAREN .)
    TIMES           reduce using rule 61 (AEXP -> OPEN_PAREN EXP CLOSE_PAREN .)
    DIVIDE          reduce using rule 61 (AEXP -> OPEN_PAREN EXP CLOSE_PAREN .)
    MODULO          reduce using rule 61 (AEXP -> OPEN_PAREN EXP CLOSE_PAREN .)
    POW             reduce using rule 61 (AEXP -> OPEN_PAREN EXP CLOSE_PAREN .)
    EQUALITY        reduce using rule 61 (AEXP -> OPEN_PAREN EXP CLOSE_PAREN .)
    INEQUALITY      reduce using rule 61 (AEXP -> OPEN_PAREN EXP CLOSE_PAREN .)
    LESS            reduce using rule 61 (AEXP -> OPEN_PAREN EXP CLOSE_PAREN .)
    LEQ             reduce using rule 61 (AEXP -> OPEN_PAREN EXP CLOSE_PAREN .)
    GREATER         reduce using rule 61 (AEXP -> OPEN_PAREN EXP CLOSE_PAREN .)
    GEQ             reduce using rule 61 (AEXP -> OPEN_PAREN EXP CLOSE_PAREN .)
    AND             reduce using rule 61 (AEXP -> OPEN_PAREN EXP CLOSE_PAREN .)
    OR              reduce using rule 61 (AEXP -> OPEN_PAREN EXP CLOSE_PAREN .)
    WHERE           reduce using rule 61 (AEXP -> OPEN_PAREN EXP CLOSE_PAREN .)
    IF              reduce using rule 61 (AEXP -> OPEN_PAREN EXP CLOSE_PAREN .)
    CLOSE_BRACE     reduce using rule 61 (AEXP -> OPEN_PAREN EXP CLOSE_PAREN .)
    ENDSTATEMENT    reduce using rule 61 (AEXP -> OPEN_PAREN EXP CLOSE_PAREN .)
    EQUALS          reduce using rule 61 (AEXP -> OPEN_PAREN EXP CLOSE_PAREN .)
    OF              reduce using rule 61 (AEXP -> OPEN_PAREN EXP CLOSE_PAREN .)
    ELSE            reduce using rule 61 (AEXP -> OPEN_PAREN EXP CLOSE_PAREN .)
    CLOSE_PAREN     reduce using rule 61 (AEXP -> OPEN_PAREN EXP CLOSE_PAREN .)
    GIVEN           reduce using rule 61 (AEXP -> OPEN_PAREN EXP CLOSE_PAREN .)


state 142

    (62) OPERATOR_FUNC -> OPEN_PAREN OP CLOSE_PAREN .

    OPEN_PAREN      reduce using rule 62 (OPERATOR_FUNC -> OPEN_PAREN OP CLOSE_PAREN .)
    IDENTIFIER      reduce using rule 62 (OPERATOR_FUNC -> OPEN_PAREN OP CLOSE_PAREN .)
    TYPENAME        reduce using rule 62 (OPERATOR_FUNC -> OPEN_PAREN OP CLOSE_PAREN .)
    FLOAT           reduce using rule 62 (OPERATOR_FUNC -> OPEN_PAREN OP CLOSE_PAREN .)
    INTEGER         reduce using rule 62 (OPERATOR_FUNC -> OPEN_PAREN OP CLOSE_PAREN .)
    BOOL            reduce using rule 62 (OPERATOR_FUNC -> OPEN_PAREN OP CLOSE_PAREN .)
    CHAR            reduce using rule 62 (OPERATOR_FUNC -> OPEN_PAREN OP CLOSE_PAREN .)
    STRING          reduce using rule 62 (OPERATOR_FUNC -> OPEN_PAREN OP CLOSE_PAREN .)
    BACKTICK        reduce using rule 62 (OPERATOR_FUNC -> OPEN_PAREN OP CLOSE_PAREN .)
    PLUS            reduce using rule 62 (OPERATOR_FUNC -> OPEN_PAREN OP CLOSE_PAREN .)
    MINUS           reduce using rule 62 (OPERATOR_FUNC -> OPEN_PAREN OP CLOSE_PAREN .)
    TIMES           reduce using rule 62 (OPERATOR_FUNC -> OPEN_PAREN OP CLOSE_PAREN .)
    DIVIDE          reduce using rule 62 (OPERATOR_FUNC -> OPEN_PAREN OP CLOSE_PAREN .)
    MODULO          reduce using rule 62 (OPERATOR_FUNC -> OPEN_PAREN OP CLOSE_PAREN .)
    POW             reduce using rule 62 (OPERATOR_FUNC -> OPEN_PAREN OP CLOSE_PAREN .)
    EQUALITY        reduce using rule 62 (OPERATOR_FUNC -> OPEN_PAREN OP CLOSE_PAREN .)
    INEQUALITY      reduce using rule 62 (OPERATOR_FUNC -> OPEN_PAREN OP CLOSE_PAREN .)
    LESS            reduce using rule 62 (OPERATOR_FUNC -> OPEN_PAREN OP CLOSE_PAREN .)
    LEQ             reduce using rule 62 (OPERATOR_FUNC -> OPEN_PAREN OP CLOSE_PAREN .)
    GREATER         reduce using rule 62 (OPERATOR_FUNC -> OPEN_PAREN OP CLOSE_PAREN .)
    GEQ             reduce using rule 62 (OPERATOR_FUNC -> OPEN_PAREN OP CLOSE_PAREN .)
    AND             reduce using rule 62 (OPERATOR_FUNC -> OPEN_PAREN OP CLOSE_PAREN .)
    OR              reduce using rule 62 (OPERATOR_FUNC -> OPEN_PAREN OP CLOSE_PAREN .)
    WHERE           reduce using rule 62 (OPERATOR_FUNC -> OPEN_PAREN OP CLOSE_PAREN .)
    IF              reduce using rule 62 (OPERATOR_FUNC -> OPEN_PAREN OP CLOSE_PAREN .)
    CLOSE_BRACE     reduce using rule 62 (OPERATOR_FUNC -> OPEN_PAREN OP CLOSE_PAREN .)
    ENDSTATEMENT    reduce using rule 62 (OPERATOR_FUNC -> OPEN_PAREN OP CLOSE_PAREN .)
    EQUALS          reduce using rule 62 (OPERATOR_FUNC -> OPEN_PAREN OP CLOSE_PAREN .)
    OF              reduce using rule 62 (OPERATOR_FUNC -> OPEN_PAREN OP CLOSE_PAREN .)
    ELSE            reduce using rule 62 (OPERATOR_FUNC -> OPEN_PAREN OP CLOSE_PAREN .)
    CLOSE_PAREN     reduce using rule 62 (OPERATOR_FUNC -> OPEN_PAREN OP CLOSE_PAREN .)
    GIVEN           reduce using rule 62 (OPERATOR_FUNC -> OPEN_PAREN OP CLOSE_PAREN .)


state 143

    (44) GDRHS -> GIVEN EXP EQUALS EXP .
    (45) GDRHS -> GIVEN EXP EQUALS EXP . GDRHS
    (52) LEXP -> EXP . IF EXP ELSE EXP
    (44) GDRHS -> . GIVEN EXP EQUALS EXP
    (45) GDRHS -> . GIVEN EXP EQUALS EXP GDRHS

    WHERE           reduce using rule 44 (GDRHS -> GIVEN EXP EQUALS EXP .)
    CLOSE_BRACE     reduce using rule 44 (GDRHS -> GIVEN EXP EQUALS EXP .)
    ENDSTATEMENT    reduce using rule 44 (GDRHS -> GIVEN EXP EQUALS EXP .)
    IF              shift and go to state 109
    GIVEN           shift and go to state 45

    GDRHS                          shift and go to state 153

state 144

    (39) FUNCTION_LHS -> OPEN_PAREN FUNCTION_LHS CLOSE_PAREN APAT APATS .

    EQUALS          reduce using rule 39 (FUNCTION_LHS -> OPEN_PAREN FUNCTION_LHS CLOSE_PAREN APAT APATS .)
    GIVEN           reduce using rule 39 (FUNCTION_LHS -> OPEN_PAREN FUNCTION_LHS CLOSE_PAREN APAT APATS .)
    CLOSE_PAREN     reduce using rule 39 (FUNCTION_LHS -> OPEN_PAREN FUNCTION_LHS CLOSE_PAREN APAT APATS .)


state 145

    (16) CONSTRUCTOR -> TYPENAME ATYPES .
    (32) ATYPES -> ATYPES . ATYPE
    (34) ATYPE -> . TYPENAME
    (35) ATYPE -> . IDENTIFIER
    (36) ATYPE -> . OPEN_PAREN TYPE CLOSE_PAREN

    PIPE            reduce using rule 16 (CONSTRUCTOR -> TYPENAME ATYPES .)
    CLOSE_BRACE     reduce using rule 16 (CONSTRUCTOR -> TYPENAME ATYPES .)
    ENDSTATEMENT    reduce using rule 16 (CONSTRUCTOR -> TYPENAME ATYPES .)
    TYPENAME        shift and go to state 154
    IDENTIFIER      shift and go to state 156
    OPEN_PAREN      shift and go to state 157

    ATYPE                          shift and go to state 155

state 146

    (14) CONSTRUCTORS -> CONSTRUCTORS PIPE . CONSTRUCTOR
    (16) CONSTRUCTOR -> . TYPENAME ATYPES

    TYPENAME        shift and go to state 129

    CONSTRUCTOR                    shift and go to state 158

state 147

    (52) LEXP -> EXP IF EXP ELSE . EXP
    (46) EXP -> . INFIX_EXP
    (47) INFIX_EXP -> . LEXP OP INFIX_EXP
    (48) INFIX_EXP -> . MINUS INFIX_EXP
    (49) INFIX_EXP -> . LEXP
    (50) LEXP -> . LAMBDA APAT APATS ARROW EXP
    (51) LEXP -> . LET DECLARATIONS IN EXP
    (52) LEXP -> . EXP IF EXP ELSE EXP
    (53) LEXP -> . MATCH EXP OF OPEN_BRACE ALTS CLOSE_BRACE
    (54) LEXP -> . FEXP
    (55) FEXP -> . FEXP AEXP
    (56) FEXP -> . AEXP
    (57) AEXP -> . USED_VAR
    (58) AEXP -> . USED_TYPENAME
    (59) AEXP -> . LITERAL
    (60) AEXP -> . OPERATOR_FUNC
    (61) AEXP -> . OPEN_PAREN EXP CLOSE_PAREN
    (101) USED_VAR -> . IDENTIFIER
    (102) USED_TYPENAME -> . TYPENAME
    (96) LITERAL -> . FLOAT
    (97) LITERAL -> . INTEGER
    (98) LITERAL -> . BOOL
    (99) LITERAL -> . CHAR
    (100) LITERAL -> . STRING
    (62) OPERATOR_FUNC -> . OPEN_PAREN OP CLOSE_PAREN

    MINUS           shift and go to state 82
    LAMBDA          shift and go to state 83
    LET             shift and go to state 84
    MATCH           shift and go to state 85
    OPEN_PAREN      shift and go to state 92
    IDENTIFIER      shift and go to state 93
    TYPENAME        shift and go to state 94
    FLOAT           shift and go to state 25
    INTEGER         shift and go to state 24
    BOOL            shift and go to state 29
    CHAR            shift and go to state 30
    STRING          shift and go to state 31

    EXP                            shift and go to state 159
    INFIX_EXP                      shift and go to state 80
    LEXP                           shift and go to state 81
    FEXP                           shift and go to state 86
    AEXP                           shift and go to state 87
    USED_VAR                       shift and go to state 88
    USED_TYPENAME                  shift and go to state 89
    LITERAL                        shift and go to state 90
    OPERATOR_FUNC                  shift and go to state 91

state 148

    (50) LEXP -> LAMBDA APAT APATS ARROW . EXP
    (46) EXP -> . INFIX_EXP
    (47) INFIX_EXP -> . LEXP OP INFIX_EXP
    (48) INFIX_EXP -> . MINUS INFIX_EXP
    (49) INFIX_EXP -> . LEXP
    (50) LEXP -> . LAMBDA APAT APATS ARROW EXP
    (51) LEXP -> . LET DECLARATIONS IN EXP
    (52) LEXP -> . EXP IF EXP ELSE EXP
    (53) LEXP -> . MATCH EXP OF OPEN_BRACE ALTS CLOSE_BRACE
    (54) LEXP -> . FEXP
    (55) FEXP -> . FEXP AEXP
    (56) FEXP -> . AEXP
    (57) AEXP -> . USED_VAR
    (58) AEXP -> . USED_TYPENAME
    (59) AEXP -> . LITERAL
    (60) AEXP -> . OPERATOR_FUNC
    (61) AEXP -> . OPEN_PAREN EXP CLOSE_PAREN
    (101) USED_VAR -> . IDENTIFIER
    (102) USED_TYPENAME -> . TYPENAME
    (96) LITERAL -> . FLOAT
    (97) LITERAL -> . INTEGER
    (98) LITERAL -> . BOOL
    (99) LITERAL -> . CHAR
    (100) LITERAL -> . STRING
    (62) OPERATOR_FUNC -> . OPEN_PAREN OP CLOSE_PAREN

    MINUS           shift and go to state 82
    LAMBDA          shift and go to state 83
    LET             shift and go to state 84
    MATCH           shift and go to state 85
    OPEN_PAREN      shift and go to state 92
    IDENTIFIER      shift and go to state 93
    TYPENAME        shift and go to state 94
    FLOAT           shift and go to state 25
    INTEGER         shift and go to state 24
    BOOL            shift and go to state 29
    CHAR            shift and go to state 30
    STRING          shift and go to state 31

    EXP                            shift and go to state 160
    INFIX_EXP                      shift and go to state 80
    LEXP                           shift and go to state 81
    FEXP                           shift and go to state 86
    AEXP                           shift and go to state 87
    USED_VAR                       shift and go to state 88
    USED_TYPENAME                  shift and go to state 89
    LITERAL                        shift and go to state 90
    OPERATOR_FUNC                  shift and go to state 91

state 149

    (51) LEXP -> LET DECLARATIONS IN EXP .
    (52) LEXP -> EXP . IF EXP ELSE EXP

  ! shift/reduce conflict for IF resolved as shift
    BACKTICK        reduce using rule 51 (LEXP -> LET DECLARATIONS IN EXP .)
    PLUS            reduce using rule 51 (LEXP -> LET DECLARATIONS IN EXP .)
    MINUS           reduce using rule 51 (LEXP -> LET DECLARATIONS IN EXP .)
    TIMES           reduce using rule 51 (LEXP -> LET DECLARATIONS IN EXP .)
    DIVIDE          reduce using rule 51 (LEXP -> LET DECLARATIONS IN EXP .)
    MODULO          reduce using rule 51 (LEXP -> LET DECLARATIONS IN EXP .)
    POW             reduce using rule 51 (LEXP -> LET DECLARATIONS IN EXP .)
    EQUALITY        reduce using rule 51 (LEXP -> LET DECLARATIONS IN EXP .)
    INEQUALITY      reduce using rule 51 (LEXP -> LET DECLARATIONS IN EXP .)
    LESS            reduce using rule 51 (LEXP -> LET DECLARATIONS IN EXP .)
    LEQ             reduce using rule 51 (LEXP -> LET DECLARATIONS IN EXP .)
    GREATER         reduce using rule 51 (LEXP -> LET DECLARATIONS IN EXP .)
    GEQ             reduce using rule 51 (LEXP -> LET DECLARATIONS IN EXP .)
    AND             reduce using rule 51 (LEXP -> LET DECLARATIONS IN EXP .)
    OR              reduce using rule 51 (LEXP -> LET DECLARATIONS IN EXP .)
    WHERE           reduce using rule 51 (LEXP -> LET DECLARATIONS IN EXP .)
    CLOSE_BRACE     reduce using rule 51 (LEXP -> LET DECLARATIONS IN EXP .)
    ENDSTATEMENT    reduce using rule 51 (LEXP -> LET DECLARATIONS IN EXP .)
    EQUALS          reduce using rule 51 (LEXP -> LET DECLARATIONS IN EXP .)
    OF              reduce using rule 51 (LEXP -> LET DECLARATIONS IN EXP .)
    ELSE            reduce using rule 51 (LEXP -> LET DECLARATIONS IN EXP .)
    CLOSE_PAREN     reduce using rule 51 (LEXP -> LET DECLARATIONS IN EXP .)
    GIVEN           reduce using rule 51 (LEXP -> LET DECLARATIONS IN EXP .)
    IF              shift and go to state 109

  ! IF              [ reduce using rule 51 (LEXP -> LET DECLARATIONS IN EXP .) ]


state 150

    (17) DECLARATIONS -> OPEN_BRACE DECLARATIONS_LIST CLOSE_BRACE .

    IN              reduce using rule 17 (DECLARATIONS -> OPEN_BRACE DECLARATIONS_LIST CLOSE_BRACE .)
    CLOSE_BRACE     reduce using rule 17 (DECLARATIONS -> OPEN_BRACE DECLARATIONS_LIST CLOSE_BRACE .)
    ENDSTATEMENT    reduce using rule 17 (DECLARATIONS -> OPEN_BRACE DECLARATIONS_LIST CLOSE_BRACE .)


state 151

    (19) DECLARATIONS_LIST -> DECLARATION ENDSTATEMENT . DECLARATIONS_LIST
    (19) DECLARATIONS_LIST -> . DECLARATION ENDSTATEMENT DECLARATIONS_LIST
    (20) DECLARATIONS_LIST -> . DECLARATION
    (21) DECLARATION -> . GEN_DECLARATION
    (22) DECLARATION -> . FUNCTION_LHS RHS
    (23) DECLARATION -> . LPAT RHS
    (24) GEN_DECLARATION -> . FIXITY_DECLARATION
    (25) GEN_DECLARATION -> .
    (37) FUNCTION_LHS -> . IDENTIFIER APAT APATS
    (38) FUNCTION_LHS -> . LPAT VAROP LPAT
    (39) FUNCTION_LHS -> . OPEN_PAREN FUNCTION_LHS CLOSE_PAREN APAT APATS
    (69) LPAT -> . APAT
    (70) LPAT -> . MINUS OPEN_PAREN INTEGER CLOSE_PAREN
    (71) LPAT -> . MINUS OPEN_PAREN FLOAT CLOSE_PAREN
    (72) LPAT -> . TYPENAME APAT APATS
    (26) FIXITY_DECLARATION -> . SETFIX ASSOCIATIVITY INTEGER OP
    (73) APAT -> . PARAM
    (74) APAT -> . TYPENAME
    (75) APAT -> . LITERAL
    (76) APAT -> . OPEN_PAREN LPAT CLOSE_PAREN
    (103) PARAM -> . IDENTIFIER
    (96) LITERAL -> . FLOAT
    (97) LITERAL -> . INTEGER
    (98) LITERAL -> . BOOL
    (99) LITERAL -> . CHAR
    (100) LITERAL -> . STRING

    ENDSTATEMENT    reduce using rule 25 (GEN_DECLARATION -> .)
    CLOSE_BRACE     reduce using rule 25 (GEN_DECLARATION -> .)
    IDENTIFIER      shift and go to state 12
    OPEN_PAREN      shift and go to state 22
    MINUS           shift and go to state 23
    TYPENAME        shift and go to state 16
    SETFIX          shift and go to state 26
    FLOAT           shift and go to state 25
    INTEGER         shift and go to state 24
    BOOL            shift and go to state 29
    CHAR            shift and go to state 30
    STRING          shift and go to state 31

    DECLARATION                    shift and go to state 139
    DECLARATIONS_LIST              shift and go to state 161
    GEN_DECLARATION                shift and go to state 17
    FUNCTION_LHS                   shift and go to state 18
    LPAT                           shift and go to state 19
    FIXITY_DECLARATION             shift and go to state 20
    APAT                           shift and go to state 21
    PARAM                          shift and go to state 27
    LITERAL                        shift and go to state 28

state 152

    (53) LEXP -> MATCH EXP OF OPEN_BRACE . ALTS CLOSE_BRACE
    (65) ALTS -> . ALT ENDSTATEMENT ALTS
    (66) ALTS -> . ALT
    (67) ALT -> . LPAT ARROW EXP
    (68) ALT -> .
    (69) LPAT -> . APAT
    (70) LPAT -> . MINUS OPEN_PAREN INTEGER CLOSE_PAREN
    (71) LPAT -> . MINUS OPEN_PAREN FLOAT CLOSE_PAREN
    (72) LPAT -> . TYPENAME APAT APATS
    (73) APAT -> . PARAM
    (74) APAT -> . TYPENAME
    (75) APAT -> . LITERAL
    (76) APAT -> . OPEN_PAREN LPAT CLOSE_PAREN
    (103) PARAM -> . IDENTIFIER
    (96) LITERAL -> . FLOAT
    (97) LITERAL -> . INTEGER
    (98) LITERAL -> . BOOL
    (99) LITERAL -> . CHAR
    (100) LITERAL -> . STRING

    ENDSTATEMENT    reduce using rule 68 (ALT -> .)
    CLOSE_BRACE     reduce using rule 68 (ALT -> .)
    MINUS           shift and go to state 23
    TYPENAME        shift and go to state 16
    OPEN_PAREN      shift and go to state 39
    IDENTIFIER      shift and go to state 36
    FLOAT           shift and go to state 25
    INTEGER         shift and go to state 24
    BOOL            shift and go to state 29
    CHAR            shift and go to state 30
    STRING          shift and go to state 31

    ALTS                           shift and go to state 162
    ALT                            shift and go to state 163
    LPAT                           shift and go to state 164
    APAT                           shift and go to state 21
    PARAM                          shift and go to state 27
    LITERAL                        shift and go to state 28

state 153

    (45) GDRHS -> GIVEN EXP EQUALS EXP GDRHS .

    WHERE           reduce using rule 45 (GDRHS -> GIVEN EXP EQUALS EXP GDRHS .)
    CLOSE_BRACE     reduce using rule 45 (GDRHS -> GIVEN EXP EQUALS EXP GDRHS .)
    ENDSTATEMENT    reduce using rule 45 (GDRHS -> GIVEN EXP EQUALS EXP GDRHS .)


state 154

    (34) ATYPE -> TYPENAME .

    TYPENAME        reduce using rule 34 (ATYPE -> TYPENAME .)
    IDENTIFIER      reduce using rule 34 (ATYPE -> TYPENAME .)
    OPEN_PAREN      reduce using rule 34 (ATYPE -> TYPENAME .)
    PIPE            reduce using rule 34 (ATYPE -> TYPENAME .)
    CLOSE_BRACE     reduce using rule 34 (ATYPE -> TYPENAME .)
    ENDSTATEMENT    reduce using rule 34 (ATYPE -> TYPENAME .)
    ARROW           reduce using rule 34 (ATYPE -> TYPENAME .)
    CLOSE_PAREN     reduce using rule 34 (ATYPE -> TYPENAME .)


state 155

    (32) ATYPES -> ATYPES ATYPE .

    TYPENAME        reduce using rule 32 (ATYPES -> ATYPES ATYPE .)
    IDENTIFIER      reduce using rule 32 (ATYPES -> ATYPES ATYPE .)
    OPEN_PAREN      reduce using rule 32 (ATYPES -> ATYPES ATYPE .)
    PIPE            reduce using rule 32 (ATYPES -> ATYPES ATYPE .)
    CLOSE_BRACE     reduce using rule 32 (ATYPES -> ATYPES ATYPE .)
    ENDSTATEMENT    reduce using rule 32 (ATYPES -> ATYPES ATYPE .)


state 156

    (35) ATYPE -> IDENTIFIER .

    TYPENAME        reduce using rule 35 (ATYPE -> IDENTIFIER .)
    IDENTIFIER      reduce using rule 35 (ATYPE -> IDENTIFIER .)
    OPEN_PAREN      reduce using rule 35 (ATYPE -> IDENTIFIER .)
    PIPE            reduce using rule 35 (ATYPE -> IDENTIFIER .)
    CLOSE_BRACE     reduce using rule 35 (ATYPE -> IDENTIFIER .)
    ENDSTATEMENT    reduce using rule 35 (ATYPE -> IDENTIFIER .)
    ARROW           reduce using rule 35 (ATYPE -> IDENTIFIER .)
    CLOSE_PAREN     reduce using rule 35 (ATYPE -> IDENTIFIER .)


state 157

    (36) ATYPE -> OPEN_PAREN . TYPE CLOSE_PAREN
    (30) TYPE -> . ATYPE
    (31) TYPE -> . ATYPE ARROW TYPE
    (34) ATYPE -> . TYPENAME
    (35) ATYPE -> . IDENTIFIER
    (36) ATYPE -> . OPEN_PAREN TYPE CLOSE_PAREN

    TYPENAME        shift and go to state 154
    IDENTIFIER      shift and go to state 156
    OPEN_PAREN      shift and go to state 157

    TYPE                           shift and go to state 165
    ATYPE                          shift and go to state 166

state 158

    (14) CONSTRUCTORS -> CONSTRUCTORS PIPE CONSTRUCTOR .

    PIPE            reduce using rule 14 (CONSTRUCTORS -> CONSTRUCTORS PIPE CONSTRUCTOR .)
    CLOSE_BRACE     reduce using rule 14 (CONSTRUCTORS -> CONSTRUCTORS PIPE CONSTRUCTOR .)
    ENDSTATEMENT    reduce using rule 14 (CONSTRUCTORS -> CONSTRUCTORS PIPE CONSTRUCTOR .)


state 159

    (52) LEXP -> EXP IF EXP ELSE EXP .
    (52) LEXP -> EXP . IF EXP ELSE EXP

  ! shift/reduce conflict for IF resolved as shift
    BACKTICK        reduce using rule 52 (LEXP -> EXP IF EXP ELSE EXP .)
    PLUS            reduce using rule 52 (LEXP -> EXP IF EXP ELSE EXP .)
    MINUS           reduce using rule 52 (LEXP -> EXP IF EXP ELSE EXP .)
    TIMES           reduce using rule 52 (LEXP -> EXP IF EXP ELSE EXP .)
    DIVIDE          reduce using rule 52 (LEXP -> EXP IF EXP ELSE EXP .)
    MODULO          reduce using rule 52 (LEXP -> EXP IF EXP ELSE EXP .)
    POW             reduce using rule 52 (LEXP -> EXP IF EXP ELSE EXP .)
    EQUALITY        reduce using rule 52 (LEXP -> EXP IF EXP ELSE EXP .)
    INEQUALITY      reduce using rule 52 (LEXP -> EXP IF EXP ELSE EXP .)
    LESS            reduce using rule 52 (LEXP -> EXP IF EXP ELSE EXP .)
    LEQ             reduce using rule 52 (LEXP -> EXP IF EXP ELSE EXP .)
    GREATER         reduce using rule 52 (LEXP -> EXP IF EXP ELSE EXP .)
    GEQ             reduce using rule 52 (LEXP -> EXP IF EXP ELSE EXP .)
    AND             reduce using rule 52 (LEXP -> EXP IF EXP ELSE EXP .)
    OR              reduce using rule 52 (LEXP -> EXP IF EXP ELSE EXP .)
    WHERE           reduce using rule 52 (LEXP -> EXP IF EXP ELSE EXP .)
    CLOSE_BRACE     reduce using rule 52 (LEXP -> EXP IF EXP ELSE EXP .)
    ENDSTATEMENT    reduce using rule 52 (LEXP -> EXP IF EXP ELSE EXP .)
    EQUALS          reduce using rule 52 (LEXP -> EXP IF EXP ELSE EXP .)
    OF              reduce using rule 52 (LEXP -> EXP IF EXP ELSE EXP .)
    ELSE            reduce using rule 52 (LEXP -> EXP IF EXP ELSE EXP .)
    CLOSE_PAREN     reduce using rule 52 (LEXP -> EXP IF EXP ELSE EXP .)
    GIVEN           reduce using rule 52 (LEXP -> EXP IF EXP ELSE EXP .)
    IF              shift and go to state 109

  ! IF              [ reduce using rule 52 (LEXP -> EXP IF EXP ELSE EXP .) ]


state 160

    (50) LEXP -> LAMBDA APAT APATS ARROW EXP .
    (52) LEXP -> EXP . IF EXP ELSE EXP

  ! shift/reduce conflict for IF resolved as shift
    BACKTICK        reduce using rule 50 (LEXP -> LAMBDA APAT APATS ARROW EXP .)
    PLUS            reduce using rule 50 (LEXP -> LAMBDA APAT APATS ARROW EXP .)
    MINUS           reduce using rule 50 (LEXP -> LAMBDA APAT APATS ARROW EXP .)
    TIMES           reduce using rule 50 (LEXP -> LAMBDA APAT APATS ARROW EXP .)
    DIVIDE          reduce using rule 50 (LEXP -> LAMBDA APAT APATS ARROW EXP .)
    MODULO          reduce using rule 50 (LEXP -> LAMBDA APAT APATS ARROW EXP .)
    POW             reduce using rule 50 (LEXP -> LAMBDA APAT APATS ARROW EXP .)
    EQUALITY        reduce using rule 50 (LEXP -> LAMBDA APAT APATS ARROW EXP .)
    INEQUALITY      reduce using rule 50 (LEXP -> LAMBDA APAT APATS ARROW EXP .)
    LESS            reduce using rule 50 (LEXP -> LAMBDA APAT APATS ARROW EXP .)
    LEQ             reduce using rule 50 (LEXP -> LAMBDA APAT APATS ARROW EXP .)
    GREATER         reduce using rule 50 (LEXP -> LAMBDA APAT APATS ARROW EXP .)
    GEQ             reduce using rule 50 (LEXP -> LAMBDA APAT APATS ARROW EXP .)
    AND             reduce using rule 50 (LEXP -> LAMBDA APAT APATS ARROW EXP .)
    OR              reduce using rule 50 (LEXP -> LAMBDA APAT APATS ARROW EXP .)
    WHERE           reduce using rule 50 (LEXP -> LAMBDA APAT APATS ARROW EXP .)
    CLOSE_BRACE     reduce using rule 50 (LEXP -> LAMBDA APAT APATS ARROW EXP .)
    ENDSTATEMENT    reduce using rule 50 (LEXP -> LAMBDA APAT APATS ARROW EXP .)
    EQUALS          reduce using rule 50 (LEXP -> LAMBDA APAT APATS ARROW EXP .)
    OF              reduce using rule 50 (LEXP -> LAMBDA APAT APATS ARROW EXP .)
    ELSE            reduce using rule 50 (LEXP -> LAMBDA APAT APATS ARROW EXP .)
    CLOSE_PAREN     reduce using rule 50 (LEXP -> LAMBDA APAT APATS ARROW EXP .)
    GIVEN           reduce using rule 50 (LEXP -> LAMBDA APAT APATS ARROW EXP .)
    IF              shift and go to state 109

  ! IF              [ reduce using rule 50 (LEXP -> LAMBDA APAT APATS ARROW EXP .) ]


state 161

    (19) DECLARATIONS_LIST -> DECLARATION ENDSTATEMENT DECLARATIONS_LIST .

    CLOSE_BRACE     reduce using rule 19 (DECLARATIONS_LIST -> DECLARATION ENDSTATEMENT DECLARATIONS_LIST .)


state 162

    (53) LEXP -> MATCH EXP OF OPEN_BRACE ALTS . CLOSE_BRACE

    CLOSE_BRACE     shift and go to state 167


state 163

    (65) ALTS -> ALT . ENDSTATEMENT ALTS
    (66) ALTS -> ALT .

    ENDSTATEMENT    shift and go to state 168
    CLOSE_BRACE     reduce using rule 66 (ALTS -> ALT .)


state 164

    (67) ALT -> LPAT . ARROW EXP

    ARROW           shift and go to state 169


state 165

    (36) ATYPE -> OPEN_PAREN TYPE . CLOSE_PAREN

    CLOSE_PAREN     shift and go to state 170


state 166

    (30) TYPE -> ATYPE .
    (31) TYPE -> ATYPE . ARROW TYPE

    CLOSE_PAREN     reduce using rule 30 (TYPE -> ATYPE .)
    ARROW           shift and go to state 171


state 167

    (53) LEXP -> MATCH EXP OF OPEN_BRACE ALTS CLOSE_BRACE .

    BACKTICK        reduce using rule 53 (LEXP -> MATCH EXP OF OPEN_BRACE ALTS CLOSE_BRACE .)
    PLUS            reduce using rule 53 (LEXP -> MATCH EXP OF OPEN_BRACE ALTS CLOSE_BRACE .)
    MINUS           reduce using rule 53 (LEXP -> MATCH EXP OF OPEN_BRACE ALTS CLOSE_BRACE .)
    TIMES           reduce using rule 53 (LEXP -> MATCH EXP OF OPEN_BRACE ALTS CLOSE_BRACE .)
    DIVIDE          reduce using rule 53 (LEXP -> MATCH EXP OF OPEN_BRACE ALTS CLOSE_BRACE .)
    MODULO          reduce using rule 53 (LEXP -> MATCH EXP OF OPEN_BRACE ALTS CLOSE_BRACE .)
    POW             reduce using rule 53 (LEXP -> MATCH EXP OF OPEN_BRACE ALTS CLOSE_BRACE .)
    EQUALITY        reduce using rule 53 (LEXP -> MATCH EXP OF OPEN_BRACE ALTS CLOSE_BRACE .)
    INEQUALITY      reduce using rule 53 (LEXP -> MATCH EXP OF OPEN_BRACE ALTS CLOSE_BRACE .)
    LESS            reduce using rule 53 (LEXP -> MATCH EXP OF OPEN_BRACE ALTS CLOSE_BRACE .)
    LEQ             reduce using rule 53 (LEXP -> MATCH EXP OF OPEN_BRACE ALTS CLOSE_BRACE .)
    GREATER         reduce using rule 53 (LEXP -> MATCH EXP OF OPEN_BRACE ALTS CLOSE_BRACE .)
    GEQ             reduce using rule 53 (LEXP -> MATCH EXP OF OPEN_BRACE ALTS CLOSE_BRACE .)
    AND             reduce using rule 53 (LEXP -> MATCH EXP OF OPEN_BRACE ALTS CLOSE_BRACE .)
    OR              reduce using rule 53 (LEXP -> MATCH EXP OF OPEN_BRACE ALTS CLOSE_BRACE .)
    WHERE           reduce using rule 53 (LEXP -> MATCH EXP OF OPEN_BRACE ALTS CLOSE_BRACE .)
    IF              reduce using rule 53 (LEXP -> MATCH EXP OF OPEN_BRACE ALTS CLOSE_BRACE .)
    CLOSE_BRACE     reduce using rule 53 (LEXP -> MATCH EXP OF OPEN_BRACE ALTS CLOSE_BRACE .)
    ENDSTATEMENT    reduce using rule 53 (LEXP -> MATCH EXP OF OPEN_BRACE ALTS CLOSE_BRACE .)
    EQUALS          reduce using rule 53 (LEXP -> MATCH EXP OF OPEN_BRACE ALTS CLOSE_BRACE .)
    OF              reduce using rule 53 (LEXP -> MATCH EXP OF OPEN_BRACE ALTS CLOSE_BRACE .)
    ELSE            reduce using rule 53 (LEXP -> MATCH EXP OF OPEN_BRACE ALTS CLOSE_BRACE .)
    CLOSE_PAREN     reduce using rule 53 (LEXP -> MATCH EXP OF OPEN_BRACE ALTS CLOSE_BRACE .)
    GIVEN           reduce using rule 53 (LEXP -> MATCH EXP OF OPEN_BRACE ALTS CLOSE_BRACE .)


state 168

    (65) ALTS -> ALT ENDSTATEMENT . ALTS
    (65) ALTS -> . ALT ENDSTATEMENT ALTS
    (66) ALTS -> . ALT
    (67) ALT -> . LPAT ARROW EXP
    (68) ALT -> .
    (69) LPAT -> . APAT
    (70) LPAT -> . MINUS OPEN_PAREN INTEGER CLOSE_PAREN
    (71) LPAT -> . MINUS OPEN_PAREN FLOAT CLOSE_PAREN
    (72) LPAT -> . TYPENAME APAT APATS
    (73) APAT -> . PARAM
    (74) APAT -> . TYPENAME
    (75) APAT -> . LITERAL
    (76) APAT -> . OPEN_PAREN LPAT CLOSE_PAREN
    (103) PARAM -> . IDENTIFIER
    (96) LITERAL -> . FLOAT
    (97) LITERAL -> . INTEGER
    (98) LITERAL -> . BOOL
    (99) LITERAL -> . CHAR
    (100) LITERAL -> . STRING

    ENDSTATEMENT    reduce using rule 68 (ALT -> .)
    CLOSE_BRACE     reduce using rule 68 (ALT -> .)
    MINUS           shift and go to state 23
    TYPENAME        shift and go to state 16
    OPEN_PAREN      shift and go to state 39
    IDENTIFIER      shift and go to state 36
    FLOAT           shift and go to state 25
    INTEGER         shift and go to state 24
    BOOL            shift and go to state 29
    CHAR            shift and go to state 30
    STRING          shift and go to state 31

    ALT                            shift and go to state 163
    ALTS                           shift and go to state 172
    LPAT                           shift and go to state 164
    APAT                           shift and go to state 21
    PARAM                          shift and go to state 27
    LITERAL                        shift and go to state 28

state 169

    (67) ALT -> LPAT ARROW . EXP
    (46) EXP -> . INFIX_EXP
    (47) INFIX_EXP -> . LEXP OP INFIX_EXP
    (48) INFIX_EXP -> . MINUS INFIX_EXP
    (49) INFIX_EXP -> . LEXP
    (50) LEXP -> . LAMBDA APAT APATS ARROW EXP
    (51) LEXP -> . LET DECLARATIONS IN EXP
    (52) LEXP -> . EXP IF EXP ELSE EXP
    (53) LEXP -> . MATCH EXP OF OPEN_BRACE ALTS CLOSE_BRACE
    (54) LEXP -> . FEXP
    (55) FEXP -> . FEXP AEXP
    (56) FEXP -> . AEXP
    (57) AEXP -> . USED_VAR
    (58) AEXP -> . USED_TYPENAME
    (59) AEXP -> . LITERAL
    (60) AEXP -> . OPERATOR_FUNC
    (61) AEXP -> . OPEN_PAREN EXP CLOSE_PAREN
    (101) USED_VAR -> . IDENTIFIER
    (102) USED_TYPENAME -> . TYPENAME
    (96) LITERAL -> . FLOAT
    (97) LITERAL -> . INTEGER
    (98) LITERAL -> . BOOL
    (99) LITERAL -> . CHAR
    (100) LITERAL -> . STRING
    (62) OPERATOR_FUNC -> . OPEN_PAREN OP CLOSE_PAREN

    MINUS           shift and go to state 82
    LAMBDA          shift and go to state 83
    LET             shift and go to state 84
    MATCH           shift and go to state 85
    OPEN_PAREN      shift and go to state 92
    IDENTIFIER      shift and go to state 93
    TYPENAME        shift and go to state 94
    FLOAT           shift and go to state 25
    INTEGER         shift and go to state 24
    BOOL            shift and go to state 29
    CHAR            shift and go to state 30
    STRING          shift and go to state 31

    EXP                            shift and go to state 173
    INFIX_EXP                      shift and go to state 80
    LEXP                           shift and go to state 81
    FEXP                           shift and go to state 86
    AEXP                           shift and go to state 87
    USED_VAR                       shift and go to state 88
    USED_TYPENAME                  shift and go to state 89
    LITERAL                        shift and go to state 90
    OPERATOR_FUNC                  shift and go to state 91

state 170

    (36) ATYPE -> OPEN_PAREN TYPE CLOSE_PAREN .

    TYPENAME        reduce using rule 36 (ATYPE -> OPEN_PAREN TYPE CLOSE_PAREN .)
    IDENTIFIER      reduce using rule 36 (ATYPE -> OPEN_PAREN TYPE CLOSE_PAREN .)
    OPEN_PAREN      reduce using rule 36 (ATYPE -> OPEN_PAREN TYPE CLOSE_PAREN .)
    PIPE            reduce using rule 36 (ATYPE -> OPEN_PAREN TYPE CLOSE_PAREN .)
    CLOSE_BRACE     reduce using rule 36 (ATYPE -> OPEN_PAREN TYPE CLOSE_PAREN .)
    ENDSTATEMENT    reduce using rule 36 (ATYPE -> OPEN_PAREN TYPE CLOSE_PAREN .)
    ARROW           reduce using rule 36 (ATYPE -> OPEN_PAREN TYPE CLOSE_PAREN .)
    CLOSE_PAREN     reduce using rule 36 (ATYPE -> OPEN_PAREN TYPE CLOSE_PAREN .)


state 171

    (31) TYPE -> ATYPE ARROW . TYPE
    (30) TYPE -> . ATYPE
    (31) TYPE -> . ATYPE ARROW TYPE
    (34) ATYPE -> . TYPENAME
    (35) ATYPE -> . IDENTIFIER
    (36) ATYPE -> . OPEN_PAREN TYPE CLOSE_PAREN

    TYPENAME        shift and go to state 154
    IDENTIFIER      shift and go to state 156
    OPEN_PAREN      shift and go to state 157

    ATYPE                          shift and go to state 166
    TYPE                           shift and go to state 174

state 172

    (65) ALTS -> ALT ENDSTATEMENT ALTS .

    CLOSE_BRACE     reduce using rule 65 (ALTS -> ALT ENDSTATEMENT ALTS .)


state 173

    (67) ALT -> LPAT ARROW EXP .
    (52) LEXP -> EXP . IF EXP ELSE EXP

    ENDSTATEMENT    reduce using rule 67 (ALT -> LPAT ARROW EXP .)
    CLOSE_BRACE     reduce using rule 67 (ALT -> LPAT ARROW EXP .)
    IF              shift and go to state 109


state 174

    (31) TYPE -> ATYPE ARROW TYPE .

    CLOSE_PAREN     reduce using rule 31 (TYPE -> ATYPE ARROW TYPE .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for BACKTICK in state 81 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 81 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 81 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 81 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 81 resolved as shift
WARNING: shift/reduce conflict for MODULO in state 81 resolved as shift
WARNING: shift/reduce conflict for POW in state 81 resolved as shift
WARNING: shift/reduce conflict for EQUALITY in state 81 resolved as shift
WARNING: shift/reduce conflict for INEQUALITY in state 81 resolved as shift
WARNING: shift/reduce conflict for LESS in state 81 resolved as shift
WARNING: shift/reduce conflict for LEQ in state 81 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 81 resolved as shift
WARNING: shift/reduce conflict for GEQ in state 81 resolved as shift
WARNING: shift/reduce conflict for AND in state 81 resolved as shift
WARNING: shift/reduce conflict for OR in state 81 resolved as shift
WARNING: shift/reduce conflict for CLOSE_BRACE in state 116 resolved as shift
WARNING: shift/reduce conflict for IF in state 149 resolved as shift
WARNING: shift/reduce conflict for IF in state 159 resolved as shift
WARNING: shift/reduce conflict for IF in state 160 resolved as shift
WARNING: reduce/reduce conflict in state 112 resolved using rule (EXP -> INFIX_EXP)
WARNING: rejected rule (INFIX_EXP -> MINUS INFIX_EXP) in state 112
WARNING: reduce/reduce conflict in state 134 resolved using rule (EXP -> INFIX_EXP)
WARNING: rejected rule (INFIX_EXP -> LEXP OP INFIX_EXP) in state 134
