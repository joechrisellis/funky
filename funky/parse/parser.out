Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    WHITESPACE

Grammar

Rule 0     S' -> MODULE_DEFINITION
Rule 1     MODULE_DEFINITION -> MODULE IDENTIFIER WITH MODULE_BODY
Rule 2     MODULE_BODY -> OPEN_BRACE IMPORT_STATEMENTS ENDSTATEMENT TOPLEVEL_DECLARATIONS CLOSE_BRACE
Rule 3     MODULE_BODY -> OPEN_BRACE TOPLEVEL_DECLARATIONS CLOSE_BRACE
Rule 4     IMPORT_STATEMENTS -> IMPORT_STATEMENTS ENDSTATEMENT IMPORT_STATEMENT
Rule 5     IMPORT_STATEMENTS -> IMPORT_STATEMENT
Rule 6     IMPORT_STATEMENT -> IMPORT STRING
Rule 7     TOPLEVEL_DECLARATIONS -> TOPLEVEL_DECLARATIONS ENDSTATEMENT TOP_DECLARATION
Rule 8     TOPLEVEL_DECLARATIONS -> TOP_DECLARATION
Rule 9     TOP_DECLARATION -> ADT_DECLARATION
Rule 10    TOP_DECLARATION -> DECLARATION
Rule 11    ADT_DECLARATION -> NEWTYPE TYPENAME EQUALS CONSTRUCTORS
Rule 12    CONSTRUCTORS -> CONSTRUCTORS PIPE CONSTRUCTOR
Rule 13    CONSTRUCTORS -> CONSTRUCTOR
Rule 14    CONSTRUCTOR -> TYPENAME ATYPES
Rule 15    DECLARATIONS -> OPEN_BRACE DECLARATIONS_LIST CLOSE_BRACE
Rule 16    DECLARATIONS -> OPEN_BRACE CLOSE_BRACE
Rule 17    DECLARATIONS_LIST -> DECLARATION ENDSTATEMENT DECLARATIONS_LIST
Rule 18    DECLARATIONS_LIST -> DECLARATION
Rule 19    DECLARATION -> FUNCTION_DEFINITION
Rule 20    DECLARATION -> VARIABLE_DEFINITION
Rule 21    DECLARATION -> FIXITY_DECLARATION
Rule 22    DECLARATION -> <empty>
Rule 23    FUNCTION_DEFINITION -> FUNCTION_LHS RHS
Rule 24    VARIABLE_DEFINITION -> PARAM RHS
Rule 25    FIXITY_DECLARATION -> SETFIX ASSOCIATIVITY INTEGER OP
Rule 26    ASSOCIATIVITY -> LEFTASSOC
Rule 27    ASSOCIATIVITY -> RIGHTASSOC
Rule 28    ASSOCIATIVITY -> NONASSOC
Rule 29    TYPE -> ATYPE
Rule 30    TYPE -> ATYPE ARROW TYPE
Rule 31    ATYPES -> ATYPES ATYPE
Rule 32    ATYPES -> <empty>
Rule 33    ATYPE -> TYPENAME
Rule 34    ATYPE -> IDENTIFIER
Rule 35    ATYPE -> OPEN_PAREN TYPE CLOSE_PAREN
Rule 36    FUNCTION_LHS -> IDENTIFIER APAT APATS
Rule 37    FUNCTION_LHS -> OPEN_PAREN FUNCTION_LHS CLOSE_PAREN APAT APATS
Rule 38    FUNCTION_LHS -> INFIX_FUNCTION_DEFINITION
Rule 39    INFIX_FUNCTION_DEFINITION -> LPAT INFIX_FUNCTION LPAT
Rule 40    RHS -> EQUALS EXP
Rule 41    RHS -> EQUALS EXP WITH DECLARATIONS
Rule 42    RHS -> GDRHS
Rule 43    RHS -> GDRHS WITH DECLARATIONS
Rule 44    GDRHS -> GIVEN EXP EQUALS EXP
Rule 45    GDRHS -> GIVEN EXP EQUALS EXP GDRHS
Rule 46    EXP -> INFIX_EXP
Rule 47    INFIX_EXP -> LEXP OP INFIX_EXP
Rule 48    INFIX_EXP -> MINUS INFIX_EXP
Rule 49    INFIX_EXP -> LEXP
Rule 50    LEXP -> LAMBDA_ABSTRACTION
Rule 51    LEXP -> LET_EXPR
Rule 52    LEXP -> IF_EXPR
Rule 53    LEXP -> MATCH_EXPR
Rule 54    LEXP -> FUNCTION_EXPR
Rule 55    LAMBDA_ABSTRACTION -> LAMBDA APAT APATS ARROW EXP
Rule 56    LET_EXPR -> LET DECLARATIONS IN EXP
Rule 57    IF_EXPR -> EXP IF EXP ELSE EXP
Rule 58    MATCH_EXPR -> MATCH EXP ON OPEN_BRACE ALTS CLOSE_BRACE
Rule 59    FUNCTION_EXPR -> FUNCTION_EXPR AEXP
Rule 60    FUNCTION_EXPR -> AEXP
Rule 61    AEXP -> USED_VAR
Rule 62    AEXP -> USED_TYPENAME
Rule 63    AEXP -> LITERAL
Rule 64    AEXP -> OPERATOR_FUNC
Rule 65    AEXP -> OPEN_PAREN EXP CLOSE_PAREN
Rule 66    OPERATOR_FUNC -> OPEN_PAREN OP CLOSE_PAREN
Rule 67    ALTS -> ALT ENDSTATEMENT ALTS
Rule 68    ALTS -> ALT
Rule 69    ALT -> LPAT ARROW EXP
Rule 70    ALT -> <empty>
Rule 71    LPAT -> APAT
Rule 72    LPAT -> CONSTRUCTOR_PATTERN
Rule 73    LPAT -> NEGATIVE_LITERAL
Rule 74    CONSTRUCTOR_PATTERN -> TYPENAME APAT APATS
Rule 75    NEGATIVE_LITERAL -> MINUS INTEGER
Rule 76    NEGATIVE_LITERAL -> MINUS FLOAT
Rule 77    APAT -> PARAM
Rule 78    APAT -> TYPENAME
Rule 79    APAT -> LITERAL
Rule 80    APAT -> OPEN_PAREN LPAT CLOSE_PAREN
Rule 81    OP -> VARSYM
Rule 82    OP -> INFIX_FUNCTION
Rule 83    INFIX_FUNCTION -> TILDE IDENTIFIER TILDE
Rule 84    APATS -> APAT APATS
Rule 85    APATS -> <empty>
Rule 86    VARSYM -> PLUS
Rule 87    VARSYM -> MINUS
Rule 88    VARSYM -> TIMES
Rule 89    VARSYM -> DIVIDE
Rule 90    VARSYM -> MODULO
Rule 91    VARSYM -> FPOW
Rule 92    VARSYM -> IPOW
Rule 93    VARSYM -> EQUALITY
Rule 94    VARSYM -> INEQUALITY
Rule 95    VARSYM -> LESS
Rule 96    VARSYM -> LEQ
Rule 97    VARSYM -> GREATER
Rule 98    VARSYM -> GEQ
Rule 99    VARSYM -> CONCAT
Rule 100   VARSYM -> AND
Rule 101   VARSYM -> OR
Rule 102   LITERAL -> FLOAT
Rule 103   LITERAL -> INTEGER
Rule 104   LITERAL -> BOOL
Rule 105   LITERAL -> STRING
Rule 106   USED_VAR -> IDENTIFIER
Rule 107   USED_TYPENAME -> TYPENAME
Rule 108   PARAM -> IDENTIFIER

Terminals, with rules where they appear

AND                  : 100
ARROW                : 30 55 69
BOOL                 : 104
CLOSE_BRACE          : 2 3 15 16 58
CLOSE_PAREN          : 35 37 65 66 80
CONCAT               : 99
DIVIDE               : 89
ELSE                 : 57
ENDSTATEMENT         : 2 4 7 17 67
EQUALITY             : 93
EQUALS               : 11 40 41 44 45
FLOAT                : 76 102
FPOW                 : 91
GEQ                  : 98
GIVEN                : 44 45
GREATER              : 97
IDENTIFIER           : 1 34 36 83 106 108
IF                   : 57
IMPORT               : 6
IN                   : 56
INEQUALITY           : 94
INTEGER              : 25 75 103
IPOW                 : 92
LAMBDA               : 55
LEFTASSOC            : 26
LEQ                  : 96
LESS                 : 95
LET                  : 56
MATCH                : 58
MINUS                : 48 75 76 87
MODULE               : 1
MODULO               : 90
NEWTYPE              : 11
NONASSOC             : 28
ON                   : 58
OPEN_BRACE           : 2 3 15 16 58
OPEN_PAREN           : 35 37 65 66 80
OR                   : 101
PIPE                 : 12
PLUS                 : 86
RIGHTASSOC           : 27
SETFIX               : 25
STRING               : 6 105
TILDE                : 83 83
TIMES                : 88
TYPENAME             : 11 14 33 74 78 107
WHITESPACE           : 
WITH                 : 1 41 43
error                : 

Nonterminals, with rules where they appear

ADT_DECLARATION      : 9
AEXP                 : 59 60
ALT                  : 67 68
ALTS                 : 58 67
APAT                 : 36 37 55 71 74 84
APATS                : 36 37 55 74 84
ASSOCIATIVITY        : 25
ATYPE                : 29 30 31
ATYPES               : 14 31
CONSTRUCTOR          : 12 13
CONSTRUCTORS         : 11 12
CONSTRUCTOR_PATTERN  : 72
DECLARATION          : 10 17 18
DECLARATIONS         : 41 43 56
DECLARATIONS_LIST    : 15 17
EXP                  : 40 41 44 44 45 45 55 56 57 57 57 58 65 69
FIXITY_DECLARATION   : 21
FUNCTION_DEFINITION  : 19
FUNCTION_EXPR        : 54 59
FUNCTION_LHS         : 23 37
GDRHS                : 42 43 45
IF_EXPR              : 52
IMPORT_STATEMENT     : 4 5
IMPORT_STATEMENTS    : 2 4
INFIX_EXP            : 46 47 48
INFIX_FUNCTION       : 39 82
INFIX_FUNCTION_DEFINITION : 38
LAMBDA_ABSTRACTION   : 50
LET_EXPR             : 51
LEXP                 : 47 49
LITERAL              : 63 79
LPAT                 : 39 39 69 80
MATCH_EXPR           : 53
MODULE_BODY          : 1
MODULE_DEFINITION    : 0
NEGATIVE_LITERAL     : 73
OP                   : 25 47 66
OPERATOR_FUNC        : 64
PARAM                : 24 77
RHS                  : 23 24
TOPLEVEL_DECLARATIONS : 2 3 7
TOP_DECLARATION      : 7 8
TYPE                 : 30 35
USED_TYPENAME        : 62
USED_VAR             : 61
VARIABLE_DEFINITION  : 20
VARSYM               : 81

Parsing method: LALR

state 0

    (0) S' -> . MODULE_DEFINITION
    (1) MODULE_DEFINITION -> . MODULE IDENTIFIER WITH MODULE_BODY

    MODULE          shift and go to state 2

    MODULE_DEFINITION              shift and go to state 1

state 1

    (0) S' -> MODULE_DEFINITION .



state 2

    (1) MODULE_DEFINITION -> MODULE . IDENTIFIER WITH MODULE_BODY

    IDENTIFIER      shift and go to state 3


state 3

    (1) MODULE_DEFINITION -> MODULE IDENTIFIER . WITH MODULE_BODY

    WITH            shift and go to state 4


state 4

    (1) MODULE_DEFINITION -> MODULE IDENTIFIER WITH . MODULE_BODY
    (2) MODULE_BODY -> . OPEN_BRACE IMPORT_STATEMENTS ENDSTATEMENT TOPLEVEL_DECLARATIONS CLOSE_BRACE
    (3) MODULE_BODY -> . OPEN_BRACE TOPLEVEL_DECLARATIONS CLOSE_BRACE

    OPEN_BRACE      shift and go to state 6

    MODULE_BODY                    shift and go to state 5

state 5

    (1) MODULE_DEFINITION -> MODULE IDENTIFIER WITH MODULE_BODY .

    $end            reduce using rule 1 (MODULE_DEFINITION -> MODULE IDENTIFIER WITH MODULE_BODY .)


state 6

    (2) MODULE_BODY -> OPEN_BRACE . IMPORT_STATEMENTS ENDSTATEMENT TOPLEVEL_DECLARATIONS CLOSE_BRACE
    (3) MODULE_BODY -> OPEN_BRACE . TOPLEVEL_DECLARATIONS CLOSE_BRACE
    (4) IMPORT_STATEMENTS -> . IMPORT_STATEMENTS ENDSTATEMENT IMPORT_STATEMENT
    (5) IMPORT_STATEMENTS -> . IMPORT_STATEMENT
    (7) TOPLEVEL_DECLARATIONS -> . TOPLEVEL_DECLARATIONS ENDSTATEMENT TOP_DECLARATION
    (8) TOPLEVEL_DECLARATIONS -> . TOP_DECLARATION
    (6) IMPORT_STATEMENT -> . IMPORT STRING
    (9) TOP_DECLARATION -> . ADT_DECLARATION
    (10) TOP_DECLARATION -> . DECLARATION
    (11) ADT_DECLARATION -> . NEWTYPE TYPENAME EQUALS CONSTRUCTORS
    (19) DECLARATION -> . FUNCTION_DEFINITION
    (20) DECLARATION -> . VARIABLE_DEFINITION
    (21) DECLARATION -> . FIXITY_DECLARATION
    (22) DECLARATION -> .
    (23) FUNCTION_DEFINITION -> . FUNCTION_LHS RHS
    (24) VARIABLE_DEFINITION -> . PARAM RHS
    (25) FIXITY_DECLARATION -> . SETFIX ASSOCIATIVITY INTEGER OP
    (36) FUNCTION_LHS -> . IDENTIFIER APAT APATS
    (37) FUNCTION_LHS -> . OPEN_PAREN FUNCTION_LHS CLOSE_PAREN APAT APATS
    (38) FUNCTION_LHS -> . INFIX_FUNCTION_DEFINITION
    (108) PARAM -> . IDENTIFIER
    (39) INFIX_FUNCTION_DEFINITION -> . LPAT INFIX_FUNCTION LPAT
    (71) LPAT -> . APAT
    (72) LPAT -> . CONSTRUCTOR_PATTERN
    (73) LPAT -> . NEGATIVE_LITERAL
    (77) APAT -> . PARAM
    (78) APAT -> . TYPENAME
    (79) APAT -> . LITERAL
    (80) APAT -> . OPEN_PAREN LPAT CLOSE_PAREN
    (74) CONSTRUCTOR_PATTERN -> . TYPENAME APAT APATS
    (75) NEGATIVE_LITERAL -> . MINUS INTEGER
    (76) NEGATIVE_LITERAL -> . MINUS FLOAT
    (102) LITERAL -> . FLOAT
    (103) LITERAL -> . INTEGER
    (104) LITERAL -> . BOOL
    (105) LITERAL -> . STRING

    IMPORT          shift and go to state 11
    NEWTYPE         shift and go to state 15
    CLOSE_BRACE     reduce using rule 22 (DECLARATION -> .)
    ENDSTATEMENT    reduce using rule 22 (DECLARATION -> .)
    SETFIX          shift and go to state 22
    IDENTIFIER      shift and go to state 24
    OPEN_PAREN      shift and go to state 26
    TYPENAME        shift and go to state 16
    MINUS           shift and go to state 32
    FLOAT           shift and go to state 33
    INTEGER         shift and go to state 23
    BOOL            shift and go to state 34
    STRING          shift and go to state 12

    IMPORT_STATEMENTS              shift and go to state 7
    TOPLEVEL_DECLARATIONS          shift and go to state 8
    IMPORT_STATEMENT               shift and go to state 9
    TOP_DECLARATION                shift and go to state 10
    ADT_DECLARATION                shift and go to state 13
    DECLARATION                    shift and go to state 14
    FUNCTION_DEFINITION            shift and go to state 17
    VARIABLE_DEFINITION            shift and go to state 18
    FIXITY_DECLARATION             shift and go to state 19
    FUNCTION_LHS                   shift and go to state 20
    PARAM                          shift and go to state 21
    APAT                           shift and go to state 25
    INFIX_FUNCTION_DEFINITION      shift and go to state 27
    LPAT                           shift and go to state 28
    CONSTRUCTOR_PATTERN            shift and go to state 29
    NEGATIVE_LITERAL               shift and go to state 30
    LITERAL                        shift and go to state 31

state 7

    (2) MODULE_BODY -> OPEN_BRACE IMPORT_STATEMENTS . ENDSTATEMENT TOPLEVEL_DECLARATIONS CLOSE_BRACE
    (4) IMPORT_STATEMENTS -> IMPORT_STATEMENTS . ENDSTATEMENT IMPORT_STATEMENT

    ENDSTATEMENT    shift and go to state 35


state 8

    (3) MODULE_BODY -> OPEN_BRACE TOPLEVEL_DECLARATIONS . CLOSE_BRACE
    (7) TOPLEVEL_DECLARATIONS -> TOPLEVEL_DECLARATIONS . ENDSTATEMENT TOP_DECLARATION

    CLOSE_BRACE     shift and go to state 36
    ENDSTATEMENT    shift and go to state 37


state 9

    (5) IMPORT_STATEMENTS -> IMPORT_STATEMENT .

    ENDSTATEMENT    reduce using rule 5 (IMPORT_STATEMENTS -> IMPORT_STATEMENT .)


state 10

    (8) TOPLEVEL_DECLARATIONS -> TOP_DECLARATION .

    CLOSE_BRACE     reduce using rule 8 (TOPLEVEL_DECLARATIONS -> TOP_DECLARATION .)
    ENDSTATEMENT    reduce using rule 8 (TOPLEVEL_DECLARATIONS -> TOP_DECLARATION .)


state 11

    (6) IMPORT_STATEMENT -> IMPORT . STRING

    STRING          shift and go to state 38


state 12

    (105) LITERAL -> STRING .

    TILDE           reduce using rule 105 (LITERAL -> STRING .)
    TYPENAME        reduce using rule 105 (LITERAL -> STRING .)
    OPEN_PAREN      reduce using rule 105 (LITERAL -> STRING .)
    IDENTIFIER      reduce using rule 105 (LITERAL -> STRING .)
    FLOAT           reduce using rule 105 (LITERAL -> STRING .)
    INTEGER         reduce using rule 105 (LITERAL -> STRING .)
    BOOL            reduce using rule 105 (LITERAL -> STRING .)
    STRING          reduce using rule 105 (LITERAL -> STRING .)
    CLOSE_PAREN     reduce using rule 105 (LITERAL -> STRING .)
    EQUALS          reduce using rule 105 (LITERAL -> STRING .)
    GIVEN           reduce using rule 105 (LITERAL -> STRING .)
    ARROW           reduce using rule 105 (LITERAL -> STRING .)
    PLUS            reduce using rule 105 (LITERAL -> STRING .)
    MINUS           reduce using rule 105 (LITERAL -> STRING .)
    TIMES           reduce using rule 105 (LITERAL -> STRING .)
    DIVIDE          reduce using rule 105 (LITERAL -> STRING .)
    MODULO          reduce using rule 105 (LITERAL -> STRING .)
    FPOW            reduce using rule 105 (LITERAL -> STRING .)
    IPOW            reduce using rule 105 (LITERAL -> STRING .)
    EQUALITY        reduce using rule 105 (LITERAL -> STRING .)
    INEQUALITY      reduce using rule 105 (LITERAL -> STRING .)
    LESS            reduce using rule 105 (LITERAL -> STRING .)
    LEQ             reduce using rule 105 (LITERAL -> STRING .)
    GREATER         reduce using rule 105 (LITERAL -> STRING .)
    GEQ             reduce using rule 105 (LITERAL -> STRING .)
    CONCAT          reduce using rule 105 (LITERAL -> STRING .)
    AND             reduce using rule 105 (LITERAL -> STRING .)
    OR              reduce using rule 105 (LITERAL -> STRING .)
    WITH            reduce using rule 105 (LITERAL -> STRING .)
    IF              reduce using rule 105 (LITERAL -> STRING .)
    CLOSE_BRACE     reduce using rule 105 (LITERAL -> STRING .)
    ENDSTATEMENT    reduce using rule 105 (LITERAL -> STRING .)
    ON              reduce using rule 105 (LITERAL -> STRING .)
    ELSE            reduce using rule 105 (LITERAL -> STRING .)


state 13

    (9) TOP_DECLARATION -> ADT_DECLARATION .

    CLOSE_BRACE     reduce using rule 9 (TOP_DECLARATION -> ADT_DECLARATION .)
    ENDSTATEMENT    reduce using rule 9 (TOP_DECLARATION -> ADT_DECLARATION .)


state 14

    (10) TOP_DECLARATION -> DECLARATION .

    CLOSE_BRACE     reduce using rule 10 (TOP_DECLARATION -> DECLARATION .)
    ENDSTATEMENT    reduce using rule 10 (TOP_DECLARATION -> DECLARATION .)


state 15

    (11) ADT_DECLARATION -> NEWTYPE . TYPENAME EQUALS CONSTRUCTORS

    TYPENAME        shift and go to state 39


state 16

    (78) APAT -> TYPENAME .
    (74) CONSTRUCTOR_PATTERN -> TYPENAME . APAT APATS
    (77) APAT -> . PARAM
    (78) APAT -> . TYPENAME
    (79) APAT -> . LITERAL
    (80) APAT -> . OPEN_PAREN LPAT CLOSE_PAREN
    (108) PARAM -> . IDENTIFIER
    (102) LITERAL -> . FLOAT
    (103) LITERAL -> . INTEGER
    (104) LITERAL -> . BOOL
    (105) LITERAL -> . STRING

    TILDE           reduce using rule 78 (APAT -> TYPENAME .)
    CLOSE_PAREN     reduce using rule 78 (APAT -> TYPENAME .)
    EQUALS          reduce using rule 78 (APAT -> TYPENAME .)
    GIVEN           reduce using rule 78 (APAT -> TYPENAME .)
    ARROW           reduce using rule 78 (APAT -> TYPENAME .)
    TYPENAME        shift and go to state 40
    OPEN_PAREN      shift and go to state 43
    IDENTIFIER      shift and go to state 44
    FLOAT           shift and go to state 33
    INTEGER         shift and go to state 23
    BOOL            shift and go to state 34
    STRING          shift and go to state 12

    APAT                           shift and go to state 41
    PARAM                          shift and go to state 42
    LITERAL                        shift and go to state 31

state 17

    (19) DECLARATION -> FUNCTION_DEFINITION .

    CLOSE_BRACE     reduce using rule 19 (DECLARATION -> FUNCTION_DEFINITION .)
    ENDSTATEMENT    reduce using rule 19 (DECLARATION -> FUNCTION_DEFINITION .)


state 18

    (20) DECLARATION -> VARIABLE_DEFINITION .

    CLOSE_BRACE     reduce using rule 20 (DECLARATION -> VARIABLE_DEFINITION .)
    ENDSTATEMENT    reduce using rule 20 (DECLARATION -> VARIABLE_DEFINITION .)


state 19

    (21) DECLARATION -> FIXITY_DECLARATION .

    CLOSE_BRACE     reduce using rule 21 (DECLARATION -> FIXITY_DECLARATION .)
    ENDSTATEMENT    reduce using rule 21 (DECLARATION -> FIXITY_DECLARATION .)


state 20

    (23) FUNCTION_DEFINITION -> FUNCTION_LHS . RHS
    (40) RHS -> . EQUALS EXP
    (41) RHS -> . EQUALS EXP WITH DECLARATIONS
    (42) RHS -> . GDRHS
    (43) RHS -> . GDRHS WITH DECLARATIONS
    (44) GDRHS -> . GIVEN EXP EQUALS EXP
    (45) GDRHS -> . GIVEN EXP EQUALS EXP GDRHS

    EQUALS          shift and go to state 46
    GIVEN           shift and go to state 48

    RHS                            shift and go to state 45
    GDRHS                          shift and go to state 47

state 21

    (24) VARIABLE_DEFINITION -> PARAM . RHS
    (77) APAT -> PARAM .
    (40) RHS -> . EQUALS EXP
    (41) RHS -> . EQUALS EXP WITH DECLARATIONS
    (42) RHS -> . GDRHS
    (43) RHS -> . GDRHS WITH DECLARATIONS
    (44) GDRHS -> . GIVEN EXP EQUALS EXP
    (45) GDRHS -> . GIVEN EXP EQUALS EXP GDRHS

    TILDE           reduce using rule 77 (APAT -> PARAM .)
    EQUALS          shift and go to state 46
    GIVEN           shift and go to state 48

    RHS                            shift and go to state 49
    GDRHS                          shift and go to state 47

state 22

    (25) FIXITY_DECLARATION -> SETFIX . ASSOCIATIVITY INTEGER OP
    (26) ASSOCIATIVITY -> . LEFTASSOC
    (27) ASSOCIATIVITY -> . RIGHTASSOC
    (28) ASSOCIATIVITY -> . NONASSOC

    LEFTASSOC       shift and go to state 51
    RIGHTASSOC      shift and go to state 52
    NONASSOC        shift and go to state 53

    ASSOCIATIVITY                  shift and go to state 50

state 23

    (103) LITERAL -> INTEGER .

    TILDE           reduce using rule 103 (LITERAL -> INTEGER .)
    TYPENAME        reduce using rule 103 (LITERAL -> INTEGER .)
    OPEN_PAREN      reduce using rule 103 (LITERAL -> INTEGER .)
    IDENTIFIER      reduce using rule 103 (LITERAL -> INTEGER .)
    FLOAT           reduce using rule 103 (LITERAL -> INTEGER .)
    INTEGER         reduce using rule 103 (LITERAL -> INTEGER .)
    BOOL            reduce using rule 103 (LITERAL -> INTEGER .)
    STRING          reduce using rule 103 (LITERAL -> INTEGER .)
    CLOSE_PAREN     reduce using rule 103 (LITERAL -> INTEGER .)
    EQUALS          reduce using rule 103 (LITERAL -> INTEGER .)
    GIVEN           reduce using rule 103 (LITERAL -> INTEGER .)
    ARROW           reduce using rule 103 (LITERAL -> INTEGER .)
    PLUS            reduce using rule 103 (LITERAL -> INTEGER .)
    MINUS           reduce using rule 103 (LITERAL -> INTEGER .)
    TIMES           reduce using rule 103 (LITERAL -> INTEGER .)
    DIVIDE          reduce using rule 103 (LITERAL -> INTEGER .)
    MODULO          reduce using rule 103 (LITERAL -> INTEGER .)
    FPOW            reduce using rule 103 (LITERAL -> INTEGER .)
    IPOW            reduce using rule 103 (LITERAL -> INTEGER .)
    EQUALITY        reduce using rule 103 (LITERAL -> INTEGER .)
    INEQUALITY      reduce using rule 103 (LITERAL -> INTEGER .)
    LESS            reduce using rule 103 (LITERAL -> INTEGER .)
    LEQ             reduce using rule 103 (LITERAL -> INTEGER .)
    GREATER         reduce using rule 103 (LITERAL -> INTEGER .)
    GEQ             reduce using rule 103 (LITERAL -> INTEGER .)
    CONCAT          reduce using rule 103 (LITERAL -> INTEGER .)
    AND             reduce using rule 103 (LITERAL -> INTEGER .)
    OR              reduce using rule 103 (LITERAL -> INTEGER .)
    WITH            reduce using rule 103 (LITERAL -> INTEGER .)
    IF              reduce using rule 103 (LITERAL -> INTEGER .)
    CLOSE_BRACE     reduce using rule 103 (LITERAL -> INTEGER .)
    ENDSTATEMENT    reduce using rule 103 (LITERAL -> INTEGER .)
    ON              reduce using rule 103 (LITERAL -> INTEGER .)
    ELSE            reduce using rule 103 (LITERAL -> INTEGER .)


state 24

    (36) FUNCTION_LHS -> IDENTIFIER . APAT APATS
    (108) PARAM -> IDENTIFIER .
    (77) APAT -> . PARAM
    (78) APAT -> . TYPENAME
    (79) APAT -> . LITERAL
    (80) APAT -> . OPEN_PAREN LPAT CLOSE_PAREN
    (108) PARAM -> . IDENTIFIER
    (102) LITERAL -> . FLOAT
    (103) LITERAL -> . INTEGER
    (104) LITERAL -> . BOOL
    (105) LITERAL -> . STRING

    EQUALS          reduce using rule 108 (PARAM -> IDENTIFIER .)
    GIVEN           reduce using rule 108 (PARAM -> IDENTIFIER .)
    TILDE           reduce using rule 108 (PARAM -> IDENTIFIER .)
    CLOSE_PAREN     reduce using rule 108 (PARAM -> IDENTIFIER .)
    TYPENAME        shift and go to state 40
    OPEN_PAREN      shift and go to state 43
    IDENTIFIER      shift and go to state 44
    FLOAT           shift and go to state 33
    INTEGER         shift and go to state 23
    BOOL            shift and go to state 34
    STRING          shift and go to state 12

    APAT                           shift and go to state 54
    PARAM                          shift and go to state 42
    LITERAL                        shift and go to state 31

state 25

    (71) LPAT -> APAT .

    TILDE           reduce using rule 71 (LPAT -> APAT .)
    CLOSE_PAREN     reduce using rule 71 (LPAT -> APAT .)
    EQUALS          reduce using rule 71 (LPAT -> APAT .)
    GIVEN           reduce using rule 71 (LPAT -> APAT .)
    ARROW           reduce using rule 71 (LPAT -> APAT .)


state 26

    (37) FUNCTION_LHS -> OPEN_PAREN . FUNCTION_LHS CLOSE_PAREN APAT APATS
    (80) APAT -> OPEN_PAREN . LPAT CLOSE_PAREN
    (36) FUNCTION_LHS -> . IDENTIFIER APAT APATS
    (37) FUNCTION_LHS -> . OPEN_PAREN FUNCTION_LHS CLOSE_PAREN APAT APATS
    (38) FUNCTION_LHS -> . INFIX_FUNCTION_DEFINITION
    (71) LPAT -> . APAT
    (72) LPAT -> . CONSTRUCTOR_PATTERN
    (73) LPAT -> . NEGATIVE_LITERAL
    (39) INFIX_FUNCTION_DEFINITION -> . LPAT INFIX_FUNCTION LPAT
    (77) APAT -> . PARAM
    (78) APAT -> . TYPENAME
    (79) APAT -> . LITERAL
    (80) APAT -> . OPEN_PAREN LPAT CLOSE_PAREN
    (74) CONSTRUCTOR_PATTERN -> . TYPENAME APAT APATS
    (75) NEGATIVE_LITERAL -> . MINUS INTEGER
    (76) NEGATIVE_LITERAL -> . MINUS FLOAT
    (108) PARAM -> . IDENTIFIER
    (102) LITERAL -> . FLOAT
    (103) LITERAL -> . INTEGER
    (104) LITERAL -> . BOOL
    (105) LITERAL -> . STRING

    IDENTIFIER      shift and go to state 24
    OPEN_PAREN      shift and go to state 26
    TYPENAME        shift and go to state 16
    MINUS           shift and go to state 32
    FLOAT           shift and go to state 33
    INTEGER         shift and go to state 23
    BOOL            shift and go to state 34
    STRING          shift and go to state 12

    FUNCTION_LHS                   shift and go to state 55
    APAT                           shift and go to state 25
    LPAT                           shift and go to state 56
    INFIX_FUNCTION_DEFINITION      shift and go to state 27
    CONSTRUCTOR_PATTERN            shift and go to state 29
    NEGATIVE_LITERAL               shift and go to state 30
    PARAM                          shift and go to state 42
    LITERAL                        shift and go to state 31

state 27

    (38) FUNCTION_LHS -> INFIX_FUNCTION_DEFINITION .

    EQUALS          reduce using rule 38 (FUNCTION_LHS -> INFIX_FUNCTION_DEFINITION .)
    GIVEN           reduce using rule 38 (FUNCTION_LHS -> INFIX_FUNCTION_DEFINITION .)
    CLOSE_PAREN     reduce using rule 38 (FUNCTION_LHS -> INFIX_FUNCTION_DEFINITION .)


state 28

    (39) INFIX_FUNCTION_DEFINITION -> LPAT . INFIX_FUNCTION LPAT
    (83) INFIX_FUNCTION -> . TILDE IDENTIFIER TILDE

    TILDE           shift and go to state 58

    INFIX_FUNCTION                 shift and go to state 57

state 29

    (72) LPAT -> CONSTRUCTOR_PATTERN .

    TILDE           reduce using rule 72 (LPAT -> CONSTRUCTOR_PATTERN .)
    CLOSE_PAREN     reduce using rule 72 (LPAT -> CONSTRUCTOR_PATTERN .)
    EQUALS          reduce using rule 72 (LPAT -> CONSTRUCTOR_PATTERN .)
    GIVEN           reduce using rule 72 (LPAT -> CONSTRUCTOR_PATTERN .)
    ARROW           reduce using rule 72 (LPAT -> CONSTRUCTOR_PATTERN .)


state 30

    (73) LPAT -> NEGATIVE_LITERAL .

    TILDE           reduce using rule 73 (LPAT -> NEGATIVE_LITERAL .)
    CLOSE_PAREN     reduce using rule 73 (LPAT -> NEGATIVE_LITERAL .)
    EQUALS          reduce using rule 73 (LPAT -> NEGATIVE_LITERAL .)
    GIVEN           reduce using rule 73 (LPAT -> NEGATIVE_LITERAL .)
    ARROW           reduce using rule 73 (LPAT -> NEGATIVE_LITERAL .)


state 31

    (79) APAT -> LITERAL .

    TILDE           reduce using rule 79 (APAT -> LITERAL .)
    TYPENAME        reduce using rule 79 (APAT -> LITERAL .)
    OPEN_PAREN      reduce using rule 79 (APAT -> LITERAL .)
    IDENTIFIER      reduce using rule 79 (APAT -> LITERAL .)
    FLOAT           reduce using rule 79 (APAT -> LITERAL .)
    INTEGER         reduce using rule 79 (APAT -> LITERAL .)
    BOOL            reduce using rule 79 (APAT -> LITERAL .)
    STRING          reduce using rule 79 (APAT -> LITERAL .)
    CLOSE_PAREN     reduce using rule 79 (APAT -> LITERAL .)
    EQUALS          reduce using rule 79 (APAT -> LITERAL .)
    GIVEN           reduce using rule 79 (APAT -> LITERAL .)
    ARROW           reduce using rule 79 (APAT -> LITERAL .)


state 32

    (75) NEGATIVE_LITERAL -> MINUS . INTEGER
    (76) NEGATIVE_LITERAL -> MINUS . FLOAT

    INTEGER         shift and go to state 59
    FLOAT           shift and go to state 60


state 33

    (102) LITERAL -> FLOAT .

    TILDE           reduce using rule 102 (LITERAL -> FLOAT .)
    TYPENAME        reduce using rule 102 (LITERAL -> FLOAT .)
    OPEN_PAREN      reduce using rule 102 (LITERAL -> FLOAT .)
    IDENTIFIER      reduce using rule 102 (LITERAL -> FLOAT .)
    FLOAT           reduce using rule 102 (LITERAL -> FLOAT .)
    INTEGER         reduce using rule 102 (LITERAL -> FLOAT .)
    BOOL            reduce using rule 102 (LITERAL -> FLOAT .)
    STRING          reduce using rule 102 (LITERAL -> FLOAT .)
    CLOSE_PAREN     reduce using rule 102 (LITERAL -> FLOAT .)
    EQUALS          reduce using rule 102 (LITERAL -> FLOAT .)
    GIVEN           reduce using rule 102 (LITERAL -> FLOAT .)
    ARROW           reduce using rule 102 (LITERAL -> FLOAT .)
    PLUS            reduce using rule 102 (LITERAL -> FLOAT .)
    MINUS           reduce using rule 102 (LITERAL -> FLOAT .)
    TIMES           reduce using rule 102 (LITERAL -> FLOAT .)
    DIVIDE          reduce using rule 102 (LITERAL -> FLOAT .)
    MODULO          reduce using rule 102 (LITERAL -> FLOAT .)
    FPOW            reduce using rule 102 (LITERAL -> FLOAT .)
    IPOW            reduce using rule 102 (LITERAL -> FLOAT .)
    EQUALITY        reduce using rule 102 (LITERAL -> FLOAT .)
    INEQUALITY      reduce using rule 102 (LITERAL -> FLOAT .)
    LESS            reduce using rule 102 (LITERAL -> FLOAT .)
    LEQ             reduce using rule 102 (LITERAL -> FLOAT .)
    GREATER         reduce using rule 102 (LITERAL -> FLOAT .)
    GEQ             reduce using rule 102 (LITERAL -> FLOAT .)
    CONCAT          reduce using rule 102 (LITERAL -> FLOAT .)
    AND             reduce using rule 102 (LITERAL -> FLOAT .)
    OR              reduce using rule 102 (LITERAL -> FLOAT .)
    WITH            reduce using rule 102 (LITERAL -> FLOAT .)
    IF              reduce using rule 102 (LITERAL -> FLOAT .)
    CLOSE_BRACE     reduce using rule 102 (LITERAL -> FLOAT .)
    ENDSTATEMENT    reduce using rule 102 (LITERAL -> FLOAT .)
    ON              reduce using rule 102 (LITERAL -> FLOAT .)
    ELSE            reduce using rule 102 (LITERAL -> FLOAT .)


state 34

    (104) LITERAL -> BOOL .

    TILDE           reduce using rule 104 (LITERAL -> BOOL .)
    TYPENAME        reduce using rule 104 (LITERAL -> BOOL .)
    OPEN_PAREN      reduce using rule 104 (LITERAL -> BOOL .)
    IDENTIFIER      reduce using rule 104 (LITERAL -> BOOL .)
    FLOAT           reduce using rule 104 (LITERAL -> BOOL .)
    INTEGER         reduce using rule 104 (LITERAL -> BOOL .)
    BOOL            reduce using rule 104 (LITERAL -> BOOL .)
    STRING          reduce using rule 104 (LITERAL -> BOOL .)
    CLOSE_PAREN     reduce using rule 104 (LITERAL -> BOOL .)
    EQUALS          reduce using rule 104 (LITERAL -> BOOL .)
    GIVEN           reduce using rule 104 (LITERAL -> BOOL .)
    ARROW           reduce using rule 104 (LITERAL -> BOOL .)
    PLUS            reduce using rule 104 (LITERAL -> BOOL .)
    MINUS           reduce using rule 104 (LITERAL -> BOOL .)
    TIMES           reduce using rule 104 (LITERAL -> BOOL .)
    DIVIDE          reduce using rule 104 (LITERAL -> BOOL .)
    MODULO          reduce using rule 104 (LITERAL -> BOOL .)
    FPOW            reduce using rule 104 (LITERAL -> BOOL .)
    IPOW            reduce using rule 104 (LITERAL -> BOOL .)
    EQUALITY        reduce using rule 104 (LITERAL -> BOOL .)
    INEQUALITY      reduce using rule 104 (LITERAL -> BOOL .)
    LESS            reduce using rule 104 (LITERAL -> BOOL .)
    LEQ             reduce using rule 104 (LITERAL -> BOOL .)
    GREATER         reduce using rule 104 (LITERAL -> BOOL .)
    GEQ             reduce using rule 104 (LITERAL -> BOOL .)
    CONCAT          reduce using rule 104 (LITERAL -> BOOL .)
    AND             reduce using rule 104 (LITERAL -> BOOL .)
    OR              reduce using rule 104 (LITERAL -> BOOL .)
    WITH            reduce using rule 104 (LITERAL -> BOOL .)
    IF              reduce using rule 104 (LITERAL -> BOOL .)
    CLOSE_BRACE     reduce using rule 104 (LITERAL -> BOOL .)
    ENDSTATEMENT    reduce using rule 104 (LITERAL -> BOOL .)
    ON              reduce using rule 104 (LITERAL -> BOOL .)
    ELSE            reduce using rule 104 (LITERAL -> BOOL .)


state 35

    (2) MODULE_BODY -> OPEN_BRACE IMPORT_STATEMENTS ENDSTATEMENT . TOPLEVEL_DECLARATIONS CLOSE_BRACE
    (4) IMPORT_STATEMENTS -> IMPORT_STATEMENTS ENDSTATEMENT . IMPORT_STATEMENT
    (7) TOPLEVEL_DECLARATIONS -> . TOPLEVEL_DECLARATIONS ENDSTATEMENT TOP_DECLARATION
    (8) TOPLEVEL_DECLARATIONS -> . TOP_DECLARATION
    (6) IMPORT_STATEMENT -> . IMPORT STRING
    (9) TOP_DECLARATION -> . ADT_DECLARATION
    (10) TOP_DECLARATION -> . DECLARATION
    (11) ADT_DECLARATION -> . NEWTYPE TYPENAME EQUALS CONSTRUCTORS
    (19) DECLARATION -> . FUNCTION_DEFINITION
    (20) DECLARATION -> . VARIABLE_DEFINITION
    (21) DECLARATION -> . FIXITY_DECLARATION
    (22) DECLARATION -> .
    (23) FUNCTION_DEFINITION -> . FUNCTION_LHS RHS
    (24) VARIABLE_DEFINITION -> . PARAM RHS
    (25) FIXITY_DECLARATION -> . SETFIX ASSOCIATIVITY INTEGER OP
    (36) FUNCTION_LHS -> . IDENTIFIER APAT APATS
    (37) FUNCTION_LHS -> . OPEN_PAREN FUNCTION_LHS CLOSE_PAREN APAT APATS
    (38) FUNCTION_LHS -> . INFIX_FUNCTION_DEFINITION
    (108) PARAM -> . IDENTIFIER
    (39) INFIX_FUNCTION_DEFINITION -> . LPAT INFIX_FUNCTION LPAT
    (71) LPAT -> . APAT
    (72) LPAT -> . CONSTRUCTOR_PATTERN
    (73) LPAT -> . NEGATIVE_LITERAL
    (77) APAT -> . PARAM
    (78) APAT -> . TYPENAME
    (79) APAT -> . LITERAL
    (80) APAT -> . OPEN_PAREN LPAT CLOSE_PAREN
    (74) CONSTRUCTOR_PATTERN -> . TYPENAME APAT APATS
    (75) NEGATIVE_LITERAL -> . MINUS INTEGER
    (76) NEGATIVE_LITERAL -> . MINUS FLOAT
    (102) LITERAL -> . FLOAT
    (103) LITERAL -> . INTEGER
    (104) LITERAL -> . BOOL
    (105) LITERAL -> . STRING

    IMPORT          shift and go to state 11
    NEWTYPE         shift and go to state 15
    CLOSE_BRACE     reduce using rule 22 (DECLARATION -> .)
    ENDSTATEMENT    reduce using rule 22 (DECLARATION -> .)
    SETFIX          shift and go to state 22
    IDENTIFIER      shift and go to state 24
    OPEN_PAREN      shift and go to state 26
    TYPENAME        shift and go to state 16
    MINUS           shift and go to state 32
    FLOAT           shift and go to state 33
    INTEGER         shift and go to state 23
    BOOL            shift and go to state 34
    STRING          shift and go to state 12

    TOPLEVEL_DECLARATIONS          shift and go to state 61
    IMPORT_STATEMENT               shift and go to state 62
    TOP_DECLARATION                shift and go to state 10
    ADT_DECLARATION                shift and go to state 13
    DECLARATION                    shift and go to state 14
    FUNCTION_DEFINITION            shift and go to state 17
    VARIABLE_DEFINITION            shift and go to state 18
    FIXITY_DECLARATION             shift and go to state 19
    FUNCTION_LHS                   shift and go to state 20
    PARAM                          shift and go to state 21
    APAT                           shift and go to state 25
    INFIX_FUNCTION_DEFINITION      shift and go to state 27
    LPAT                           shift and go to state 28
    CONSTRUCTOR_PATTERN            shift and go to state 29
    NEGATIVE_LITERAL               shift and go to state 30
    LITERAL                        shift and go to state 31

state 36

    (3) MODULE_BODY -> OPEN_BRACE TOPLEVEL_DECLARATIONS CLOSE_BRACE .

    $end            reduce using rule 3 (MODULE_BODY -> OPEN_BRACE TOPLEVEL_DECLARATIONS CLOSE_BRACE .)


state 37

    (7) TOPLEVEL_DECLARATIONS -> TOPLEVEL_DECLARATIONS ENDSTATEMENT . TOP_DECLARATION
    (9) TOP_DECLARATION -> . ADT_DECLARATION
    (10) TOP_DECLARATION -> . DECLARATION
    (11) ADT_DECLARATION -> . NEWTYPE TYPENAME EQUALS CONSTRUCTORS
    (19) DECLARATION -> . FUNCTION_DEFINITION
    (20) DECLARATION -> . VARIABLE_DEFINITION
    (21) DECLARATION -> . FIXITY_DECLARATION
    (22) DECLARATION -> .
    (23) FUNCTION_DEFINITION -> . FUNCTION_LHS RHS
    (24) VARIABLE_DEFINITION -> . PARAM RHS
    (25) FIXITY_DECLARATION -> . SETFIX ASSOCIATIVITY INTEGER OP
    (36) FUNCTION_LHS -> . IDENTIFIER APAT APATS
    (37) FUNCTION_LHS -> . OPEN_PAREN FUNCTION_LHS CLOSE_PAREN APAT APATS
    (38) FUNCTION_LHS -> . INFIX_FUNCTION_DEFINITION
    (108) PARAM -> . IDENTIFIER
    (39) INFIX_FUNCTION_DEFINITION -> . LPAT INFIX_FUNCTION LPAT
    (71) LPAT -> . APAT
    (72) LPAT -> . CONSTRUCTOR_PATTERN
    (73) LPAT -> . NEGATIVE_LITERAL
    (77) APAT -> . PARAM
    (78) APAT -> . TYPENAME
    (79) APAT -> . LITERAL
    (80) APAT -> . OPEN_PAREN LPAT CLOSE_PAREN
    (74) CONSTRUCTOR_PATTERN -> . TYPENAME APAT APATS
    (75) NEGATIVE_LITERAL -> . MINUS INTEGER
    (76) NEGATIVE_LITERAL -> . MINUS FLOAT
    (102) LITERAL -> . FLOAT
    (103) LITERAL -> . INTEGER
    (104) LITERAL -> . BOOL
    (105) LITERAL -> . STRING

    NEWTYPE         shift and go to state 15
    CLOSE_BRACE     reduce using rule 22 (DECLARATION -> .)
    ENDSTATEMENT    reduce using rule 22 (DECLARATION -> .)
    SETFIX          shift and go to state 22
    IDENTIFIER      shift and go to state 24
    OPEN_PAREN      shift and go to state 26
    TYPENAME        shift and go to state 16
    MINUS           shift and go to state 32
    FLOAT           shift and go to state 33
    INTEGER         shift and go to state 23
    BOOL            shift and go to state 34
    STRING          shift and go to state 12

    TOP_DECLARATION                shift and go to state 63
    ADT_DECLARATION                shift and go to state 13
    DECLARATION                    shift and go to state 14
    FUNCTION_DEFINITION            shift and go to state 17
    VARIABLE_DEFINITION            shift and go to state 18
    FIXITY_DECLARATION             shift and go to state 19
    FUNCTION_LHS                   shift and go to state 20
    PARAM                          shift and go to state 21
    APAT                           shift and go to state 25
    INFIX_FUNCTION_DEFINITION      shift and go to state 27
    LPAT                           shift and go to state 28
    CONSTRUCTOR_PATTERN            shift and go to state 29
    NEGATIVE_LITERAL               shift and go to state 30
    LITERAL                        shift and go to state 31

state 38

    (6) IMPORT_STATEMENT -> IMPORT STRING .

    ENDSTATEMENT    reduce using rule 6 (IMPORT_STATEMENT -> IMPORT STRING .)


state 39

    (11) ADT_DECLARATION -> NEWTYPE TYPENAME . EQUALS CONSTRUCTORS

    EQUALS          shift and go to state 64


state 40

    (78) APAT -> TYPENAME .

    TYPENAME        reduce using rule 78 (APAT -> TYPENAME .)
    OPEN_PAREN      reduce using rule 78 (APAT -> TYPENAME .)
    IDENTIFIER      reduce using rule 78 (APAT -> TYPENAME .)
    FLOAT           reduce using rule 78 (APAT -> TYPENAME .)
    INTEGER         reduce using rule 78 (APAT -> TYPENAME .)
    BOOL            reduce using rule 78 (APAT -> TYPENAME .)
    STRING          reduce using rule 78 (APAT -> TYPENAME .)
    TILDE           reduce using rule 78 (APAT -> TYPENAME .)
    CLOSE_PAREN     reduce using rule 78 (APAT -> TYPENAME .)
    EQUALS          reduce using rule 78 (APAT -> TYPENAME .)
    GIVEN           reduce using rule 78 (APAT -> TYPENAME .)
    ARROW           reduce using rule 78 (APAT -> TYPENAME .)


state 41

    (74) CONSTRUCTOR_PATTERN -> TYPENAME APAT . APATS
    (84) APATS -> . APAT APATS
    (85) APATS -> .
    (77) APAT -> . PARAM
    (78) APAT -> . TYPENAME
    (79) APAT -> . LITERAL
    (80) APAT -> . OPEN_PAREN LPAT CLOSE_PAREN
    (108) PARAM -> . IDENTIFIER
    (102) LITERAL -> . FLOAT
    (103) LITERAL -> . INTEGER
    (104) LITERAL -> . BOOL
    (105) LITERAL -> . STRING

    TILDE           reduce using rule 85 (APATS -> .)
    CLOSE_PAREN     reduce using rule 85 (APATS -> .)
    EQUALS          reduce using rule 85 (APATS -> .)
    GIVEN           reduce using rule 85 (APATS -> .)
    ARROW           reduce using rule 85 (APATS -> .)
    TYPENAME        shift and go to state 40
    OPEN_PAREN      shift and go to state 43
    IDENTIFIER      shift and go to state 44
    FLOAT           shift and go to state 33
    INTEGER         shift and go to state 23
    BOOL            shift and go to state 34
    STRING          shift and go to state 12

    APAT                           shift and go to state 65
    APATS                          shift and go to state 66
    PARAM                          shift and go to state 42
    LITERAL                        shift and go to state 31

state 42

    (77) APAT -> PARAM .

    TYPENAME        reduce using rule 77 (APAT -> PARAM .)
    OPEN_PAREN      reduce using rule 77 (APAT -> PARAM .)
    IDENTIFIER      reduce using rule 77 (APAT -> PARAM .)
    FLOAT           reduce using rule 77 (APAT -> PARAM .)
    INTEGER         reduce using rule 77 (APAT -> PARAM .)
    BOOL            reduce using rule 77 (APAT -> PARAM .)
    STRING          reduce using rule 77 (APAT -> PARAM .)
    TILDE           reduce using rule 77 (APAT -> PARAM .)
    CLOSE_PAREN     reduce using rule 77 (APAT -> PARAM .)
    EQUALS          reduce using rule 77 (APAT -> PARAM .)
    GIVEN           reduce using rule 77 (APAT -> PARAM .)
    ARROW           reduce using rule 77 (APAT -> PARAM .)


state 43

    (80) APAT -> OPEN_PAREN . LPAT CLOSE_PAREN
    (71) LPAT -> . APAT
    (72) LPAT -> . CONSTRUCTOR_PATTERN
    (73) LPAT -> . NEGATIVE_LITERAL
    (77) APAT -> . PARAM
    (78) APAT -> . TYPENAME
    (79) APAT -> . LITERAL
    (80) APAT -> . OPEN_PAREN LPAT CLOSE_PAREN
    (74) CONSTRUCTOR_PATTERN -> . TYPENAME APAT APATS
    (75) NEGATIVE_LITERAL -> . MINUS INTEGER
    (76) NEGATIVE_LITERAL -> . MINUS FLOAT
    (108) PARAM -> . IDENTIFIER
    (102) LITERAL -> . FLOAT
    (103) LITERAL -> . INTEGER
    (104) LITERAL -> . BOOL
    (105) LITERAL -> . STRING

    TYPENAME        shift and go to state 16
    OPEN_PAREN      shift and go to state 43
    MINUS           shift and go to state 32
    IDENTIFIER      shift and go to state 44
    FLOAT           shift and go to state 33
    INTEGER         shift and go to state 23
    BOOL            shift and go to state 34
    STRING          shift and go to state 12

    LPAT                           shift and go to state 67
    APAT                           shift and go to state 25
    CONSTRUCTOR_PATTERN            shift and go to state 29
    NEGATIVE_LITERAL               shift and go to state 30
    PARAM                          shift and go to state 42
    LITERAL                        shift and go to state 31

state 44

    (108) PARAM -> IDENTIFIER .

    TYPENAME        reduce using rule 108 (PARAM -> IDENTIFIER .)
    OPEN_PAREN      reduce using rule 108 (PARAM -> IDENTIFIER .)
    IDENTIFIER      reduce using rule 108 (PARAM -> IDENTIFIER .)
    FLOAT           reduce using rule 108 (PARAM -> IDENTIFIER .)
    INTEGER         reduce using rule 108 (PARAM -> IDENTIFIER .)
    BOOL            reduce using rule 108 (PARAM -> IDENTIFIER .)
    STRING          reduce using rule 108 (PARAM -> IDENTIFIER .)
    TILDE           reduce using rule 108 (PARAM -> IDENTIFIER .)
    CLOSE_PAREN     reduce using rule 108 (PARAM -> IDENTIFIER .)
    EQUALS          reduce using rule 108 (PARAM -> IDENTIFIER .)
    GIVEN           reduce using rule 108 (PARAM -> IDENTIFIER .)
    ARROW           reduce using rule 108 (PARAM -> IDENTIFIER .)


state 45

    (23) FUNCTION_DEFINITION -> FUNCTION_LHS RHS .

    CLOSE_BRACE     reduce using rule 23 (FUNCTION_DEFINITION -> FUNCTION_LHS RHS .)
    ENDSTATEMENT    reduce using rule 23 (FUNCTION_DEFINITION -> FUNCTION_LHS RHS .)


state 46

    (40) RHS -> EQUALS . EXP
    (41) RHS -> EQUALS . EXP WITH DECLARATIONS
    (46) EXP -> . INFIX_EXP
    (47) INFIX_EXP -> . LEXP OP INFIX_EXP
    (48) INFIX_EXP -> . MINUS INFIX_EXP
    (49) INFIX_EXP -> . LEXP
    (50) LEXP -> . LAMBDA_ABSTRACTION
    (51) LEXP -> . LET_EXPR
    (52) LEXP -> . IF_EXPR
    (53) LEXP -> . MATCH_EXPR
    (54) LEXP -> . FUNCTION_EXPR
    (55) LAMBDA_ABSTRACTION -> . LAMBDA APAT APATS ARROW EXP
    (56) LET_EXPR -> . LET DECLARATIONS IN EXP
    (57) IF_EXPR -> . EXP IF EXP ELSE EXP
    (58) MATCH_EXPR -> . MATCH EXP ON OPEN_BRACE ALTS CLOSE_BRACE
    (59) FUNCTION_EXPR -> . FUNCTION_EXPR AEXP
    (60) FUNCTION_EXPR -> . AEXP
    (61) AEXP -> . USED_VAR
    (62) AEXP -> . USED_TYPENAME
    (63) AEXP -> . LITERAL
    (64) AEXP -> . OPERATOR_FUNC
    (65) AEXP -> . OPEN_PAREN EXP CLOSE_PAREN
    (106) USED_VAR -> . IDENTIFIER
    (107) USED_TYPENAME -> . TYPENAME
    (102) LITERAL -> . FLOAT
    (103) LITERAL -> . INTEGER
    (104) LITERAL -> . BOOL
    (105) LITERAL -> . STRING
    (66) OPERATOR_FUNC -> . OPEN_PAREN OP CLOSE_PAREN

    MINUS           shift and go to state 71
    LAMBDA          shift and go to state 77
    LET             shift and go to state 78
    MATCH           shift and go to state 79
    OPEN_PAREN      shift and go to state 85
    IDENTIFIER      shift and go to state 86
    TYPENAME        shift and go to state 87
    FLOAT           shift and go to state 33
    INTEGER         shift and go to state 23
    BOOL            shift and go to state 34
    STRING          shift and go to state 12

    EXP                            shift and go to state 68
    INFIX_EXP                      shift and go to state 69
    LEXP                           shift and go to state 70
    LAMBDA_ABSTRACTION             shift and go to state 72
    LET_EXPR                       shift and go to state 73
    IF_EXPR                        shift and go to state 74
    MATCH_EXPR                     shift and go to state 75
    FUNCTION_EXPR                  shift and go to state 76
    AEXP                           shift and go to state 80
    USED_VAR                       shift and go to state 81
    USED_TYPENAME                  shift and go to state 82
    LITERAL                        shift and go to state 83
    OPERATOR_FUNC                  shift and go to state 84

state 47

    (42) RHS -> GDRHS .
    (43) RHS -> GDRHS . WITH DECLARATIONS

    CLOSE_BRACE     reduce using rule 42 (RHS -> GDRHS .)
    ENDSTATEMENT    reduce using rule 42 (RHS -> GDRHS .)
    WITH            shift and go to state 88


state 48

    (44) GDRHS -> GIVEN . EXP EQUALS EXP
    (45) GDRHS -> GIVEN . EXP EQUALS EXP GDRHS
    (46) EXP -> . INFIX_EXP
    (47) INFIX_EXP -> . LEXP OP INFIX_EXP
    (48) INFIX_EXP -> . MINUS INFIX_EXP
    (49) INFIX_EXP -> . LEXP
    (50) LEXP -> . LAMBDA_ABSTRACTION
    (51) LEXP -> . LET_EXPR
    (52) LEXP -> . IF_EXPR
    (53) LEXP -> . MATCH_EXPR
    (54) LEXP -> . FUNCTION_EXPR
    (55) LAMBDA_ABSTRACTION -> . LAMBDA APAT APATS ARROW EXP
    (56) LET_EXPR -> . LET DECLARATIONS IN EXP
    (57) IF_EXPR -> . EXP IF EXP ELSE EXP
    (58) MATCH_EXPR -> . MATCH EXP ON OPEN_BRACE ALTS CLOSE_BRACE
    (59) FUNCTION_EXPR -> . FUNCTION_EXPR AEXP
    (60) FUNCTION_EXPR -> . AEXP
    (61) AEXP -> . USED_VAR
    (62) AEXP -> . USED_TYPENAME
    (63) AEXP -> . LITERAL
    (64) AEXP -> . OPERATOR_FUNC
    (65) AEXP -> . OPEN_PAREN EXP CLOSE_PAREN
    (106) USED_VAR -> . IDENTIFIER
    (107) USED_TYPENAME -> . TYPENAME
    (102) LITERAL -> . FLOAT
    (103) LITERAL -> . INTEGER
    (104) LITERAL -> . BOOL
    (105) LITERAL -> . STRING
    (66) OPERATOR_FUNC -> . OPEN_PAREN OP CLOSE_PAREN

    MINUS           shift and go to state 71
    LAMBDA          shift and go to state 77
    LET             shift and go to state 78
    MATCH           shift and go to state 79
    OPEN_PAREN      shift and go to state 85
    IDENTIFIER      shift and go to state 86
    TYPENAME        shift and go to state 87
    FLOAT           shift and go to state 33
    INTEGER         shift and go to state 23
    BOOL            shift and go to state 34
    STRING          shift and go to state 12

    EXP                            shift and go to state 89
    INFIX_EXP                      shift and go to state 69
    LEXP                           shift and go to state 70
    LAMBDA_ABSTRACTION             shift and go to state 72
    LET_EXPR                       shift and go to state 73
    IF_EXPR                        shift and go to state 74
    MATCH_EXPR                     shift and go to state 75
    FUNCTION_EXPR                  shift and go to state 76
    AEXP                           shift and go to state 80
    USED_VAR                       shift and go to state 81
    USED_TYPENAME                  shift and go to state 82
    LITERAL                        shift and go to state 83
    OPERATOR_FUNC                  shift and go to state 84

state 49

    (24) VARIABLE_DEFINITION -> PARAM RHS .

    CLOSE_BRACE     reduce using rule 24 (VARIABLE_DEFINITION -> PARAM RHS .)
    ENDSTATEMENT    reduce using rule 24 (VARIABLE_DEFINITION -> PARAM RHS .)


state 50

    (25) FIXITY_DECLARATION -> SETFIX ASSOCIATIVITY . INTEGER OP

    INTEGER         shift and go to state 90


state 51

    (26) ASSOCIATIVITY -> LEFTASSOC .

    INTEGER         reduce using rule 26 (ASSOCIATIVITY -> LEFTASSOC .)


state 52

    (27) ASSOCIATIVITY -> RIGHTASSOC .

    INTEGER         reduce using rule 27 (ASSOCIATIVITY -> RIGHTASSOC .)


state 53

    (28) ASSOCIATIVITY -> NONASSOC .

    INTEGER         reduce using rule 28 (ASSOCIATIVITY -> NONASSOC .)


state 54

    (36) FUNCTION_LHS -> IDENTIFIER APAT . APATS
    (84) APATS -> . APAT APATS
    (85) APATS -> .
    (77) APAT -> . PARAM
    (78) APAT -> . TYPENAME
    (79) APAT -> . LITERAL
    (80) APAT -> . OPEN_PAREN LPAT CLOSE_PAREN
    (108) PARAM -> . IDENTIFIER
    (102) LITERAL -> . FLOAT
    (103) LITERAL -> . INTEGER
    (104) LITERAL -> . BOOL
    (105) LITERAL -> . STRING

    EQUALS          reduce using rule 85 (APATS -> .)
    GIVEN           reduce using rule 85 (APATS -> .)
    CLOSE_PAREN     reduce using rule 85 (APATS -> .)
    TYPENAME        shift and go to state 40
    OPEN_PAREN      shift and go to state 43
    IDENTIFIER      shift and go to state 44
    FLOAT           shift and go to state 33
    INTEGER         shift and go to state 23
    BOOL            shift and go to state 34
    STRING          shift and go to state 12

    APAT                           shift and go to state 65
    APATS                          shift and go to state 91
    PARAM                          shift and go to state 42
    LITERAL                        shift and go to state 31

state 55

    (37) FUNCTION_LHS -> OPEN_PAREN FUNCTION_LHS . CLOSE_PAREN APAT APATS

    CLOSE_PAREN     shift and go to state 92


state 56

    (80) APAT -> OPEN_PAREN LPAT . CLOSE_PAREN
    (39) INFIX_FUNCTION_DEFINITION -> LPAT . INFIX_FUNCTION LPAT
    (83) INFIX_FUNCTION -> . TILDE IDENTIFIER TILDE

    CLOSE_PAREN     shift and go to state 93
    TILDE           shift and go to state 58

    INFIX_FUNCTION                 shift and go to state 57

state 57

    (39) INFIX_FUNCTION_DEFINITION -> LPAT INFIX_FUNCTION . LPAT
    (71) LPAT -> . APAT
    (72) LPAT -> . CONSTRUCTOR_PATTERN
    (73) LPAT -> . NEGATIVE_LITERAL
    (77) APAT -> . PARAM
    (78) APAT -> . TYPENAME
    (79) APAT -> . LITERAL
    (80) APAT -> . OPEN_PAREN LPAT CLOSE_PAREN
    (74) CONSTRUCTOR_PATTERN -> . TYPENAME APAT APATS
    (75) NEGATIVE_LITERAL -> . MINUS INTEGER
    (76) NEGATIVE_LITERAL -> . MINUS FLOAT
    (108) PARAM -> . IDENTIFIER
    (102) LITERAL -> . FLOAT
    (103) LITERAL -> . INTEGER
    (104) LITERAL -> . BOOL
    (105) LITERAL -> . STRING

    TYPENAME        shift and go to state 16
    OPEN_PAREN      shift and go to state 43
    MINUS           shift and go to state 32
    IDENTIFIER      shift and go to state 44
    FLOAT           shift and go to state 33
    INTEGER         shift and go to state 23
    BOOL            shift and go to state 34
    STRING          shift and go to state 12

    LPAT                           shift and go to state 94
    APAT                           shift and go to state 25
    CONSTRUCTOR_PATTERN            shift and go to state 29
    NEGATIVE_LITERAL               shift and go to state 30
    PARAM                          shift and go to state 42
    LITERAL                        shift and go to state 31

state 58

    (83) INFIX_FUNCTION -> TILDE . IDENTIFIER TILDE

    IDENTIFIER      shift and go to state 95


state 59

    (75) NEGATIVE_LITERAL -> MINUS INTEGER .

    TILDE           reduce using rule 75 (NEGATIVE_LITERAL -> MINUS INTEGER .)
    CLOSE_PAREN     reduce using rule 75 (NEGATIVE_LITERAL -> MINUS INTEGER .)
    EQUALS          reduce using rule 75 (NEGATIVE_LITERAL -> MINUS INTEGER .)
    GIVEN           reduce using rule 75 (NEGATIVE_LITERAL -> MINUS INTEGER .)
    ARROW           reduce using rule 75 (NEGATIVE_LITERAL -> MINUS INTEGER .)


state 60

    (76) NEGATIVE_LITERAL -> MINUS FLOAT .

    TILDE           reduce using rule 76 (NEGATIVE_LITERAL -> MINUS FLOAT .)
    CLOSE_PAREN     reduce using rule 76 (NEGATIVE_LITERAL -> MINUS FLOAT .)
    EQUALS          reduce using rule 76 (NEGATIVE_LITERAL -> MINUS FLOAT .)
    GIVEN           reduce using rule 76 (NEGATIVE_LITERAL -> MINUS FLOAT .)
    ARROW           reduce using rule 76 (NEGATIVE_LITERAL -> MINUS FLOAT .)


state 61

    (2) MODULE_BODY -> OPEN_BRACE IMPORT_STATEMENTS ENDSTATEMENT TOPLEVEL_DECLARATIONS . CLOSE_BRACE
    (7) TOPLEVEL_DECLARATIONS -> TOPLEVEL_DECLARATIONS . ENDSTATEMENT TOP_DECLARATION

    CLOSE_BRACE     shift and go to state 96
    ENDSTATEMENT    shift and go to state 37


state 62

    (4) IMPORT_STATEMENTS -> IMPORT_STATEMENTS ENDSTATEMENT IMPORT_STATEMENT .

    ENDSTATEMENT    reduce using rule 4 (IMPORT_STATEMENTS -> IMPORT_STATEMENTS ENDSTATEMENT IMPORT_STATEMENT .)


state 63

    (7) TOPLEVEL_DECLARATIONS -> TOPLEVEL_DECLARATIONS ENDSTATEMENT TOP_DECLARATION .

    CLOSE_BRACE     reduce using rule 7 (TOPLEVEL_DECLARATIONS -> TOPLEVEL_DECLARATIONS ENDSTATEMENT TOP_DECLARATION .)
    ENDSTATEMENT    reduce using rule 7 (TOPLEVEL_DECLARATIONS -> TOPLEVEL_DECLARATIONS ENDSTATEMENT TOP_DECLARATION .)


state 64

    (11) ADT_DECLARATION -> NEWTYPE TYPENAME EQUALS . CONSTRUCTORS
    (12) CONSTRUCTORS -> . CONSTRUCTORS PIPE CONSTRUCTOR
    (13) CONSTRUCTORS -> . CONSTRUCTOR
    (14) CONSTRUCTOR -> . TYPENAME ATYPES

    TYPENAME        shift and go to state 97

    CONSTRUCTORS                   shift and go to state 98
    CONSTRUCTOR                    shift and go to state 99

state 65

    (84) APATS -> APAT . APATS
    (84) APATS -> . APAT APATS
    (85) APATS -> .
    (77) APAT -> . PARAM
    (78) APAT -> . TYPENAME
    (79) APAT -> . LITERAL
    (80) APAT -> . OPEN_PAREN LPAT CLOSE_PAREN
    (108) PARAM -> . IDENTIFIER
    (102) LITERAL -> . FLOAT
    (103) LITERAL -> . INTEGER
    (104) LITERAL -> . BOOL
    (105) LITERAL -> . STRING

    TILDE           reduce using rule 85 (APATS -> .)
    CLOSE_PAREN     reduce using rule 85 (APATS -> .)
    EQUALS          reduce using rule 85 (APATS -> .)
    GIVEN           reduce using rule 85 (APATS -> .)
    ARROW           reduce using rule 85 (APATS -> .)
    TYPENAME        shift and go to state 40
    OPEN_PAREN      shift and go to state 43
    IDENTIFIER      shift and go to state 44
    FLOAT           shift and go to state 33
    INTEGER         shift and go to state 23
    BOOL            shift and go to state 34
    STRING          shift and go to state 12

    APAT                           shift and go to state 65
    APATS                          shift and go to state 100
    PARAM                          shift and go to state 42
    LITERAL                        shift and go to state 31

state 66

    (74) CONSTRUCTOR_PATTERN -> TYPENAME APAT APATS .

    TILDE           reduce using rule 74 (CONSTRUCTOR_PATTERN -> TYPENAME APAT APATS .)
    CLOSE_PAREN     reduce using rule 74 (CONSTRUCTOR_PATTERN -> TYPENAME APAT APATS .)
    EQUALS          reduce using rule 74 (CONSTRUCTOR_PATTERN -> TYPENAME APAT APATS .)
    GIVEN           reduce using rule 74 (CONSTRUCTOR_PATTERN -> TYPENAME APAT APATS .)
    ARROW           reduce using rule 74 (CONSTRUCTOR_PATTERN -> TYPENAME APAT APATS .)


state 67

    (80) APAT -> OPEN_PAREN LPAT . CLOSE_PAREN

    CLOSE_PAREN     shift and go to state 93


state 68

    (40) RHS -> EQUALS EXP .
    (41) RHS -> EQUALS EXP . WITH DECLARATIONS
    (57) IF_EXPR -> EXP . IF EXP ELSE EXP

    CLOSE_BRACE     reduce using rule 40 (RHS -> EQUALS EXP .)
    ENDSTATEMENT    reduce using rule 40 (RHS -> EQUALS EXP .)
    WITH            shift and go to state 101
    IF              shift and go to state 102


state 69

    (46) EXP -> INFIX_EXP .

    WITH            reduce using rule 46 (EXP -> INFIX_EXP .)
    IF              reduce using rule 46 (EXP -> INFIX_EXP .)
    CLOSE_BRACE     reduce using rule 46 (EXP -> INFIX_EXP .)
    ENDSTATEMENT    reduce using rule 46 (EXP -> INFIX_EXP .)
    EQUALS          reduce using rule 46 (EXP -> INFIX_EXP .)
    ON              reduce using rule 46 (EXP -> INFIX_EXP .)
    CLOSE_PAREN     reduce using rule 46 (EXP -> INFIX_EXP .)
    ELSE            reduce using rule 46 (EXP -> INFIX_EXP .)
    GIVEN           reduce using rule 46 (EXP -> INFIX_EXP .)
    PLUS            reduce using rule 46 (EXP -> INFIX_EXP .)
    MINUS           reduce using rule 46 (EXP -> INFIX_EXP .)
    TIMES           reduce using rule 46 (EXP -> INFIX_EXP .)
    DIVIDE          reduce using rule 46 (EXP -> INFIX_EXP .)
    MODULO          reduce using rule 46 (EXP -> INFIX_EXP .)
    FPOW            reduce using rule 46 (EXP -> INFIX_EXP .)
    IPOW            reduce using rule 46 (EXP -> INFIX_EXP .)
    EQUALITY        reduce using rule 46 (EXP -> INFIX_EXP .)
    INEQUALITY      reduce using rule 46 (EXP -> INFIX_EXP .)
    LESS            reduce using rule 46 (EXP -> INFIX_EXP .)
    LEQ             reduce using rule 46 (EXP -> INFIX_EXP .)
    GREATER         reduce using rule 46 (EXP -> INFIX_EXP .)
    GEQ             reduce using rule 46 (EXP -> INFIX_EXP .)
    CONCAT          reduce using rule 46 (EXP -> INFIX_EXP .)
    AND             reduce using rule 46 (EXP -> INFIX_EXP .)
    OR              reduce using rule 46 (EXP -> INFIX_EXP .)
    TILDE           reduce using rule 46 (EXP -> INFIX_EXP .)


state 70

    (47) INFIX_EXP -> LEXP . OP INFIX_EXP
    (49) INFIX_EXP -> LEXP .
    (81) OP -> . VARSYM
    (82) OP -> . INFIX_FUNCTION
    (86) VARSYM -> . PLUS
    (87) VARSYM -> . MINUS
    (88) VARSYM -> . TIMES
    (89) VARSYM -> . DIVIDE
    (90) VARSYM -> . MODULO
    (91) VARSYM -> . FPOW
    (92) VARSYM -> . IPOW
    (93) VARSYM -> . EQUALITY
    (94) VARSYM -> . INEQUALITY
    (95) VARSYM -> . LESS
    (96) VARSYM -> . LEQ
    (97) VARSYM -> . GREATER
    (98) VARSYM -> . GEQ
    (99) VARSYM -> . CONCAT
    (100) VARSYM -> . AND
    (101) VARSYM -> . OR
    (83) INFIX_FUNCTION -> . TILDE IDENTIFIER TILDE

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MODULO resolved as shift
  ! shift/reduce conflict for FPOW resolved as shift
  ! shift/reduce conflict for IPOW resolved as shift
  ! shift/reduce conflict for EQUALITY resolved as shift
  ! shift/reduce conflict for INEQUALITY resolved as shift
  ! shift/reduce conflict for LESS resolved as shift
  ! shift/reduce conflict for LEQ resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for GEQ resolved as shift
  ! shift/reduce conflict for CONCAT resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for TILDE resolved as shift
    WITH            reduce using rule 49 (INFIX_EXP -> LEXP .)
    IF              reduce using rule 49 (INFIX_EXP -> LEXP .)
    CLOSE_BRACE     reduce using rule 49 (INFIX_EXP -> LEXP .)
    ENDSTATEMENT    reduce using rule 49 (INFIX_EXP -> LEXP .)
    EQUALS          reduce using rule 49 (INFIX_EXP -> LEXP .)
    ON              reduce using rule 49 (INFIX_EXP -> LEXP .)
    ELSE            reduce using rule 49 (INFIX_EXP -> LEXP .)
    CLOSE_PAREN     reduce using rule 49 (INFIX_EXP -> LEXP .)
    GIVEN           reduce using rule 49 (INFIX_EXP -> LEXP .)
    PLUS            shift and go to state 106
    MINUS           shift and go to state 107
    TIMES           shift and go to state 108
    DIVIDE          shift and go to state 109
    MODULO          shift and go to state 110
    FPOW            shift and go to state 111
    IPOW            shift and go to state 112
    EQUALITY        shift and go to state 113
    INEQUALITY      shift and go to state 114
    LESS            shift and go to state 115
    LEQ             shift and go to state 116
    GREATER         shift and go to state 117
    GEQ             shift and go to state 118
    CONCAT          shift and go to state 119
    AND             shift and go to state 120
    OR              shift and go to state 121
    TILDE           shift and go to state 58

  ! PLUS            [ reduce using rule 49 (INFIX_EXP -> LEXP .) ]
  ! MINUS           [ reduce using rule 49 (INFIX_EXP -> LEXP .) ]
  ! TIMES           [ reduce using rule 49 (INFIX_EXP -> LEXP .) ]
  ! DIVIDE          [ reduce using rule 49 (INFIX_EXP -> LEXP .) ]
  ! MODULO          [ reduce using rule 49 (INFIX_EXP -> LEXP .) ]
  ! FPOW            [ reduce using rule 49 (INFIX_EXP -> LEXP .) ]
  ! IPOW            [ reduce using rule 49 (INFIX_EXP -> LEXP .) ]
  ! EQUALITY        [ reduce using rule 49 (INFIX_EXP -> LEXP .) ]
  ! INEQUALITY      [ reduce using rule 49 (INFIX_EXP -> LEXP .) ]
  ! LESS            [ reduce using rule 49 (INFIX_EXP -> LEXP .) ]
  ! LEQ             [ reduce using rule 49 (INFIX_EXP -> LEXP .) ]
  ! GREATER         [ reduce using rule 49 (INFIX_EXP -> LEXP .) ]
  ! GEQ             [ reduce using rule 49 (INFIX_EXP -> LEXP .) ]
  ! CONCAT          [ reduce using rule 49 (INFIX_EXP -> LEXP .) ]
  ! AND             [ reduce using rule 49 (INFIX_EXP -> LEXP .) ]
  ! OR              [ reduce using rule 49 (INFIX_EXP -> LEXP .) ]
  ! TILDE           [ reduce using rule 49 (INFIX_EXP -> LEXP .) ]

    OP                             shift and go to state 103
    VARSYM                         shift and go to state 104
    INFIX_FUNCTION                 shift and go to state 105

state 71

    (48) INFIX_EXP -> MINUS . INFIX_EXP
    (47) INFIX_EXP -> . LEXP OP INFIX_EXP
    (48) INFIX_EXP -> . MINUS INFIX_EXP
    (49) INFIX_EXP -> . LEXP
    (50) LEXP -> . LAMBDA_ABSTRACTION
    (51) LEXP -> . LET_EXPR
    (52) LEXP -> . IF_EXPR
    (53) LEXP -> . MATCH_EXPR
    (54) LEXP -> . FUNCTION_EXPR
    (55) LAMBDA_ABSTRACTION -> . LAMBDA APAT APATS ARROW EXP
    (56) LET_EXPR -> . LET DECLARATIONS IN EXP
    (57) IF_EXPR -> . EXP IF EXP ELSE EXP
    (58) MATCH_EXPR -> . MATCH EXP ON OPEN_BRACE ALTS CLOSE_BRACE
    (59) FUNCTION_EXPR -> . FUNCTION_EXPR AEXP
    (60) FUNCTION_EXPR -> . AEXP
    (46) EXP -> . INFIX_EXP
    (61) AEXP -> . USED_VAR
    (62) AEXP -> . USED_TYPENAME
    (63) AEXP -> . LITERAL
    (64) AEXP -> . OPERATOR_FUNC
    (65) AEXP -> . OPEN_PAREN EXP CLOSE_PAREN
    (106) USED_VAR -> . IDENTIFIER
    (107) USED_TYPENAME -> . TYPENAME
    (102) LITERAL -> . FLOAT
    (103) LITERAL -> . INTEGER
    (104) LITERAL -> . BOOL
    (105) LITERAL -> . STRING
    (66) OPERATOR_FUNC -> . OPEN_PAREN OP CLOSE_PAREN

    MINUS           shift and go to state 71
    LAMBDA          shift and go to state 77
    LET             shift and go to state 78
    MATCH           shift and go to state 79
    OPEN_PAREN      shift and go to state 85
    IDENTIFIER      shift and go to state 86
    TYPENAME        shift and go to state 87
    FLOAT           shift and go to state 33
    INTEGER         shift and go to state 23
    BOOL            shift and go to state 34
    STRING          shift and go to state 12

    INFIX_EXP                      shift and go to state 122
    LEXP                           shift and go to state 70
    LAMBDA_ABSTRACTION             shift and go to state 72
    LET_EXPR                       shift and go to state 73
    IF_EXPR                        shift and go to state 74
    MATCH_EXPR                     shift and go to state 75
    FUNCTION_EXPR                  shift and go to state 76
    EXP                            shift and go to state 123
    AEXP                           shift and go to state 80
    USED_VAR                       shift and go to state 81
    USED_TYPENAME                  shift and go to state 82
    LITERAL                        shift and go to state 83
    OPERATOR_FUNC                  shift and go to state 84

state 72

    (50) LEXP -> LAMBDA_ABSTRACTION .

    PLUS            reduce using rule 50 (LEXP -> LAMBDA_ABSTRACTION .)
    MINUS           reduce using rule 50 (LEXP -> LAMBDA_ABSTRACTION .)
    TIMES           reduce using rule 50 (LEXP -> LAMBDA_ABSTRACTION .)
    DIVIDE          reduce using rule 50 (LEXP -> LAMBDA_ABSTRACTION .)
    MODULO          reduce using rule 50 (LEXP -> LAMBDA_ABSTRACTION .)
    FPOW            reduce using rule 50 (LEXP -> LAMBDA_ABSTRACTION .)
    IPOW            reduce using rule 50 (LEXP -> LAMBDA_ABSTRACTION .)
    EQUALITY        reduce using rule 50 (LEXP -> LAMBDA_ABSTRACTION .)
    INEQUALITY      reduce using rule 50 (LEXP -> LAMBDA_ABSTRACTION .)
    LESS            reduce using rule 50 (LEXP -> LAMBDA_ABSTRACTION .)
    LEQ             reduce using rule 50 (LEXP -> LAMBDA_ABSTRACTION .)
    GREATER         reduce using rule 50 (LEXP -> LAMBDA_ABSTRACTION .)
    GEQ             reduce using rule 50 (LEXP -> LAMBDA_ABSTRACTION .)
    CONCAT          reduce using rule 50 (LEXP -> LAMBDA_ABSTRACTION .)
    AND             reduce using rule 50 (LEXP -> LAMBDA_ABSTRACTION .)
    OR              reduce using rule 50 (LEXP -> LAMBDA_ABSTRACTION .)
    TILDE           reduce using rule 50 (LEXP -> LAMBDA_ABSTRACTION .)
    WITH            reduce using rule 50 (LEXP -> LAMBDA_ABSTRACTION .)
    IF              reduce using rule 50 (LEXP -> LAMBDA_ABSTRACTION .)
    CLOSE_BRACE     reduce using rule 50 (LEXP -> LAMBDA_ABSTRACTION .)
    ENDSTATEMENT    reduce using rule 50 (LEXP -> LAMBDA_ABSTRACTION .)
    EQUALS          reduce using rule 50 (LEXP -> LAMBDA_ABSTRACTION .)
    ON              reduce using rule 50 (LEXP -> LAMBDA_ABSTRACTION .)
    ELSE            reduce using rule 50 (LEXP -> LAMBDA_ABSTRACTION .)
    CLOSE_PAREN     reduce using rule 50 (LEXP -> LAMBDA_ABSTRACTION .)
    GIVEN           reduce using rule 50 (LEXP -> LAMBDA_ABSTRACTION .)


state 73

    (51) LEXP -> LET_EXPR .

    PLUS            reduce using rule 51 (LEXP -> LET_EXPR .)
    MINUS           reduce using rule 51 (LEXP -> LET_EXPR .)
    TIMES           reduce using rule 51 (LEXP -> LET_EXPR .)
    DIVIDE          reduce using rule 51 (LEXP -> LET_EXPR .)
    MODULO          reduce using rule 51 (LEXP -> LET_EXPR .)
    FPOW            reduce using rule 51 (LEXP -> LET_EXPR .)
    IPOW            reduce using rule 51 (LEXP -> LET_EXPR .)
    EQUALITY        reduce using rule 51 (LEXP -> LET_EXPR .)
    INEQUALITY      reduce using rule 51 (LEXP -> LET_EXPR .)
    LESS            reduce using rule 51 (LEXP -> LET_EXPR .)
    LEQ             reduce using rule 51 (LEXP -> LET_EXPR .)
    GREATER         reduce using rule 51 (LEXP -> LET_EXPR .)
    GEQ             reduce using rule 51 (LEXP -> LET_EXPR .)
    CONCAT          reduce using rule 51 (LEXP -> LET_EXPR .)
    AND             reduce using rule 51 (LEXP -> LET_EXPR .)
    OR              reduce using rule 51 (LEXP -> LET_EXPR .)
    TILDE           reduce using rule 51 (LEXP -> LET_EXPR .)
    WITH            reduce using rule 51 (LEXP -> LET_EXPR .)
    IF              reduce using rule 51 (LEXP -> LET_EXPR .)
    CLOSE_BRACE     reduce using rule 51 (LEXP -> LET_EXPR .)
    ENDSTATEMENT    reduce using rule 51 (LEXP -> LET_EXPR .)
    EQUALS          reduce using rule 51 (LEXP -> LET_EXPR .)
    ON              reduce using rule 51 (LEXP -> LET_EXPR .)
    ELSE            reduce using rule 51 (LEXP -> LET_EXPR .)
    CLOSE_PAREN     reduce using rule 51 (LEXP -> LET_EXPR .)
    GIVEN           reduce using rule 51 (LEXP -> LET_EXPR .)


state 74

    (52) LEXP -> IF_EXPR .

    PLUS            reduce using rule 52 (LEXP -> IF_EXPR .)
    MINUS           reduce using rule 52 (LEXP -> IF_EXPR .)
    TIMES           reduce using rule 52 (LEXP -> IF_EXPR .)
    DIVIDE          reduce using rule 52 (LEXP -> IF_EXPR .)
    MODULO          reduce using rule 52 (LEXP -> IF_EXPR .)
    FPOW            reduce using rule 52 (LEXP -> IF_EXPR .)
    IPOW            reduce using rule 52 (LEXP -> IF_EXPR .)
    EQUALITY        reduce using rule 52 (LEXP -> IF_EXPR .)
    INEQUALITY      reduce using rule 52 (LEXP -> IF_EXPR .)
    LESS            reduce using rule 52 (LEXP -> IF_EXPR .)
    LEQ             reduce using rule 52 (LEXP -> IF_EXPR .)
    GREATER         reduce using rule 52 (LEXP -> IF_EXPR .)
    GEQ             reduce using rule 52 (LEXP -> IF_EXPR .)
    CONCAT          reduce using rule 52 (LEXP -> IF_EXPR .)
    AND             reduce using rule 52 (LEXP -> IF_EXPR .)
    OR              reduce using rule 52 (LEXP -> IF_EXPR .)
    TILDE           reduce using rule 52 (LEXP -> IF_EXPR .)
    WITH            reduce using rule 52 (LEXP -> IF_EXPR .)
    IF              reduce using rule 52 (LEXP -> IF_EXPR .)
    CLOSE_BRACE     reduce using rule 52 (LEXP -> IF_EXPR .)
    ENDSTATEMENT    reduce using rule 52 (LEXP -> IF_EXPR .)
    EQUALS          reduce using rule 52 (LEXP -> IF_EXPR .)
    ON              reduce using rule 52 (LEXP -> IF_EXPR .)
    ELSE            reduce using rule 52 (LEXP -> IF_EXPR .)
    CLOSE_PAREN     reduce using rule 52 (LEXP -> IF_EXPR .)
    GIVEN           reduce using rule 52 (LEXP -> IF_EXPR .)


state 75

    (53) LEXP -> MATCH_EXPR .

    PLUS            reduce using rule 53 (LEXP -> MATCH_EXPR .)
    MINUS           reduce using rule 53 (LEXP -> MATCH_EXPR .)
    TIMES           reduce using rule 53 (LEXP -> MATCH_EXPR .)
    DIVIDE          reduce using rule 53 (LEXP -> MATCH_EXPR .)
    MODULO          reduce using rule 53 (LEXP -> MATCH_EXPR .)
    FPOW            reduce using rule 53 (LEXP -> MATCH_EXPR .)
    IPOW            reduce using rule 53 (LEXP -> MATCH_EXPR .)
    EQUALITY        reduce using rule 53 (LEXP -> MATCH_EXPR .)
    INEQUALITY      reduce using rule 53 (LEXP -> MATCH_EXPR .)
    LESS            reduce using rule 53 (LEXP -> MATCH_EXPR .)
    LEQ             reduce using rule 53 (LEXP -> MATCH_EXPR .)
    GREATER         reduce using rule 53 (LEXP -> MATCH_EXPR .)
    GEQ             reduce using rule 53 (LEXP -> MATCH_EXPR .)
    CONCAT          reduce using rule 53 (LEXP -> MATCH_EXPR .)
    AND             reduce using rule 53 (LEXP -> MATCH_EXPR .)
    OR              reduce using rule 53 (LEXP -> MATCH_EXPR .)
    TILDE           reduce using rule 53 (LEXP -> MATCH_EXPR .)
    WITH            reduce using rule 53 (LEXP -> MATCH_EXPR .)
    IF              reduce using rule 53 (LEXP -> MATCH_EXPR .)
    CLOSE_BRACE     reduce using rule 53 (LEXP -> MATCH_EXPR .)
    ENDSTATEMENT    reduce using rule 53 (LEXP -> MATCH_EXPR .)
    EQUALS          reduce using rule 53 (LEXP -> MATCH_EXPR .)
    ON              reduce using rule 53 (LEXP -> MATCH_EXPR .)
    ELSE            reduce using rule 53 (LEXP -> MATCH_EXPR .)
    CLOSE_PAREN     reduce using rule 53 (LEXP -> MATCH_EXPR .)
    GIVEN           reduce using rule 53 (LEXP -> MATCH_EXPR .)


state 76

    (54) LEXP -> FUNCTION_EXPR .
    (59) FUNCTION_EXPR -> FUNCTION_EXPR . AEXP
    (61) AEXP -> . USED_VAR
    (62) AEXP -> . USED_TYPENAME
    (63) AEXP -> . LITERAL
    (64) AEXP -> . OPERATOR_FUNC
    (65) AEXP -> . OPEN_PAREN EXP CLOSE_PAREN
    (106) USED_VAR -> . IDENTIFIER
    (107) USED_TYPENAME -> . TYPENAME
    (102) LITERAL -> . FLOAT
    (103) LITERAL -> . INTEGER
    (104) LITERAL -> . BOOL
    (105) LITERAL -> . STRING
    (66) OPERATOR_FUNC -> . OPEN_PAREN OP CLOSE_PAREN

    PLUS            reduce using rule 54 (LEXP -> FUNCTION_EXPR .)
    MINUS           reduce using rule 54 (LEXP -> FUNCTION_EXPR .)
    TIMES           reduce using rule 54 (LEXP -> FUNCTION_EXPR .)
    DIVIDE          reduce using rule 54 (LEXP -> FUNCTION_EXPR .)
    MODULO          reduce using rule 54 (LEXP -> FUNCTION_EXPR .)
    FPOW            reduce using rule 54 (LEXP -> FUNCTION_EXPR .)
    IPOW            reduce using rule 54 (LEXP -> FUNCTION_EXPR .)
    EQUALITY        reduce using rule 54 (LEXP -> FUNCTION_EXPR .)
    INEQUALITY      reduce using rule 54 (LEXP -> FUNCTION_EXPR .)
    LESS            reduce using rule 54 (LEXP -> FUNCTION_EXPR .)
    LEQ             reduce using rule 54 (LEXP -> FUNCTION_EXPR .)
    GREATER         reduce using rule 54 (LEXP -> FUNCTION_EXPR .)
    GEQ             reduce using rule 54 (LEXP -> FUNCTION_EXPR .)
    CONCAT          reduce using rule 54 (LEXP -> FUNCTION_EXPR .)
    AND             reduce using rule 54 (LEXP -> FUNCTION_EXPR .)
    OR              reduce using rule 54 (LEXP -> FUNCTION_EXPR .)
    TILDE           reduce using rule 54 (LEXP -> FUNCTION_EXPR .)
    WITH            reduce using rule 54 (LEXP -> FUNCTION_EXPR .)
    IF              reduce using rule 54 (LEXP -> FUNCTION_EXPR .)
    CLOSE_BRACE     reduce using rule 54 (LEXP -> FUNCTION_EXPR .)
    ENDSTATEMENT    reduce using rule 54 (LEXP -> FUNCTION_EXPR .)
    EQUALS          reduce using rule 54 (LEXP -> FUNCTION_EXPR .)
    ON              reduce using rule 54 (LEXP -> FUNCTION_EXPR .)
    ELSE            reduce using rule 54 (LEXP -> FUNCTION_EXPR .)
    CLOSE_PAREN     reduce using rule 54 (LEXP -> FUNCTION_EXPR .)
    GIVEN           reduce using rule 54 (LEXP -> FUNCTION_EXPR .)
    OPEN_PAREN      shift and go to state 85
    IDENTIFIER      shift and go to state 86
    TYPENAME        shift and go to state 87
    FLOAT           shift and go to state 33
    INTEGER         shift and go to state 23
    BOOL            shift and go to state 34
    STRING          shift and go to state 12

    AEXP                           shift and go to state 124
    USED_VAR                       shift and go to state 81
    USED_TYPENAME                  shift and go to state 82
    LITERAL                        shift and go to state 83
    OPERATOR_FUNC                  shift and go to state 84

state 77

    (55) LAMBDA_ABSTRACTION -> LAMBDA . APAT APATS ARROW EXP
    (77) APAT -> . PARAM
    (78) APAT -> . TYPENAME
    (79) APAT -> . LITERAL
    (80) APAT -> . OPEN_PAREN LPAT CLOSE_PAREN
    (108) PARAM -> . IDENTIFIER
    (102) LITERAL -> . FLOAT
    (103) LITERAL -> . INTEGER
    (104) LITERAL -> . BOOL
    (105) LITERAL -> . STRING

    TYPENAME        shift and go to state 40
    OPEN_PAREN      shift and go to state 43
    IDENTIFIER      shift and go to state 44
    FLOAT           shift and go to state 33
    INTEGER         shift and go to state 23
    BOOL            shift and go to state 34
    STRING          shift and go to state 12

    APAT                           shift and go to state 125
    PARAM                          shift and go to state 42
    LITERAL                        shift and go to state 31

state 78

    (56) LET_EXPR -> LET . DECLARATIONS IN EXP
    (15) DECLARATIONS -> . OPEN_BRACE DECLARATIONS_LIST CLOSE_BRACE
    (16) DECLARATIONS -> . OPEN_BRACE CLOSE_BRACE

    OPEN_BRACE      shift and go to state 127

    DECLARATIONS                   shift and go to state 126

state 79

    (58) MATCH_EXPR -> MATCH . EXP ON OPEN_BRACE ALTS CLOSE_BRACE
    (46) EXP -> . INFIX_EXP
    (47) INFIX_EXP -> . LEXP OP INFIX_EXP
    (48) INFIX_EXP -> . MINUS INFIX_EXP
    (49) INFIX_EXP -> . LEXP
    (50) LEXP -> . LAMBDA_ABSTRACTION
    (51) LEXP -> . LET_EXPR
    (52) LEXP -> . IF_EXPR
    (53) LEXP -> . MATCH_EXPR
    (54) LEXP -> . FUNCTION_EXPR
    (55) LAMBDA_ABSTRACTION -> . LAMBDA APAT APATS ARROW EXP
    (56) LET_EXPR -> . LET DECLARATIONS IN EXP
    (57) IF_EXPR -> . EXP IF EXP ELSE EXP
    (58) MATCH_EXPR -> . MATCH EXP ON OPEN_BRACE ALTS CLOSE_BRACE
    (59) FUNCTION_EXPR -> . FUNCTION_EXPR AEXP
    (60) FUNCTION_EXPR -> . AEXP
    (61) AEXP -> . USED_VAR
    (62) AEXP -> . USED_TYPENAME
    (63) AEXP -> . LITERAL
    (64) AEXP -> . OPERATOR_FUNC
    (65) AEXP -> . OPEN_PAREN EXP CLOSE_PAREN
    (106) USED_VAR -> . IDENTIFIER
    (107) USED_TYPENAME -> . TYPENAME
    (102) LITERAL -> . FLOAT
    (103) LITERAL -> . INTEGER
    (104) LITERAL -> . BOOL
    (105) LITERAL -> . STRING
    (66) OPERATOR_FUNC -> . OPEN_PAREN OP CLOSE_PAREN

    MINUS           shift and go to state 71
    LAMBDA          shift and go to state 77
    LET             shift and go to state 78
    MATCH           shift and go to state 79
    OPEN_PAREN      shift and go to state 85
    IDENTIFIER      shift and go to state 86
    TYPENAME        shift and go to state 87
    FLOAT           shift and go to state 33
    INTEGER         shift and go to state 23
    BOOL            shift and go to state 34
    STRING          shift and go to state 12

    EXP                            shift and go to state 128
    INFIX_EXP                      shift and go to state 69
    LEXP                           shift and go to state 70
    LAMBDA_ABSTRACTION             shift and go to state 72
    LET_EXPR                       shift and go to state 73
    IF_EXPR                        shift and go to state 74
    MATCH_EXPR                     shift and go to state 75
    FUNCTION_EXPR                  shift and go to state 76
    AEXP                           shift and go to state 80
    USED_VAR                       shift and go to state 81
    USED_TYPENAME                  shift and go to state 82
    LITERAL                        shift and go to state 83
    OPERATOR_FUNC                  shift and go to state 84

state 80

    (60) FUNCTION_EXPR -> AEXP .

    OPEN_PAREN      reduce using rule 60 (FUNCTION_EXPR -> AEXP .)
    IDENTIFIER      reduce using rule 60 (FUNCTION_EXPR -> AEXP .)
    TYPENAME        reduce using rule 60 (FUNCTION_EXPR -> AEXP .)
    FLOAT           reduce using rule 60 (FUNCTION_EXPR -> AEXP .)
    INTEGER         reduce using rule 60 (FUNCTION_EXPR -> AEXP .)
    BOOL            reduce using rule 60 (FUNCTION_EXPR -> AEXP .)
    STRING          reduce using rule 60 (FUNCTION_EXPR -> AEXP .)
    PLUS            reduce using rule 60 (FUNCTION_EXPR -> AEXP .)
    MINUS           reduce using rule 60 (FUNCTION_EXPR -> AEXP .)
    TIMES           reduce using rule 60 (FUNCTION_EXPR -> AEXP .)
    DIVIDE          reduce using rule 60 (FUNCTION_EXPR -> AEXP .)
    MODULO          reduce using rule 60 (FUNCTION_EXPR -> AEXP .)
    FPOW            reduce using rule 60 (FUNCTION_EXPR -> AEXP .)
    IPOW            reduce using rule 60 (FUNCTION_EXPR -> AEXP .)
    EQUALITY        reduce using rule 60 (FUNCTION_EXPR -> AEXP .)
    INEQUALITY      reduce using rule 60 (FUNCTION_EXPR -> AEXP .)
    LESS            reduce using rule 60 (FUNCTION_EXPR -> AEXP .)
    LEQ             reduce using rule 60 (FUNCTION_EXPR -> AEXP .)
    GREATER         reduce using rule 60 (FUNCTION_EXPR -> AEXP .)
    GEQ             reduce using rule 60 (FUNCTION_EXPR -> AEXP .)
    CONCAT          reduce using rule 60 (FUNCTION_EXPR -> AEXP .)
    AND             reduce using rule 60 (FUNCTION_EXPR -> AEXP .)
    OR              reduce using rule 60 (FUNCTION_EXPR -> AEXP .)
    TILDE           reduce using rule 60 (FUNCTION_EXPR -> AEXP .)
    WITH            reduce using rule 60 (FUNCTION_EXPR -> AEXP .)
    IF              reduce using rule 60 (FUNCTION_EXPR -> AEXP .)
    CLOSE_BRACE     reduce using rule 60 (FUNCTION_EXPR -> AEXP .)
    ENDSTATEMENT    reduce using rule 60 (FUNCTION_EXPR -> AEXP .)
    EQUALS          reduce using rule 60 (FUNCTION_EXPR -> AEXP .)
    ON              reduce using rule 60 (FUNCTION_EXPR -> AEXP .)
    ELSE            reduce using rule 60 (FUNCTION_EXPR -> AEXP .)
    CLOSE_PAREN     reduce using rule 60 (FUNCTION_EXPR -> AEXP .)
    GIVEN           reduce using rule 60 (FUNCTION_EXPR -> AEXP .)


state 81

    (61) AEXP -> USED_VAR .

    OPEN_PAREN      reduce using rule 61 (AEXP -> USED_VAR .)
    IDENTIFIER      reduce using rule 61 (AEXP -> USED_VAR .)
    TYPENAME        reduce using rule 61 (AEXP -> USED_VAR .)
    FLOAT           reduce using rule 61 (AEXP -> USED_VAR .)
    INTEGER         reduce using rule 61 (AEXP -> USED_VAR .)
    BOOL            reduce using rule 61 (AEXP -> USED_VAR .)
    STRING          reduce using rule 61 (AEXP -> USED_VAR .)
    PLUS            reduce using rule 61 (AEXP -> USED_VAR .)
    MINUS           reduce using rule 61 (AEXP -> USED_VAR .)
    TIMES           reduce using rule 61 (AEXP -> USED_VAR .)
    DIVIDE          reduce using rule 61 (AEXP -> USED_VAR .)
    MODULO          reduce using rule 61 (AEXP -> USED_VAR .)
    FPOW            reduce using rule 61 (AEXP -> USED_VAR .)
    IPOW            reduce using rule 61 (AEXP -> USED_VAR .)
    EQUALITY        reduce using rule 61 (AEXP -> USED_VAR .)
    INEQUALITY      reduce using rule 61 (AEXP -> USED_VAR .)
    LESS            reduce using rule 61 (AEXP -> USED_VAR .)
    LEQ             reduce using rule 61 (AEXP -> USED_VAR .)
    GREATER         reduce using rule 61 (AEXP -> USED_VAR .)
    GEQ             reduce using rule 61 (AEXP -> USED_VAR .)
    CONCAT          reduce using rule 61 (AEXP -> USED_VAR .)
    AND             reduce using rule 61 (AEXP -> USED_VAR .)
    OR              reduce using rule 61 (AEXP -> USED_VAR .)
    TILDE           reduce using rule 61 (AEXP -> USED_VAR .)
    WITH            reduce using rule 61 (AEXP -> USED_VAR .)
    IF              reduce using rule 61 (AEXP -> USED_VAR .)
    CLOSE_BRACE     reduce using rule 61 (AEXP -> USED_VAR .)
    ENDSTATEMENT    reduce using rule 61 (AEXP -> USED_VAR .)
    EQUALS          reduce using rule 61 (AEXP -> USED_VAR .)
    ON              reduce using rule 61 (AEXP -> USED_VAR .)
    ELSE            reduce using rule 61 (AEXP -> USED_VAR .)
    CLOSE_PAREN     reduce using rule 61 (AEXP -> USED_VAR .)
    GIVEN           reduce using rule 61 (AEXP -> USED_VAR .)


state 82

    (62) AEXP -> USED_TYPENAME .

    OPEN_PAREN      reduce using rule 62 (AEXP -> USED_TYPENAME .)
    IDENTIFIER      reduce using rule 62 (AEXP -> USED_TYPENAME .)
    TYPENAME        reduce using rule 62 (AEXP -> USED_TYPENAME .)
    FLOAT           reduce using rule 62 (AEXP -> USED_TYPENAME .)
    INTEGER         reduce using rule 62 (AEXP -> USED_TYPENAME .)
    BOOL            reduce using rule 62 (AEXP -> USED_TYPENAME .)
    STRING          reduce using rule 62 (AEXP -> USED_TYPENAME .)
    PLUS            reduce using rule 62 (AEXP -> USED_TYPENAME .)
    MINUS           reduce using rule 62 (AEXP -> USED_TYPENAME .)
    TIMES           reduce using rule 62 (AEXP -> USED_TYPENAME .)
    DIVIDE          reduce using rule 62 (AEXP -> USED_TYPENAME .)
    MODULO          reduce using rule 62 (AEXP -> USED_TYPENAME .)
    FPOW            reduce using rule 62 (AEXP -> USED_TYPENAME .)
    IPOW            reduce using rule 62 (AEXP -> USED_TYPENAME .)
    EQUALITY        reduce using rule 62 (AEXP -> USED_TYPENAME .)
    INEQUALITY      reduce using rule 62 (AEXP -> USED_TYPENAME .)
    LESS            reduce using rule 62 (AEXP -> USED_TYPENAME .)
    LEQ             reduce using rule 62 (AEXP -> USED_TYPENAME .)
    GREATER         reduce using rule 62 (AEXP -> USED_TYPENAME .)
    GEQ             reduce using rule 62 (AEXP -> USED_TYPENAME .)
    CONCAT          reduce using rule 62 (AEXP -> USED_TYPENAME .)
    AND             reduce using rule 62 (AEXP -> USED_TYPENAME .)
    OR              reduce using rule 62 (AEXP -> USED_TYPENAME .)
    TILDE           reduce using rule 62 (AEXP -> USED_TYPENAME .)
    WITH            reduce using rule 62 (AEXP -> USED_TYPENAME .)
    IF              reduce using rule 62 (AEXP -> USED_TYPENAME .)
    CLOSE_BRACE     reduce using rule 62 (AEXP -> USED_TYPENAME .)
    ENDSTATEMENT    reduce using rule 62 (AEXP -> USED_TYPENAME .)
    EQUALS          reduce using rule 62 (AEXP -> USED_TYPENAME .)
    ON              reduce using rule 62 (AEXP -> USED_TYPENAME .)
    ELSE            reduce using rule 62 (AEXP -> USED_TYPENAME .)
    CLOSE_PAREN     reduce using rule 62 (AEXP -> USED_TYPENAME .)
    GIVEN           reduce using rule 62 (AEXP -> USED_TYPENAME .)


state 83

    (63) AEXP -> LITERAL .

    OPEN_PAREN      reduce using rule 63 (AEXP -> LITERAL .)
    IDENTIFIER      reduce using rule 63 (AEXP -> LITERAL .)
    TYPENAME        reduce using rule 63 (AEXP -> LITERAL .)
    FLOAT           reduce using rule 63 (AEXP -> LITERAL .)
    INTEGER         reduce using rule 63 (AEXP -> LITERAL .)
    BOOL            reduce using rule 63 (AEXP -> LITERAL .)
    STRING          reduce using rule 63 (AEXP -> LITERAL .)
    PLUS            reduce using rule 63 (AEXP -> LITERAL .)
    MINUS           reduce using rule 63 (AEXP -> LITERAL .)
    TIMES           reduce using rule 63 (AEXP -> LITERAL .)
    DIVIDE          reduce using rule 63 (AEXP -> LITERAL .)
    MODULO          reduce using rule 63 (AEXP -> LITERAL .)
    FPOW            reduce using rule 63 (AEXP -> LITERAL .)
    IPOW            reduce using rule 63 (AEXP -> LITERAL .)
    EQUALITY        reduce using rule 63 (AEXP -> LITERAL .)
    INEQUALITY      reduce using rule 63 (AEXP -> LITERAL .)
    LESS            reduce using rule 63 (AEXP -> LITERAL .)
    LEQ             reduce using rule 63 (AEXP -> LITERAL .)
    GREATER         reduce using rule 63 (AEXP -> LITERAL .)
    GEQ             reduce using rule 63 (AEXP -> LITERAL .)
    CONCAT          reduce using rule 63 (AEXP -> LITERAL .)
    AND             reduce using rule 63 (AEXP -> LITERAL .)
    OR              reduce using rule 63 (AEXP -> LITERAL .)
    TILDE           reduce using rule 63 (AEXP -> LITERAL .)
    WITH            reduce using rule 63 (AEXP -> LITERAL .)
    IF              reduce using rule 63 (AEXP -> LITERAL .)
    CLOSE_BRACE     reduce using rule 63 (AEXP -> LITERAL .)
    ENDSTATEMENT    reduce using rule 63 (AEXP -> LITERAL .)
    EQUALS          reduce using rule 63 (AEXP -> LITERAL .)
    ON              reduce using rule 63 (AEXP -> LITERAL .)
    ELSE            reduce using rule 63 (AEXP -> LITERAL .)
    CLOSE_PAREN     reduce using rule 63 (AEXP -> LITERAL .)
    GIVEN           reduce using rule 63 (AEXP -> LITERAL .)


state 84

    (64) AEXP -> OPERATOR_FUNC .

    OPEN_PAREN      reduce using rule 64 (AEXP -> OPERATOR_FUNC .)
    IDENTIFIER      reduce using rule 64 (AEXP -> OPERATOR_FUNC .)
    TYPENAME        reduce using rule 64 (AEXP -> OPERATOR_FUNC .)
    FLOAT           reduce using rule 64 (AEXP -> OPERATOR_FUNC .)
    INTEGER         reduce using rule 64 (AEXP -> OPERATOR_FUNC .)
    BOOL            reduce using rule 64 (AEXP -> OPERATOR_FUNC .)
    STRING          reduce using rule 64 (AEXP -> OPERATOR_FUNC .)
    PLUS            reduce using rule 64 (AEXP -> OPERATOR_FUNC .)
    MINUS           reduce using rule 64 (AEXP -> OPERATOR_FUNC .)
    TIMES           reduce using rule 64 (AEXP -> OPERATOR_FUNC .)
    DIVIDE          reduce using rule 64 (AEXP -> OPERATOR_FUNC .)
    MODULO          reduce using rule 64 (AEXP -> OPERATOR_FUNC .)
    FPOW            reduce using rule 64 (AEXP -> OPERATOR_FUNC .)
    IPOW            reduce using rule 64 (AEXP -> OPERATOR_FUNC .)
    EQUALITY        reduce using rule 64 (AEXP -> OPERATOR_FUNC .)
    INEQUALITY      reduce using rule 64 (AEXP -> OPERATOR_FUNC .)
    LESS            reduce using rule 64 (AEXP -> OPERATOR_FUNC .)
    LEQ             reduce using rule 64 (AEXP -> OPERATOR_FUNC .)
    GREATER         reduce using rule 64 (AEXP -> OPERATOR_FUNC .)
    GEQ             reduce using rule 64 (AEXP -> OPERATOR_FUNC .)
    CONCAT          reduce using rule 64 (AEXP -> OPERATOR_FUNC .)
    AND             reduce using rule 64 (AEXP -> OPERATOR_FUNC .)
    OR              reduce using rule 64 (AEXP -> OPERATOR_FUNC .)
    TILDE           reduce using rule 64 (AEXP -> OPERATOR_FUNC .)
    WITH            reduce using rule 64 (AEXP -> OPERATOR_FUNC .)
    IF              reduce using rule 64 (AEXP -> OPERATOR_FUNC .)
    CLOSE_BRACE     reduce using rule 64 (AEXP -> OPERATOR_FUNC .)
    ENDSTATEMENT    reduce using rule 64 (AEXP -> OPERATOR_FUNC .)
    EQUALS          reduce using rule 64 (AEXP -> OPERATOR_FUNC .)
    ON              reduce using rule 64 (AEXP -> OPERATOR_FUNC .)
    ELSE            reduce using rule 64 (AEXP -> OPERATOR_FUNC .)
    CLOSE_PAREN     reduce using rule 64 (AEXP -> OPERATOR_FUNC .)
    GIVEN           reduce using rule 64 (AEXP -> OPERATOR_FUNC .)


state 85

    (65) AEXP -> OPEN_PAREN . EXP CLOSE_PAREN
    (66) OPERATOR_FUNC -> OPEN_PAREN . OP CLOSE_PAREN
    (46) EXP -> . INFIX_EXP
    (81) OP -> . VARSYM
    (82) OP -> . INFIX_FUNCTION
    (47) INFIX_EXP -> . LEXP OP INFIX_EXP
    (48) INFIX_EXP -> . MINUS INFIX_EXP
    (49) INFIX_EXP -> . LEXP
    (86) VARSYM -> . PLUS
    (87) VARSYM -> . MINUS
    (88) VARSYM -> . TIMES
    (89) VARSYM -> . DIVIDE
    (90) VARSYM -> . MODULO
    (91) VARSYM -> . FPOW
    (92) VARSYM -> . IPOW
    (93) VARSYM -> . EQUALITY
    (94) VARSYM -> . INEQUALITY
    (95) VARSYM -> . LESS
    (96) VARSYM -> . LEQ
    (97) VARSYM -> . GREATER
    (98) VARSYM -> . GEQ
    (99) VARSYM -> . CONCAT
    (100) VARSYM -> . AND
    (101) VARSYM -> . OR
    (83) INFIX_FUNCTION -> . TILDE IDENTIFIER TILDE
    (50) LEXP -> . LAMBDA_ABSTRACTION
    (51) LEXP -> . LET_EXPR
    (52) LEXP -> . IF_EXPR
    (53) LEXP -> . MATCH_EXPR
    (54) LEXP -> . FUNCTION_EXPR
    (55) LAMBDA_ABSTRACTION -> . LAMBDA APAT APATS ARROW EXP
    (56) LET_EXPR -> . LET DECLARATIONS IN EXP
    (57) IF_EXPR -> . EXP IF EXP ELSE EXP
    (58) MATCH_EXPR -> . MATCH EXP ON OPEN_BRACE ALTS CLOSE_BRACE
    (59) FUNCTION_EXPR -> . FUNCTION_EXPR AEXP
    (60) FUNCTION_EXPR -> . AEXP
    (61) AEXP -> . USED_VAR
    (62) AEXP -> . USED_TYPENAME
    (63) AEXP -> . LITERAL
    (64) AEXP -> . OPERATOR_FUNC
    (65) AEXP -> . OPEN_PAREN EXP CLOSE_PAREN
    (106) USED_VAR -> . IDENTIFIER
    (107) USED_TYPENAME -> . TYPENAME
    (102) LITERAL -> . FLOAT
    (103) LITERAL -> . INTEGER
    (104) LITERAL -> . BOOL
    (105) LITERAL -> . STRING
    (66) OPERATOR_FUNC -> . OPEN_PAREN OP CLOSE_PAREN

    MINUS           shift and go to state 131
    PLUS            shift and go to state 106
    TIMES           shift and go to state 108
    DIVIDE          shift and go to state 109
    MODULO          shift and go to state 110
    FPOW            shift and go to state 111
    IPOW            shift and go to state 112
    EQUALITY        shift and go to state 113
    INEQUALITY      shift and go to state 114
    LESS            shift and go to state 115
    LEQ             shift and go to state 116
    GREATER         shift and go to state 117
    GEQ             shift and go to state 118
    CONCAT          shift and go to state 119
    AND             shift and go to state 120
    OR              shift and go to state 121
    TILDE           shift and go to state 58
    LAMBDA          shift and go to state 77
    LET             shift and go to state 78
    MATCH           shift and go to state 79
    OPEN_PAREN      shift and go to state 85
    IDENTIFIER      shift and go to state 86
    TYPENAME        shift and go to state 87
    FLOAT           shift and go to state 33
    INTEGER         shift and go to state 23
    BOOL            shift and go to state 34
    STRING          shift and go to state 12

    EXP                            shift and go to state 129
    OP                             shift and go to state 130
    INFIX_EXP                      shift and go to state 69
    VARSYM                         shift and go to state 104
    INFIX_FUNCTION                 shift and go to state 105
    LEXP                           shift and go to state 70
    LAMBDA_ABSTRACTION             shift and go to state 72
    LET_EXPR                       shift and go to state 73
    IF_EXPR                        shift and go to state 74
    MATCH_EXPR                     shift and go to state 75
    FUNCTION_EXPR                  shift and go to state 76
    AEXP                           shift and go to state 80
    USED_VAR                       shift and go to state 81
    USED_TYPENAME                  shift and go to state 82
    LITERAL                        shift and go to state 83
    OPERATOR_FUNC                  shift and go to state 84

state 86

    (106) USED_VAR -> IDENTIFIER .

    OPEN_PAREN      reduce using rule 106 (USED_VAR -> IDENTIFIER .)
    IDENTIFIER      reduce using rule 106 (USED_VAR -> IDENTIFIER .)
    TYPENAME        reduce using rule 106 (USED_VAR -> IDENTIFIER .)
    FLOAT           reduce using rule 106 (USED_VAR -> IDENTIFIER .)
    INTEGER         reduce using rule 106 (USED_VAR -> IDENTIFIER .)
    BOOL            reduce using rule 106 (USED_VAR -> IDENTIFIER .)
    STRING          reduce using rule 106 (USED_VAR -> IDENTIFIER .)
    PLUS            reduce using rule 106 (USED_VAR -> IDENTIFIER .)
    MINUS           reduce using rule 106 (USED_VAR -> IDENTIFIER .)
    TIMES           reduce using rule 106 (USED_VAR -> IDENTIFIER .)
    DIVIDE          reduce using rule 106 (USED_VAR -> IDENTIFIER .)
    MODULO          reduce using rule 106 (USED_VAR -> IDENTIFIER .)
    FPOW            reduce using rule 106 (USED_VAR -> IDENTIFIER .)
    IPOW            reduce using rule 106 (USED_VAR -> IDENTIFIER .)
    EQUALITY        reduce using rule 106 (USED_VAR -> IDENTIFIER .)
    INEQUALITY      reduce using rule 106 (USED_VAR -> IDENTIFIER .)
    LESS            reduce using rule 106 (USED_VAR -> IDENTIFIER .)
    LEQ             reduce using rule 106 (USED_VAR -> IDENTIFIER .)
    GREATER         reduce using rule 106 (USED_VAR -> IDENTIFIER .)
    GEQ             reduce using rule 106 (USED_VAR -> IDENTIFIER .)
    CONCAT          reduce using rule 106 (USED_VAR -> IDENTIFIER .)
    AND             reduce using rule 106 (USED_VAR -> IDENTIFIER .)
    OR              reduce using rule 106 (USED_VAR -> IDENTIFIER .)
    TILDE           reduce using rule 106 (USED_VAR -> IDENTIFIER .)
    WITH            reduce using rule 106 (USED_VAR -> IDENTIFIER .)
    IF              reduce using rule 106 (USED_VAR -> IDENTIFIER .)
    CLOSE_BRACE     reduce using rule 106 (USED_VAR -> IDENTIFIER .)
    ENDSTATEMENT    reduce using rule 106 (USED_VAR -> IDENTIFIER .)
    EQUALS          reduce using rule 106 (USED_VAR -> IDENTIFIER .)
    ON              reduce using rule 106 (USED_VAR -> IDENTIFIER .)
    ELSE            reduce using rule 106 (USED_VAR -> IDENTIFIER .)
    CLOSE_PAREN     reduce using rule 106 (USED_VAR -> IDENTIFIER .)
    GIVEN           reduce using rule 106 (USED_VAR -> IDENTIFIER .)


state 87

    (107) USED_TYPENAME -> TYPENAME .

    OPEN_PAREN      reduce using rule 107 (USED_TYPENAME -> TYPENAME .)
    IDENTIFIER      reduce using rule 107 (USED_TYPENAME -> TYPENAME .)
    TYPENAME        reduce using rule 107 (USED_TYPENAME -> TYPENAME .)
    FLOAT           reduce using rule 107 (USED_TYPENAME -> TYPENAME .)
    INTEGER         reduce using rule 107 (USED_TYPENAME -> TYPENAME .)
    BOOL            reduce using rule 107 (USED_TYPENAME -> TYPENAME .)
    STRING          reduce using rule 107 (USED_TYPENAME -> TYPENAME .)
    PLUS            reduce using rule 107 (USED_TYPENAME -> TYPENAME .)
    MINUS           reduce using rule 107 (USED_TYPENAME -> TYPENAME .)
    TIMES           reduce using rule 107 (USED_TYPENAME -> TYPENAME .)
    DIVIDE          reduce using rule 107 (USED_TYPENAME -> TYPENAME .)
    MODULO          reduce using rule 107 (USED_TYPENAME -> TYPENAME .)
    FPOW            reduce using rule 107 (USED_TYPENAME -> TYPENAME .)
    IPOW            reduce using rule 107 (USED_TYPENAME -> TYPENAME .)
    EQUALITY        reduce using rule 107 (USED_TYPENAME -> TYPENAME .)
    INEQUALITY      reduce using rule 107 (USED_TYPENAME -> TYPENAME .)
    LESS            reduce using rule 107 (USED_TYPENAME -> TYPENAME .)
    LEQ             reduce using rule 107 (USED_TYPENAME -> TYPENAME .)
    GREATER         reduce using rule 107 (USED_TYPENAME -> TYPENAME .)
    GEQ             reduce using rule 107 (USED_TYPENAME -> TYPENAME .)
    CONCAT          reduce using rule 107 (USED_TYPENAME -> TYPENAME .)
    AND             reduce using rule 107 (USED_TYPENAME -> TYPENAME .)
    OR              reduce using rule 107 (USED_TYPENAME -> TYPENAME .)
    TILDE           reduce using rule 107 (USED_TYPENAME -> TYPENAME .)
    WITH            reduce using rule 107 (USED_TYPENAME -> TYPENAME .)
    IF              reduce using rule 107 (USED_TYPENAME -> TYPENAME .)
    CLOSE_BRACE     reduce using rule 107 (USED_TYPENAME -> TYPENAME .)
    ENDSTATEMENT    reduce using rule 107 (USED_TYPENAME -> TYPENAME .)
    EQUALS          reduce using rule 107 (USED_TYPENAME -> TYPENAME .)
    ON              reduce using rule 107 (USED_TYPENAME -> TYPENAME .)
    ELSE            reduce using rule 107 (USED_TYPENAME -> TYPENAME .)
    CLOSE_PAREN     reduce using rule 107 (USED_TYPENAME -> TYPENAME .)
    GIVEN           reduce using rule 107 (USED_TYPENAME -> TYPENAME .)


state 88

    (43) RHS -> GDRHS WITH . DECLARATIONS
    (15) DECLARATIONS -> . OPEN_BRACE DECLARATIONS_LIST CLOSE_BRACE
    (16) DECLARATIONS -> . OPEN_BRACE CLOSE_BRACE

    OPEN_BRACE      shift and go to state 127

    DECLARATIONS                   shift and go to state 132

state 89

    (44) GDRHS -> GIVEN EXP . EQUALS EXP
    (45) GDRHS -> GIVEN EXP . EQUALS EXP GDRHS
    (57) IF_EXPR -> EXP . IF EXP ELSE EXP

    EQUALS          shift and go to state 133
    IF              shift and go to state 102


state 90

    (25) FIXITY_DECLARATION -> SETFIX ASSOCIATIVITY INTEGER . OP
    (81) OP -> . VARSYM
    (82) OP -> . INFIX_FUNCTION
    (86) VARSYM -> . PLUS
    (87) VARSYM -> . MINUS
    (88) VARSYM -> . TIMES
    (89) VARSYM -> . DIVIDE
    (90) VARSYM -> . MODULO
    (91) VARSYM -> . FPOW
    (92) VARSYM -> . IPOW
    (93) VARSYM -> . EQUALITY
    (94) VARSYM -> . INEQUALITY
    (95) VARSYM -> . LESS
    (96) VARSYM -> . LEQ
    (97) VARSYM -> . GREATER
    (98) VARSYM -> . GEQ
    (99) VARSYM -> . CONCAT
    (100) VARSYM -> . AND
    (101) VARSYM -> . OR
    (83) INFIX_FUNCTION -> . TILDE IDENTIFIER TILDE

    PLUS            shift and go to state 106
    MINUS           shift and go to state 107
    TIMES           shift and go to state 108
    DIVIDE          shift and go to state 109
    MODULO          shift and go to state 110
    FPOW            shift and go to state 111
    IPOW            shift and go to state 112
    EQUALITY        shift and go to state 113
    INEQUALITY      shift and go to state 114
    LESS            shift and go to state 115
    LEQ             shift and go to state 116
    GREATER         shift and go to state 117
    GEQ             shift and go to state 118
    CONCAT          shift and go to state 119
    AND             shift and go to state 120
    OR              shift and go to state 121
    TILDE           shift and go to state 58

    OP                             shift and go to state 134
    VARSYM                         shift and go to state 104
    INFIX_FUNCTION                 shift and go to state 105

state 91

    (36) FUNCTION_LHS -> IDENTIFIER APAT APATS .

    EQUALS          reduce using rule 36 (FUNCTION_LHS -> IDENTIFIER APAT APATS .)
    GIVEN           reduce using rule 36 (FUNCTION_LHS -> IDENTIFIER APAT APATS .)
    CLOSE_PAREN     reduce using rule 36 (FUNCTION_LHS -> IDENTIFIER APAT APATS .)


state 92

    (37) FUNCTION_LHS -> OPEN_PAREN FUNCTION_LHS CLOSE_PAREN . APAT APATS
    (77) APAT -> . PARAM
    (78) APAT -> . TYPENAME
    (79) APAT -> . LITERAL
    (80) APAT -> . OPEN_PAREN LPAT CLOSE_PAREN
    (108) PARAM -> . IDENTIFIER
    (102) LITERAL -> . FLOAT
    (103) LITERAL -> . INTEGER
    (104) LITERAL -> . BOOL
    (105) LITERAL -> . STRING

    TYPENAME        shift and go to state 40
    OPEN_PAREN      shift and go to state 43
    IDENTIFIER      shift and go to state 44
    FLOAT           shift and go to state 33
    INTEGER         shift and go to state 23
    BOOL            shift and go to state 34
    STRING          shift and go to state 12

    APAT                           shift and go to state 135
    PARAM                          shift and go to state 42
    LITERAL                        shift and go to state 31

state 93

    (80) APAT -> OPEN_PAREN LPAT CLOSE_PAREN .

    TILDE           reduce using rule 80 (APAT -> OPEN_PAREN LPAT CLOSE_PAREN .)
    TYPENAME        reduce using rule 80 (APAT -> OPEN_PAREN LPAT CLOSE_PAREN .)
    OPEN_PAREN      reduce using rule 80 (APAT -> OPEN_PAREN LPAT CLOSE_PAREN .)
    IDENTIFIER      reduce using rule 80 (APAT -> OPEN_PAREN LPAT CLOSE_PAREN .)
    FLOAT           reduce using rule 80 (APAT -> OPEN_PAREN LPAT CLOSE_PAREN .)
    INTEGER         reduce using rule 80 (APAT -> OPEN_PAREN LPAT CLOSE_PAREN .)
    BOOL            reduce using rule 80 (APAT -> OPEN_PAREN LPAT CLOSE_PAREN .)
    STRING          reduce using rule 80 (APAT -> OPEN_PAREN LPAT CLOSE_PAREN .)
    CLOSE_PAREN     reduce using rule 80 (APAT -> OPEN_PAREN LPAT CLOSE_PAREN .)
    EQUALS          reduce using rule 80 (APAT -> OPEN_PAREN LPAT CLOSE_PAREN .)
    GIVEN           reduce using rule 80 (APAT -> OPEN_PAREN LPAT CLOSE_PAREN .)
    ARROW           reduce using rule 80 (APAT -> OPEN_PAREN LPAT CLOSE_PAREN .)


state 94

    (39) INFIX_FUNCTION_DEFINITION -> LPAT INFIX_FUNCTION LPAT .

    EQUALS          reduce using rule 39 (INFIX_FUNCTION_DEFINITION -> LPAT INFIX_FUNCTION LPAT .)
    GIVEN           reduce using rule 39 (INFIX_FUNCTION_DEFINITION -> LPAT INFIX_FUNCTION LPAT .)
    CLOSE_PAREN     reduce using rule 39 (INFIX_FUNCTION_DEFINITION -> LPAT INFIX_FUNCTION LPAT .)


state 95

    (83) INFIX_FUNCTION -> TILDE IDENTIFIER . TILDE

    TILDE           shift and go to state 136


state 96

    (2) MODULE_BODY -> OPEN_BRACE IMPORT_STATEMENTS ENDSTATEMENT TOPLEVEL_DECLARATIONS CLOSE_BRACE .

    $end            reduce using rule 2 (MODULE_BODY -> OPEN_BRACE IMPORT_STATEMENTS ENDSTATEMENT TOPLEVEL_DECLARATIONS CLOSE_BRACE .)


state 97

    (14) CONSTRUCTOR -> TYPENAME . ATYPES
    (31) ATYPES -> . ATYPES ATYPE
    (32) ATYPES -> .

    TYPENAME        reduce using rule 32 (ATYPES -> .)
    IDENTIFIER      reduce using rule 32 (ATYPES -> .)
    OPEN_PAREN      reduce using rule 32 (ATYPES -> .)
    PIPE            reduce using rule 32 (ATYPES -> .)
    CLOSE_BRACE     reduce using rule 32 (ATYPES -> .)
    ENDSTATEMENT    reduce using rule 32 (ATYPES -> .)

    ATYPES                         shift and go to state 137

state 98

    (11) ADT_DECLARATION -> NEWTYPE TYPENAME EQUALS CONSTRUCTORS .
    (12) CONSTRUCTORS -> CONSTRUCTORS . PIPE CONSTRUCTOR

    CLOSE_BRACE     reduce using rule 11 (ADT_DECLARATION -> NEWTYPE TYPENAME EQUALS CONSTRUCTORS .)
    ENDSTATEMENT    reduce using rule 11 (ADT_DECLARATION -> NEWTYPE TYPENAME EQUALS CONSTRUCTORS .)
    PIPE            shift and go to state 138


state 99

    (13) CONSTRUCTORS -> CONSTRUCTOR .

    PIPE            reduce using rule 13 (CONSTRUCTORS -> CONSTRUCTOR .)
    CLOSE_BRACE     reduce using rule 13 (CONSTRUCTORS -> CONSTRUCTOR .)
    ENDSTATEMENT    reduce using rule 13 (CONSTRUCTORS -> CONSTRUCTOR .)


state 100

    (84) APATS -> APAT APATS .

    TILDE           reduce using rule 84 (APATS -> APAT APATS .)
    CLOSE_PAREN     reduce using rule 84 (APATS -> APAT APATS .)
    EQUALS          reduce using rule 84 (APATS -> APAT APATS .)
    GIVEN           reduce using rule 84 (APATS -> APAT APATS .)
    ARROW           reduce using rule 84 (APATS -> APAT APATS .)


state 101

    (41) RHS -> EQUALS EXP WITH . DECLARATIONS
    (15) DECLARATIONS -> . OPEN_BRACE DECLARATIONS_LIST CLOSE_BRACE
    (16) DECLARATIONS -> . OPEN_BRACE CLOSE_BRACE

    OPEN_BRACE      shift and go to state 127

    DECLARATIONS                   shift and go to state 139

state 102

    (57) IF_EXPR -> EXP IF . EXP ELSE EXP
    (46) EXP -> . INFIX_EXP
    (47) INFIX_EXP -> . LEXP OP INFIX_EXP
    (48) INFIX_EXP -> . MINUS INFIX_EXP
    (49) INFIX_EXP -> . LEXP
    (50) LEXP -> . LAMBDA_ABSTRACTION
    (51) LEXP -> . LET_EXPR
    (52) LEXP -> . IF_EXPR
    (53) LEXP -> . MATCH_EXPR
    (54) LEXP -> . FUNCTION_EXPR
    (55) LAMBDA_ABSTRACTION -> . LAMBDA APAT APATS ARROW EXP
    (56) LET_EXPR -> . LET DECLARATIONS IN EXP
    (57) IF_EXPR -> . EXP IF EXP ELSE EXP
    (58) MATCH_EXPR -> . MATCH EXP ON OPEN_BRACE ALTS CLOSE_BRACE
    (59) FUNCTION_EXPR -> . FUNCTION_EXPR AEXP
    (60) FUNCTION_EXPR -> . AEXP
    (61) AEXP -> . USED_VAR
    (62) AEXP -> . USED_TYPENAME
    (63) AEXP -> . LITERAL
    (64) AEXP -> . OPERATOR_FUNC
    (65) AEXP -> . OPEN_PAREN EXP CLOSE_PAREN
    (106) USED_VAR -> . IDENTIFIER
    (107) USED_TYPENAME -> . TYPENAME
    (102) LITERAL -> . FLOAT
    (103) LITERAL -> . INTEGER
    (104) LITERAL -> . BOOL
    (105) LITERAL -> . STRING
    (66) OPERATOR_FUNC -> . OPEN_PAREN OP CLOSE_PAREN

    MINUS           shift and go to state 71
    LAMBDA          shift and go to state 77
    LET             shift and go to state 78
    MATCH           shift and go to state 79
    OPEN_PAREN      shift and go to state 85
    IDENTIFIER      shift and go to state 86
    TYPENAME        shift and go to state 87
    FLOAT           shift and go to state 33
    INTEGER         shift and go to state 23
    BOOL            shift and go to state 34
    STRING          shift and go to state 12

    EXP                            shift and go to state 140
    INFIX_EXP                      shift and go to state 69
    LEXP                           shift and go to state 70
    LAMBDA_ABSTRACTION             shift and go to state 72
    LET_EXPR                       shift and go to state 73
    IF_EXPR                        shift and go to state 74
    MATCH_EXPR                     shift and go to state 75
    FUNCTION_EXPR                  shift and go to state 76
    AEXP                           shift and go to state 80
    USED_VAR                       shift and go to state 81
    USED_TYPENAME                  shift and go to state 82
    LITERAL                        shift and go to state 83
    OPERATOR_FUNC                  shift and go to state 84

state 103

    (47) INFIX_EXP -> LEXP OP . INFIX_EXP
    (47) INFIX_EXP -> . LEXP OP INFIX_EXP
    (48) INFIX_EXP -> . MINUS INFIX_EXP
    (49) INFIX_EXP -> . LEXP
    (50) LEXP -> . LAMBDA_ABSTRACTION
    (51) LEXP -> . LET_EXPR
    (52) LEXP -> . IF_EXPR
    (53) LEXP -> . MATCH_EXPR
    (54) LEXP -> . FUNCTION_EXPR
    (55) LAMBDA_ABSTRACTION -> . LAMBDA APAT APATS ARROW EXP
    (56) LET_EXPR -> . LET DECLARATIONS IN EXP
    (57) IF_EXPR -> . EXP IF EXP ELSE EXP
    (58) MATCH_EXPR -> . MATCH EXP ON OPEN_BRACE ALTS CLOSE_BRACE
    (59) FUNCTION_EXPR -> . FUNCTION_EXPR AEXP
    (60) FUNCTION_EXPR -> . AEXP
    (46) EXP -> . INFIX_EXP
    (61) AEXP -> . USED_VAR
    (62) AEXP -> . USED_TYPENAME
    (63) AEXP -> . LITERAL
    (64) AEXP -> . OPERATOR_FUNC
    (65) AEXP -> . OPEN_PAREN EXP CLOSE_PAREN
    (106) USED_VAR -> . IDENTIFIER
    (107) USED_TYPENAME -> . TYPENAME
    (102) LITERAL -> . FLOAT
    (103) LITERAL -> . INTEGER
    (104) LITERAL -> . BOOL
    (105) LITERAL -> . STRING
    (66) OPERATOR_FUNC -> . OPEN_PAREN OP CLOSE_PAREN

    MINUS           shift and go to state 71
    LAMBDA          shift and go to state 77
    LET             shift and go to state 78
    MATCH           shift and go to state 79
    OPEN_PAREN      shift and go to state 85
    IDENTIFIER      shift and go to state 86
    TYPENAME        shift and go to state 87
    FLOAT           shift and go to state 33
    INTEGER         shift and go to state 23
    BOOL            shift and go to state 34
    STRING          shift and go to state 12

    LEXP                           shift and go to state 70
    INFIX_EXP                      shift and go to state 141
    LAMBDA_ABSTRACTION             shift and go to state 72
    LET_EXPR                       shift and go to state 73
    IF_EXPR                        shift and go to state 74
    MATCH_EXPR                     shift and go to state 75
    FUNCTION_EXPR                  shift and go to state 76
    EXP                            shift and go to state 123
    AEXP                           shift and go to state 80
    USED_VAR                       shift and go to state 81
    USED_TYPENAME                  shift and go to state 82
    LITERAL                        shift and go to state 83
    OPERATOR_FUNC                  shift and go to state 84

state 104

    (81) OP -> VARSYM .

    MINUS           reduce using rule 81 (OP -> VARSYM .)
    LAMBDA          reduce using rule 81 (OP -> VARSYM .)
    LET             reduce using rule 81 (OP -> VARSYM .)
    MATCH           reduce using rule 81 (OP -> VARSYM .)
    OPEN_PAREN      reduce using rule 81 (OP -> VARSYM .)
    IDENTIFIER      reduce using rule 81 (OP -> VARSYM .)
    TYPENAME        reduce using rule 81 (OP -> VARSYM .)
    FLOAT           reduce using rule 81 (OP -> VARSYM .)
    INTEGER         reduce using rule 81 (OP -> VARSYM .)
    BOOL            reduce using rule 81 (OP -> VARSYM .)
    STRING          reduce using rule 81 (OP -> VARSYM .)
    CLOSE_PAREN     reduce using rule 81 (OP -> VARSYM .)
    CLOSE_BRACE     reduce using rule 81 (OP -> VARSYM .)
    ENDSTATEMENT    reduce using rule 81 (OP -> VARSYM .)


state 105

    (82) OP -> INFIX_FUNCTION .

    MINUS           reduce using rule 82 (OP -> INFIX_FUNCTION .)
    LAMBDA          reduce using rule 82 (OP -> INFIX_FUNCTION .)
    LET             reduce using rule 82 (OP -> INFIX_FUNCTION .)
    MATCH           reduce using rule 82 (OP -> INFIX_FUNCTION .)
    OPEN_PAREN      reduce using rule 82 (OP -> INFIX_FUNCTION .)
    IDENTIFIER      reduce using rule 82 (OP -> INFIX_FUNCTION .)
    TYPENAME        reduce using rule 82 (OP -> INFIX_FUNCTION .)
    FLOAT           reduce using rule 82 (OP -> INFIX_FUNCTION .)
    INTEGER         reduce using rule 82 (OP -> INFIX_FUNCTION .)
    BOOL            reduce using rule 82 (OP -> INFIX_FUNCTION .)
    STRING          reduce using rule 82 (OP -> INFIX_FUNCTION .)
    CLOSE_PAREN     reduce using rule 82 (OP -> INFIX_FUNCTION .)
    CLOSE_BRACE     reduce using rule 82 (OP -> INFIX_FUNCTION .)
    ENDSTATEMENT    reduce using rule 82 (OP -> INFIX_FUNCTION .)


state 106

    (86) VARSYM -> PLUS .

    MINUS           reduce using rule 86 (VARSYM -> PLUS .)
    LAMBDA          reduce using rule 86 (VARSYM -> PLUS .)
    LET             reduce using rule 86 (VARSYM -> PLUS .)
    MATCH           reduce using rule 86 (VARSYM -> PLUS .)
    OPEN_PAREN      reduce using rule 86 (VARSYM -> PLUS .)
    IDENTIFIER      reduce using rule 86 (VARSYM -> PLUS .)
    TYPENAME        reduce using rule 86 (VARSYM -> PLUS .)
    FLOAT           reduce using rule 86 (VARSYM -> PLUS .)
    INTEGER         reduce using rule 86 (VARSYM -> PLUS .)
    BOOL            reduce using rule 86 (VARSYM -> PLUS .)
    STRING          reduce using rule 86 (VARSYM -> PLUS .)
    CLOSE_PAREN     reduce using rule 86 (VARSYM -> PLUS .)
    CLOSE_BRACE     reduce using rule 86 (VARSYM -> PLUS .)
    ENDSTATEMENT    reduce using rule 86 (VARSYM -> PLUS .)


state 107

    (87) VARSYM -> MINUS .

    MINUS           reduce using rule 87 (VARSYM -> MINUS .)
    LAMBDA          reduce using rule 87 (VARSYM -> MINUS .)
    LET             reduce using rule 87 (VARSYM -> MINUS .)
    MATCH           reduce using rule 87 (VARSYM -> MINUS .)
    OPEN_PAREN      reduce using rule 87 (VARSYM -> MINUS .)
    IDENTIFIER      reduce using rule 87 (VARSYM -> MINUS .)
    TYPENAME        reduce using rule 87 (VARSYM -> MINUS .)
    FLOAT           reduce using rule 87 (VARSYM -> MINUS .)
    INTEGER         reduce using rule 87 (VARSYM -> MINUS .)
    BOOL            reduce using rule 87 (VARSYM -> MINUS .)
    STRING          reduce using rule 87 (VARSYM -> MINUS .)
    CLOSE_BRACE     reduce using rule 87 (VARSYM -> MINUS .)
    ENDSTATEMENT    reduce using rule 87 (VARSYM -> MINUS .)


state 108

    (88) VARSYM -> TIMES .

    MINUS           reduce using rule 88 (VARSYM -> TIMES .)
    LAMBDA          reduce using rule 88 (VARSYM -> TIMES .)
    LET             reduce using rule 88 (VARSYM -> TIMES .)
    MATCH           reduce using rule 88 (VARSYM -> TIMES .)
    OPEN_PAREN      reduce using rule 88 (VARSYM -> TIMES .)
    IDENTIFIER      reduce using rule 88 (VARSYM -> TIMES .)
    TYPENAME        reduce using rule 88 (VARSYM -> TIMES .)
    FLOAT           reduce using rule 88 (VARSYM -> TIMES .)
    INTEGER         reduce using rule 88 (VARSYM -> TIMES .)
    BOOL            reduce using rule 88 (VARSYM -> TIMES .)
    STRING          reduce using rule 88 (VARSYM -> TIMES .)
    CLOSE_PAREN     reduce using rule 88 (VARSYM -> TIMES .)
    CLOSE_BRACE     reduce using rule 88 (VARSYM -> TIMES .)
    ENDSTATEMENT    reduce using rule 88 (VARSYM -> TIMES .)


state 109

    (89) VARSYM -> DIVIDE .

    MINUS           reduce using rule 89 (VARSYM -> DIVIDE .)
    LAMBDA          reduce using rule 89 (VARSYM -> DIVIDE .)
    LET             reduce using rule 89 (VARSYM -> DIVIDE .)
    MATCH           reduce using rule 89 (VARSYM -> DIVIDE .)
    OPEN_PAREN      reduce using rule 89 (VARSYM -> DIVIDE .)
    IDENTIFIER      reduce using rule 89 (VARSYM -> DIVIDE .)
    TYPENAME        reduce using rule 89 (VARSYM -> DIVIDE .)
    FLOAT           reduce using rule 89 (VARSYM -> DIVIDE .)
    INTEGER         reduce using rule 89 (VARSYM -> DIVIDE .)
    BOOL            reduce using rule 89 (VARSYM -> DIVIDE .)
    STRING          reduce using rule 89 (VARSYM -> DIVIDE .)
    CLOSE_PAREN     reduce using rule 89 (VARSYM -> DIVIDE .)
    CLOSE_BRACE     reduce using rule 89 (VARSYM -> DIVIDE .)
    ENDSTATEMENT    reduce using rule 89 (VARSYM -> DIVIDE .)


state 110

    (90) VARSYM -> MODULO .

    MINUS           reduce using rule 90 (VARSYM -> MODULO .)
    LAMBDA          reduce using rule 90 (VARSYM -> MODULO .)
    LET             reduce using rule 90 (VARSYM -> MODULO .)
    MATCH           reduce using rule 90 (VARSYM -> MODULO .)
    OPEN_PAREN      reduce using rule 90 (VARSYM -> MODULO .)
    IDENTIFIER      reduce using rule 90 (VARSYM -> MODULO .)
    TYPENAME        reduce using rule 90 (VARSYM -> MODULO .)
    FLOAT           reduce using rule 90 (VARSYM -> MODULO .)
    INTEGER         reduce using rule 90 (VARSYM -> MODULO .)
    BOOL            reduce using rule 90 (VARSYM -> MODULO .)
    STRING          reduce using rule 90 (VARSYM -> MODULO .)
    CLOSE_PAREN     reduce using rule 90 (VARSYM -> MODULO .)
    CLOSE_BRACE     reduce using rule 90 (VARSYM -> MODULO .)
    ENDSTATEMENT    reduce using rule 90 (VARSYM -> MODULO .)


state 111

    (91) VARSYM -> FPOW .

    MINUS           reduce using rule 91 (VARSYM -> FPOW .)
    LAMBDA          reduce using rule 91 (VARSYM -> FPOW .)
    LET             reduce using rule 91 (VARSYM -> FPOW .)
    MATCH           reduce using rule 91 (VARSYM -> FPOW .)
    OPEN_PAREN      reduce using rule 91 (VARSYM -> FPOW .)
    IDENTIFIER      reduce using rule 91 (VARSYM -> FPOW .)
    TYPENAME        reduce using rule 91 (VARSYM -> FPOW .)
    FLOAT           reduce using rule 91 (VARSYM -> FPOW .)
    INTEGER         reduce using rule 91 (VARSYM -> FPOW .)
    BOOL            reduce using rule 91 (VARSYM -> FPOW .)
    STRING          reduce using rule 91 (VARSYM -> FPOW .)
    CLOSE_PAREN     reduce using rule 91 (VARSYM -> FPOW .)
    CLOSE_BRACE     reduce using rule 91 (VARSYM -> FPOW .)
    ENDSTATEMENT    reduce using rule 91 (VARSYM -> FPOW .)


state 112

    (92) VARSYM -> IPOW .

    MINUS           reduce using rule 92 (VARSYM -> IPOW .)
    LAMBDA          reduce using rule 92 (VARSYM -> IPOW .)
    LET             reduce using rule 92 (VARSYM -> IPOW .)
    MATCH           reduce using rule 92 (VARSYM -> IPOW .)
    OPEN_PAREN      reduce using rule 92 (VARSYM -> IPOW .)
    IDENTIFIER      reduce using rule 92 (VARSYM -> IPOW .)
    TYPENAME        reduce using rule 92 (VARSYM -> IPOW .)
    FLOAT           reduce using rule 92 (VARSYM -> IPOW .)
    INTEGER         reduce using rule 92 (VARSYM -> IPOW .)
    BOOL            reduce using rule 92 (VARSYM -> IPOW .)
    STRING          reduce using rule 92 (VARSYM -> IPOW .)
    CLOSE_PAREN     reduce using rule 92 (VARSYM -> IPOW .)
    CLOSE_BRACE     reduce using rule 92 (VARSYM -> IPOW .)
    ENDSTATEMENT    reduce using rule 92 (VARSYM -> IPOW .)


state 113

    (93) VARSYM -> EQUALITY .

    MINUS           reduce using rule 93 (VARSYM -> EQUALITY .)
    LAMBDA          reduce using rule 93 (VARSYM -> EQUALITY .)
    LET             reduce using rule 93 (VARSYM -> EQUALITY .)
    MATCH           reduce using rule 93 (VARSYM -> EQUALITY .)
    OPEN_PAREN      reduce using rule 93 (VARSYM -> EQUALITY .)
    IDENTIFIER      reduce using rule 93 (VARSYM -> EQUALITY .)
    TYPENAME        reduce using rule 93 (VARSYM -> EQUALITY .)
    FLOAT           reduce using rule 93 (VARSYM -> EQUALITY .)
    INTEGER         reduce using rule 93 (VARSYM -> EQUALITY .)
    BOOL            reduce using rule 93 (VARSYM -> EQUALITY .)
    STRING          reduce using rule 93 (VARSYM -> EQUALITY .)
    CLOSE_PAREN     reduce using rule 93 (VARSYM -> EQUALITY .)
    CLOSE_BRACE     reduce using rule 93 (VARSYM -> EQUALITY .)
    ENDSTATEMENT    reduce using rule 93 (VARSYM -> EQUALITY .)


state 114

    (94) VARSYM -> INEQUALITY .

    MINUS           reduce using rule 94 (VARSYM -> INEQUALITY .)
    LAMBDA          reduce using rule 94 (VARSYM -> INEQUALITY .)
    LET             reduce using rule 94 (VARSYM -> INEQUALITY .)
    MATCH           reduce using rule 94 (VARSYM -> INEQUALITY .)
    OPEN_PAREN      reduce using rule 94 (VARSYM -> INEQUALITY .)
    IDENTIFIER      reduce using rule 94 (VARSYM -> INEQUALITY .)
    TYPENAME        reduce using rule 94 (VARSYM -> INEQUALITY .)
    FLOAT           reduce using rule 94 (VARSYM -> INEQUALITY .)
    INTEGER         reduce using rule 94 (VARSYM -> INEQUALITY .)
    BOOL            reduce using rule 94 (VARSYM -> INEQUALITY .)
    STRING          reduce using rule 94 (VARSYM -> INEQUALITY .)
    CLOSE_PAREN     reduce using rule 94 (VARSYM -> INEQUALITY .)
    CLOSE_BRACE     reduce using rule 94 (VARSYM -> INEQUALITY .)
    ENDSTATEMENT    reduce using rule 94 (VARSYM -> INEQUALITY .)


state 115

    (95) VARSYM -> LESS .

    MINUS           reduce using rule 95 (VARSYM -> LESS .)
    LAMBDA          reduce using rule 95 (VARSYM -> LESS .)
    LET             reduce using rule 95 (VARSYM -> LESS .)
    MATCH           reduce using rule 95 (VARSYM -> LESS .)
    OPEN_PAREN      reduce using rule 95 (VARSYM -> LESS .)
    IDENTIFIER      reduce using rule 95 (VARSYM -> LESS .)
    TYPENAME        reduce using rule 95 (VARSYM -> LESS .)
    FLOAT           reduce using rule 95 (VARSYM -> LESS .)
    INTEGER         reduce using rule 95 (VARSYM -> LESS .)
    BOOL            reduce using rule 95 (VARSYM -> LESS .)
    STRING          reduce using rule 95 (VARSYM -> LESS .)
    CLOSE_PAREN     reduce using rule 95 (VARSYM -> LESS .)
    CLOSE_BRACE     reduce using rule 95 (VARSYM -> LESS .)
    ENDSTATEMENT    reduce using rule 95 (VARSYM -> LESS .)


state 116

    (96) VARSYM -> LEQ .

    MINUS           reduce using rule 96 (VARSYM -> LEQ .)
    LAMBDA          reduce using rule 96 (VARSYM -> LEQ .)
    LET             reduce using rule 96 (VARSYM -> LEQ .)
    MATCH           reduce using rule 96 (VARSYM -> LEQ .)
    OPEN_PAREN      reduce using rule 96 (VARSYM -> LEQ .)
    IDENTIFIER      reduce using rule 96 (VARSYM -> LEQ .)
    TYPENAME        reduce using rule 96 (VARSYM -> LEQ .)
    FLOAT           reduce using rule 96 (VARSYM -> LEQ .)
    INTEGER         reduce using rule 96 (VARSYM -> LEQ .)
    BOOL            reduce using rule 96 (VARSYM -> LEQ .)
    STRING          reduce using rule 96 (VARSYM -> LEQ .)
    CLOSE_PAREN     reduce using rule 96 (VARSYM -> LEQ .)
    CLOSE_BRACE     reduce using rule 96 (VARSYM -> LEQ .)
    ENDSTATEMENT    reduce using rule 96 (VARSYM -> LEQ .)


state 117

    (97) VARSYM -> GREATER .

    MINUS           reduce using rule 97 (VARSYM -> GREATER .)
    LAMBDA          reduce using rule 97 (VARSYM -> GREATER .)
    LET             reduce using rule 97 (VARSYM -> GREATER .)
    MATCH           reduce using rule 97 (VARSYM -> GREATER .)
    OPEN_PAREN      reduce using rule 97 (VARSYM -> GREATER .)
    IDENTIFIER      reduce using rule 97 (VARSYM -> GREATER .)
    TYPENAME        reduce using rule 97 (VARSYM -> GREATER .)
    FLOAT           reduce using rule 97 (VARSYM -> GREATER .)
    INTEGER         reduce using rule 97 (VARSYM -> GREATER .)
    BOOL            reduce using rule 97 (VARSYM -> GREATER .)
    STRING          reduce using rule 97 (VARSYM -> GREATER .)
    CLOSE_PAREN     reduce using rule 97 (VARSYM -> GREATER .)
    CLOSE_BRACE     reduce using rule 97 (VARSYM -> GREATER .)
    ENDSTATEMENT    reduce using rule 97 (VARSYM -> GREATER .)


state 118

    (98) VARSYM -> GEQ .

    MINUS           reduce using rule 98 (VARSYM -> GEQ .)
    LAMBDA          reduce using rule 98 (VARSYM -> GEQ .)
    LET             reduce using rule 98 (VARSYM -> GEQ .)
    MATCH           reduce using rule 98 (VARSYM -> GEQ .)
    OPEN_PAREN      reduce using rule 98 (VARSYM -> GEQ .)
    IDENTIFIER      reduce using rule 98 (VARSYM -> GEQ .)
    TYPENAME        reduce using rule 98 (VARSYM -> GEQ .)
    FLOAT           reduce using rule 98 (VARSYM -> GEQ .)
    INTEGER         reduce using rule 98 (VARSYM -> GEQ .)
    BOOL            reduce using rule 98 (VARSYM -> GEQ .)
    STRING          reduce using rule 98 (VARSYM -> GEQ .)
    CLOSE_PAREN     reduce using rule 98 (VARSYM -> GEQ .)
    CLOSE_BRACE     reduce using rule 98 (VARSYM -> GEQ .)
    ENDSTATEMENT    reduce using rule 98 (VARSYM -> GEQ .)


state 119

    (99) VARSYM -> CONCAT .

    MINUS           reduce using rule 99 (VARSYM -> CONCAT .)
    LAMBDA          reduce using rule 99 (VARSYM -> CONCAT .)
    LET             reduce using rule 99 (VARSYM -> CONCAT .)
    MATCH           reduce using rule 99 (VARSYM -> CONCAT .)
    OPEN_PAREN      reduce using rule 99 (VARSYM -> CONCAT .)
    IDENTIFIER      reduce using rule 99 (VARSYM -> CONCAT .)
    TYPENAME        reduce using rule 99 (VARSYM -> CONCAT .)
    FLOAT           reduce using rule 99 (VARSYM -> CONCAT .)
    INTEGER         reduce using rule 99 (VARSYM -> CONCAT .)
    BOOL            reduce using rule 99 (VARSYM -> CONCAT .)
    STRING          reduce using rule 99 (VARSYM -> CONCAT .)
    CLOSE_PAREN     reduce using rule 99 (VARSYM -> CONCAT .)
    CLOSE_BRACE     reduce using rule 99 (VARSYM -> CONCAT .)
    ENDSTATEMENT    reduce using rule 99 (VARSYM -> CONCAT .)


state 120

    (100) VARSYM -> AND .

    MINUS           reduce using rule 100 (VARSYM -> AND .)
    LAMBDA          reduce using rule 100 (VARSYM -> AND .)
    LET             reduce using rule 100 (VARSYM -> AND .)
    MATCH           reduce using rule 100 (VARSYM -> AND .)
    OPEN_PAREN      reduce using rule 100 (VARSYM -> AND .)
    IDENTIFIER      reduce using rule 100 (VARSYM -> AND .)
    TYPENAME        reduce using rule 100 (VARSYM -> AND .)
    FLOAT           reduce using rule 100 (VARSYM -> AND .)
    INTEGER         reduce using rule 100 (VARSYM -> AND .)
    BOOL            reduce using rule 100 (VARSYM -> AND .)
    STRING          reduce using rule 100 (VARSYM -> AND .)
    CLOSE_PAREN     reduce using rule 100 (VARSYM -> AND .)
    CLOSE_BRACE     reduce using rule 100 (VARSYM -> AND .)
    ENDSTATEMENT    reduce using rule 100 (VARSYM -> AND .)


state 121

    (101) VARSYM -> OR .

    MINUS           reduce using rule 101 (VARSYM -> OR .)
    LAMBDA          reduce using rule 101 (VARSYM -> OR .)
    LET             reduce using rule 101 (VARSYM -> OR .)
    MATCH           reduce using rule 101 (VARSYM -> OR .)
    OPEN_PAREN      reduce using rule 101 (VARSYM -> OR .)
    IDENTIFIER      reduce using rule 101 (VARSYM -> OR .)
    TYPENAME        reduce using rule 101 (VARSYM -> OR .)
    FLOAT           reduce using rule 101 (VARSYM -> OR .)
    INTEGER         reduce using rule 101 (VARSYM -> OR .)
    BOOL            reduce using rule 101 (VARSYM -> OR .)
    STRING          reduce using rule 101 (VARSYM -> OR .)
    CLOSE_PAREN     reduce using rule 101 (VARSYM -> OR .)
    CLOSE_BRACE     reduce using rule 101 (VARSYM -> OR .)
    ENDSTATEMENT    reduce using rule 101 (VARSYM -> OR .)


state 122

    (48) INFIX_EXP -> MINUS INFIX_EXP .
    (46) EXP -> INFIX_EXP .

  ! reduce/reduce conflict for IF resolved using rule 46 (EXP -> INFIX_EXP .)
    WITH            reduce using rule 48 (INFIX_EXP -> MINUS INFIX_EXP .)
    CLOSE_BRACE     reduce using rule 48 (INFIX_EXP -> MINUS INFIX_EXP .)
    ENDSTATEMENT    reduce using rule 48 (INFIX_EXP -> MINUS INFIX_EXP .)
    EQUALS          reduce using rule 48 (INFIX_EXP -> MINUS INFIX_EXP .)
    ON              reduce using rule 48 (INFIX_EXP -> MINUS INFIX_EXP .)
    ELSE            reduce using rule 48 (INFIX_EXP -> MINUS INFIX_EXP .)
    CLOSE_PAREN     reduce using rule 48 (INFIX_EXP -> MINUS INFIX_EXP .)
    GIVEN           reduce using rule 48 (INFIX_EXP -> MINUS INFIX_EXP .)
    PLUS            reduce using rule 48 (INFIX_EXP -> MINUS INFIX_EXP .)
    MINUS           reduce using rule 48 (INFIX_EXP -> MINUS INFIX_EXP .)
    TIMES           reduce using rule 48 (INFIX_EXP -> MINUS INFIX_EXP .)
    DIVIDE          reduce using rule 48 (INFIX_EXP -> MINUS INFIX_EXP .)
    MODULO          reduce using rule 48 (INFIX_EXP -> MINUS INFIX_EXP .)
    FPOW            reduce using rule 48 (INFIX_EXP -> MINUS INFIX_EXP .)
    IPOW            reduce using rule 48 (INFIX_EXP -> MINUS INFIX_EXP .)
    EQUALITY        reduce using rule 48 (INFIX_EXP -> MINUS INFIX_EXP .)
    INEQUALITY      reduce using rule 48 (INFIX_EXP -> MINUS INFIX_EXP .)
    LESS            reduce using rule 48 (INFIX_EXP -> MINUS INFIX_EXP .)
    LEQ             reduce using rule 48 (INFIX_EXP -> MINUS INFIX_EXP .)
    GREATER         reduce using rule 48 (INFIX_EXP -> MINUS INFIX_EXP .)
    GEQ             reduce using rule 48 (INFIX_EXP -> MINUS INFIX_EXP .)
    CONCAT          reduce using rule 48 (INFIX_EXP -> MINUS INFIX_EXP .)
    AND             reduce using rule 48 (INFIX_EXP -> MINUS INFIX_EXP .)
    OR              reduce using rule 48 (INFIX_EXP -> MINUS INFIX_EXP .)
    TILDE           reduce using rule 48 (INFIX_EXP -> MINUS INFIX_EXP .)
    IF              reduce using rule 46 (EXP -> INFIX_EXP .)

  ! IF              [ reduce using rule 48 (INFIX_EXP -> MINUS INFIX_EXP .) ]


state 123

    (57) IF_EXPR -> EXP . IF EXP ELSE EXP

    IF              shift and go to state 102


state 124

    (59) FUNCTION_EXPR -> FUNCTION_EXPR AEXP .

    OPEN_PAREN      reduce using rule 59 (FUNCTION_EXPR -> FUNCTION_EXPR AEXP .)
    IDENTIFIER      reduce using rule 59 (FUNCTION_EXPR -> FUNCTION_EXPR AEXP .)
    TYPENAME        reduce using rule 59 (FUNCTION_EXPR -> FUNCTION_EXPR AEXP .)
    FLOAT           reduce using rule 59 (FUNCTION_EXPR -> FUNCTION_EXPR AEXP .)
    INTEGER         reduce using rule 59 (FUNCTION_EXPR -> FUNCTION_EXPR AEXP .)
    BOOL            reduce using rule 59 (FUNCTION_EXPR -> FUNCTION_EXPR AEXP .)
    STRING          reduce using rule 59 (FUNCTION_EXPR -> FUNCTION_EXPR AEXP .)
    PLUS            reduce using rule 59 (FUNCTION_EXPR -> FUNCTION_EXPR AEXP .)
    MINUS           reduce using rule 59 (FUNCTION_EXPR -> FUNCTION_EXPR AEXP .)
    TIMES           reduce using rule 59 (FUNCTION_EXPR -> FUNCTION_EXPR AEXP .)
    DIVIDE          reduce using rule 59 (FUNCTION_EXPR -> FUNCTION_EXPR AEXP .)
    MODULO          reduce using rule 59 (FUNCTION_EXPR -> FUNCTION_EXPR AEXP .)
    FPOW            reduce using rule 59 (FUNCTION_EXPR -> FUNCTION_EXPR AEXP .)
    IPOW            reduce using rule 59 (FUNCTION_EXPR -> FUNCTION_EXPR AEXP .)
    EQUALITY        reduce using rule 59 (FUNCTION_EXPR -> FUNCTION_EXPR AEXP .)
    INEQUALITY      reduce using rule 59 (FUNCTION_EXPR -> FUNCTION_EXPR AEXP .)
    LESS            reduce using rule 59 (FUNCTION_EXPR -> FUNCTION_EXPR AEXP .)
    LEQ             reduce using rule 59 (FUNCTION_EXPR -> FUNCTION_EXPR AEXP .)
    GREATER         reduce using rule 59 (FUNCTION_EXPR -> FUNCTION_EXPR AEXP .)
    GEQ             reduce using rule 59 (FUNCTION_EXPR -> FUNCTION_EXPR AEXP .)
    CONCAT          reduce using rule 59 (FUNCTION_EXPR -> FUNCTION_EXPR AEXP .)
    AND             reduce using rule 59 (FUNCTION_EXPR -> FUNCTION_EXPR AEXP .)
    OR              reduce using rule 59 (FUNCTION_EXPR -> FUNCTION_EXPR AEXP .)
    TILDE           reduce using rule 59 (FUNCTION_EXPR -> FUNCTION_EXPR AEXP .)
    WITH            reduce using rule 59 (FUNCTION_EXPR -> FUNCTION_EXPR AEXP .)
    IF              reduce using rule 59 (FUNCTION_EXPR -> FUNCTION_EXPR AEXP .)
    CLOSE_BRACE     reduce using rule 59 (FUNCTION_EXPR -> FUNCTION_EXPR AEXP .)
    ENDSTATEMENT    reduce using rule 59 (FUNCTION_EXPR -> FUNCTION_EXPR AEXP .)
    EQUALS          reduce using rule 59 (FUNCTION_EXPR -> FUNCTION_EXPR AEXP .)
    ON              reduce using rule 59 (FUNCTION_EXPR -> FUNCTION_EXPR AEXP .)
    ELSE            reduce using rule 59 (FUNCTION_EXPR -> FUNCTION_EXPR AEXP .)
    CLOSE_PAREN     reduce using rule 59 (FUNCTION_EXPR -> FUNCTION_EXPR AEXP .)
    GIVEN           reduce using rule 59 (FUNCTION_EXPR -> FUNCTION_EXPR AEXP .)


state 125

    (55) LAMBDA_ABSTRACTION -> LAMBDA APAT . APATS ARROW EXP
    (84) APATS -> . APAT APATS
    (85) APATS -> .
    (77) APAT -> . PARAM
    (78) APAT -> . TYPENAME
    (79) APAT -> . LITERAL
    (80) APAT -> . OPEN_PAREN LPAT CLOSE_PAREN
    (108) PARAM -> . IDENTIFIER
    (102) LITERAL -> . FLOAT
    (103) LITERAL -> . INTEGER
    (104) LITERAL -> . BOOL
    (105) LITERAL -> . STRING

    ARROW           reduce using rule 85 (APATS -> .)
    TYPENAME        shift and go to state 40
    OPEN_PAREN      shift and go to state 43
    IDENTIFIER      shift and go to state 44
    FLOAT           shift and go to state 33
    INTEGER         shift and go to state 23
    BOOL            shift and go to state 34
    STRING          shift and go to state 12

    APAT                           shift and go to state 65
    APATS                          shift and go to state 142
    PARAM                          shift and go to state 42
    LITERAL                        shift and go to state 31

state 126

    (56) LET_EXPR -> LET DECLARATIONS . IN EXP

    IN              shift and go to state 143


state 127

    (15) DECLARATIONS -> OPEN_BRACE . DECLARATIONS_LIST CLOSE_BRACE
    (16) DECLARATIONS -> OPEN_BRACE . CLOSE_BRACE
    (17) DECLARATIONS_LIST -> . DECLARATION ENDSTATEMENT DECLARATIONS_LIST
    (18) DECLARATIONS_LIST -> . DECLARATION
    (19) DECLARATION -> . FUNCTION_DEFINITION
    (20) DECLARATION -> . VARIABLE_DEFINITION
    (21) DECLARATION -> . FIXITY_DECLARATION
    (22) DECLARATION -> .
    (23) FUNCTION_DEFINITION -> . FUNCTION_LHS RHS
    (24) VARIABLE_DEFINITION -> . PARAM RHS
    (25) FIXITY_DECLARATION -> . SETFIX ASSOCIATIVITY INTEGER OP
    (36) FUNCTION_LHS -> . IDENTIFIER APAT APATS
    (37) FUNCTION_LHS -> . OPEN_PAREN FUNCTION_LHS CLOSE_PAREN APAT APATS
    (38) FUNCTION_LHS -> . INFIX_FUNCTION_DEFINITION
    (108) PARAM -> . IDENTIFIER
    (39) INFIX_FUNCTION_DEFINITION -> . LPAT INFIX_FUNCTION LPAT
    (71) LPAT -> . APAT
    (72) LPAT -> . CONSTRUCTOR_PATTERN
    (73) LPAT -> . NEGATIVE_LITERAL
    (77) APAT -> . PARAM
    (78) APAT -> . TYPENAME
    (79) APAT -> . LITERAL
    (80) APAT -> . OPEN_PAREN LPAT CLOSE_PAREN
    (74) CONSTRUCTOR_PATTERN -> . TYPENAME APAT APATS
    (75) NEGATIVE_LITERAL -> . MINUS INTEGER
    (76) NEGATIVE_LITERAL -> . MINUS FLOAT
    (102) LITERAL -> . FLOAT
    (103) LITERAL -> . INTEGER
    (104) LITERAL -> . BOOL
    (105) LITERAL -> . STRING

  ! shift/reduce conflict for CLOSE_BRACE resolved as shift
    CLOSE_BRACE     shift and go to state 145
    ENDSTATEMENT    reduce using rule 22 (DECLARATION -> .)
    SETFIX          shift and go to state 22
    IDENTIFIER      shift and go to state 24
    OPEN_PAREN      shift and go to state 26
    TYPENAME        shift and go to state 16
    MINUS           shift and go to state 32
    FLOAT           shift and go to state 33
    INTEGER         shift and go to state 23
    BOOL            shift and go to state 34
    STRING          shift and go to state 12

  ! CLOSE_BRACE     [ reduce using rule 22 (DECLARATION -> .) ]

    DECLARATIONS_LIST              shift and go to state 144
    DECLARATION                    shift and go to state 146
    FUNCTION_DEFINITION            shift and go to state 17
    VARIABLE_DEFINITION            shift and go to state 18
    FIXITY_DECLARATION             shift and go to state 19
    FUNCTION_LHS                   shift and go to state 20
    PARAM                          shift and go to state 21
    APAT                           shift and go to state 25
    INFIX_FUNCTION_DEFINITION      shift and go to state 27
    LPAT                           shift and go to state 28
    CONSTRUCTOR_PATTERN            shift and go to state 29
    NEGATIVE_LITERAL               shift and go to state 30
    LITERAL                        shift and go to state 31

state 128

    (58) MATCH_EXPR -> MATCH EXP . ON OPEN_BRACE ALTS CLOSE_BRACE
    (57) IF_EXPR -> EXP . IF EXP ELSE EXP

    ON              shift and go to state 147
    IF              shift and go to state 102


state 129

    (65) AEXP -> OPEN_PAREN EXP . CLOSE_PAREN
    (57) IF_EXPR -> EXP . IF EXP ELSE EXP

    CLOSE_PAREN     shift and go to state 148
    IF              shift and go to state 102


state 130

    (66) OPERATOR_FUNC -> OPEN_PAREN OP . CLOSE_PAREN

    CLOSE_PAREN     shift and go to state 149


state 131

    (48) INFIX_EXP -> MINUS . INFIX_EXP
    (87) VARSYM -> MINUS .
    (47) INFIX_EXP -> . LEXP OP INFIX_EXP
    (48) INFIX_EXP -> . MINUS INFIX_EXP
    (49) INFIX_EXP -> . LEXP
    (50) LEXP -> . LAMBDA_ABSTRACTION
    (51) LEXP -> . LET_EXPR
    (52) LEXP -> . IF_EXPR
    (53) LEXP -> . MATCH_EXPR
    (54) LEXP -> . FUNCTION_EXPR
    (55) LAMBDA_ABSTRACTION -> . LAMBDA APAT APATS ARROW EXP
    (56) LET_EXPR -> . LET DECLARATIONS IN EXP
    (57) IF_EXPR -> . EXP IF EXP ELSE EXP
    (58) MATCH_EXPR -> . MATCH EXP ON OPEN_BRACE ALTS CLOSE_BRACE
    (59) FUNCTION_EXPR -> . FUNCTION_EXPR AEXP
    (60) FUNCTION_EXPR -> . AEXP
    (46) EXP -> . INFIX_EXP
    (61) AEXP -> . USED_VAR
    (62) AEXP -> . USED_TYPENAME
    (63) AEXP -> . LITERAL
    (64) AEXP -> . OPERATOR_FUNC
    (65) AEXP -> . OPEN_PAREN EXP CLOSE_PAREN
    (106) USED_VAR -> . IDENTIFIER
    (107) USED_TYPENAME -> . TYPENAME
    (102) LITERAL -> . FLOAT
    (103) LITERAL -> . INTEGER
    (104) LITERAL -> . BOOL
    (105) LITERAL -> . STRING
    (66) OPERATOR_FUNC -> . OPEN_PAREN OP CLOSE_PAREN

    CLOSE_PAREN     reduce using rule 87 (VARSYM -> MINUS .)
    MINUS           shift and go to state 71
    LAMBDA          shift and go to state 77
    LET             shift and go to state 78
    MATCH           shift and go to state 79
    OPEN_PAREN      shift and go to state 85
    IDENTIFIER      shift and go to state 86
    TYPENAME        shift and go to state 87
    FLOAT           shift and go to state 33
    INTEGER         shift and go to state 23
    BOOL            shift and go to state 34
    STRING          shift and go to state 12

    INFIX_EXP                      shift and go to state 122
    LEXP                           shift and go to state 70
    LAMBDA_ABSTRACTION             shift and go to state 72
    LET_EXPR                       shift and go to state 73
    IF_EXPR                        shift and go to state 74
    MATCH_EXPR                     shift and go to state 75
    FUNCTION_EXPR                  shift and go to state 76
    EXP                            shift and go to state 123
    AEXP                           shift and go to state 80
    USED_VAR                       shift and go to state 81
    USED_TYPENAME                  shift and go to state 82
    LITERAL                        shift and go to state 83
    OPERATOR_FUNC                  shift and go to state 84

state 132

    (43) RHS -> GDRHS WITH DECLARATIONS .

    CLOSE_BRACE     reduce using rule 43 (RHS -> GDRHS WITH DECLARATIONS .)
    ENDSTATEMENT    reduce using rule 43 (RHS -> GDRHS WITH DECLARATIONS .)


state 133

    (44) GDRHS -> GIVEN EXP EQUALS . EXP
    (45) GDRHS -> GIVEN EXP EQUALS . EXP GDRHS
    (46) EXP -> . INFIX_EXP
    (47) INFIX_EXP -> . LEXP OP INFIX_EXP
    (48) INFIX_EXP -> . MINUS INFIX_EXP
    (49) INFIX_EXP -> . LEXP
    (50) LEXP -> . LAMBDA_ABSTRACTION
    (51) LEXP -> . LET_EXPR
    (52) LEXP -> . IF_EXPR
    (53) LEXP -> . MATCH_EXPR
    (54) LEXP -> . FUNCTION_EXPR
    (55) LAMBDA_ABSTRACTION -> . LAMBDA APAT APATS ARROW EXP
    (56) LET_EXPR -> . LET DECLARATIONS IN EXP
    (57) IF_EXPR -> . EXP IF EXP ELSE EXP
    (58) MATCH_EXPR -> . MATCH EXP ON OPEN_BRACE ALTS CLOSE_BRACE
    (59) FUNCTION_EXPR -> . FUNCTION_EXPR AEXP
    (60) FUNCTION_EXPR -> . AEXP
    (61) AEXP -> . USED_VAR
    (62) AEXP -> . USED_TYPENAME
    (63) AEXP -> . LITERAL
    (64) AEXP -> . OPERATOR_FUNC
    (65) AEXP -> . OPEN_PAREN EXP CLOSE_PAREN
    (106) USED_VAR -> . IDENTIFIER
    (107) USED_TYPENAME -> . TYPENAME
    (102) LITERAL -> . FLOAT
    (103) LITERAL -> . INTEGER
    (104) LITERAL -> . BOOL
    (105) LITERAL -> . STRING
    (66) OPERATOR_FUNC -> . OPEN_PAREN OP CLOSE_PAREN

    MINUS           shift and go to state 71
    LAMBDA          shift and go to state 77
    LET             shift and go to state 78
    MATCH           shift and go to state 79
    OPEN_PAREN      shift and go to state 85
    IDENTIFIER      shift and go to state 86
    TYPENAME        shift and go to state 87
    FLOAT           shift and go to state 33
    INTEGER         shift and go to state 23
    BOOL            shift and go to state 34
    STRING          shift and go to state 12

    EXP                            shift and go to state 150
    INFIX_EXP                      shift and go to state 69
    LEXP                           shift and go to state 70
    LAMBDA_ABSTRACTION             shift and go to state 72
    LET_EXPR                       shift and go to state 73
    IF_EXPR                        shift and go to state 74
    MATCH_EXPR                     shift and go to state 75
    FUNCTION_EXPR                  shift and go to state 76
    AEXP                           shift and go to state 80
    USED_VAR                       shift and go to state 81
    USED_TYPENAME                  shift and go to state 82
    LITERAL                        shift and go to state 83
    OPERATOR_FUNC                  shift and go to state 84

state 134

    (25) FIXITY_DECLARATION -> SETFIX ASSOCIATIVITY INTEGER OP .

    CLOSE_BRACE     reduce using rule 25 (FIXITY_DECLARATION -> SETFIX ASSOCIATIVITY INTEGER OP .)
    ENDSTATEMENT    reduce using rule 25 (FIXITY_DECLARATION -> SETFIX ASSOCIATIVITY INTEGER OP .)


state 135

    (37) FUNCTION_LHS -> OPEN_PAREN FUNCTION_LHS CLOSE_PAREN APAT . APATS
    (84) APATS -> . APAT APATS
    (85) APATS -> .
    (77) APAT -> . PARAM
    (78) APAT -> . TYPENAME
    (79) APAT -> . LITERAL
    (80) APAT -> . OPEN_PAREN LPAT CLOSE_PAREN
    (108) PARAM -> . IDENTIFIER
    (102) LITERAL -> . FLOAT
    (103) LITERAL -> . INTEGER
    (104) LITERAL -> . BOOL
    (105) LITERAL -> . STRING

    EQUALS          reduce using rule 85 (APATS -> .)
    GIVEN           reduce using rule 85 (APATS -> .)
    CLOSE_PAREN     reduce using rule 85 (APATS -> .)
    TYPENAME        shift and go to state 40
    OPEN_PAREN      shift and go to state 43
    IDENTIFIER      shift and go to state 44
    FLOAT           shift and go to state 33
    INTEGER         shift and go to state 23
    BOOL            shift and go to state 34
    STRING          shift and go to state 12

    APAT                           shift and go to state 65
    APATS                          shift and go to state 151
    PARAM                          shift and go to state 42
    LITERAL                        shift and go to state 31

state 136

    (83) INFIX_FUNCTION -> TILDE IDENTIFIER TILDE .

    TYPENAME        reduce using rule 83 (INFIX_FUNCTION -> TILDE IDENTIFIER TILDE .)
    OPEN_PAREN      reduce using rule 83 (INFIX_FUNCTION -> TILDE IDENTIFIER TILDE .)
    MINUS           reduce using rule 83 (INFIX_FUNCTION -> TILDE IDENTIFIER TILDE .)
    IDENTIFIER      reduce using rule 83 (INFIX_FUNCTION -> TILDE IDENTIFIER TILDE .)
    FLOAT           reduce using rule 83 (INFIX_FUNCTION -> TILDE IDENTIFIER TILDE .)
    INTEGER         reduce using rule 83 (INFIX_FUNCTION -> TILDE IDENTIFIER TILDE .)
    BOOL            reduce using rule 83 (INFIX_FUNCTION -> TILDE IDENTIFIER TILDE .)
    STRING          reduce using rule 83 (INFIX_FUNCTION -> TILDE IDENTIFIER TILDE .)
    LAMBDA          reduce using rule 83 (INFIX_FUNCTION -> TILDE IDENTIFIER TILDE .)
    LET             reduce using rule 83 (INFIX_FUNCTION -> TILDE IDENTIFIER TILDE .)
    MATCH           reduce using rule 83 (INFIX_FUNCTION -> TILDE IDENTIFIER TILDE .)
    CLOSE_PAREN     reduce using rule 83 (INFIX_FUNCTION -> TILDE IDENTIFIER TILDE .)
    CLOSE_BRACE     reduce using rule 83 (INFIX_FUNCTION -> TILDE IDENTIFIER TILDE .)
    ENDSTATEMENT    reduce using rule 83 (INFIX_FUNCTION -> TILDE IDENTIFIER TILDE .)


state 137

    (14) CONSTRUCTOR -> TYPENAME ATYPES .
    (31) ATYPES -> ATYPES . ATYPE
    (33) ATYPE -> . TYPENAME
    (34) ATYPE -> . IDENTIFIER
    (35) ATYPE -> . OPEN_PAREN TYPE CLOSE_PAREN

    PIPE            reduce using rule 14 (CONSTRUCTOR -> TYPENAME ATYPES .)
    CLOSE_BRACE     reduce using rule 14 (CONSTRUCTOR -> TYPENAME ATYPES .)
    ENDSTATEMENT    reduce using rule 14 (CONSTRUCTOR -> TYPENAME ATYPES .)
    TYPENAME        shift and go to state 152
    IDENTIFIER      shift and go to state 154
    OPEN_PAREN      shift and go to state 155

    ATYPE                          shift and go to state 153

state 138

    (12) CONSTRUCTORS -> CONSTRUCTORS PIPE . CONSTRUCTOR
    (14) CONSTRUCTOR -> . TYPENAME ATYPES

    TYPENAME        shift and go to state 97

    CONSTRUCTOR                    shift and go to state 156

state 139

    (41) RHS -> EQUALS EXP WITH DECLARATIONS .

    CLOSE_BRACE     reduce using rule 41 (RHS -> EQUALS EXP WITH DECLARATIONS .)
    ENDSTATEMENT    reduce using rule 41 (RHS -> EQUALS EXP WITH DECLARATIONS .)


state 140

    (57) IF_EXPR -> EXP IF EXP . ELSE EXP
    (57) IF_EXPR -> EXP . IF EXP ELSE EXP

    ELSE            shift and go to state 157
    IF              shift and go to state 102


state 141

    (47) INFIX_EXP -> LEXP OP INFIX_EXP .
    (46) EXP -> INFIX_EXP .

  ! reduce/reduce conflict for IF resolved using rule 46 (EXP -> INFIX_EXP .)
    WITH            reduce using rule 47 (INFIX_EXP -> LEXP OP INFIX_EXP .)
    CLOSE_BRACE     reduce using rule 47 (INFIX_EXP -> LEXP OP INFIX_EXP .)
    ENDSTATEMENT    reduce using rule 47 (INFIX_EXP -> LEXP OP INFIX_EXP .)
    EQUALS          reduce using rule 47 (INFIX_EXP -> LEXP OP INFIX_EXP .)
    ON              reduce using rule 47 (INFIX_EXP -> LEXP OP INFIX_EXP .)
    ELSE            reduce using rule 47 (INFIX_EXP -> LEXP OP INFIX_EXP .)
    CLOSE_PAREN     reduce using rule 47 (INFIX_EXP -> LEXP OP INFIX_EXP .)
    GIVEN           reduce using rule 47 (INFIX_EXP -> LEXP OP INFIX_EXP .)
    PLUS            reduce using rule 47 (INFIX_EXP -> LEXP OP INFIX_EXP .)
    MINUS           reduce using rule 47 (INFIX_EXP -> LEXP OP INFIX_EXP .)
    TIMES           reduce using rule 47 (INFIX_EXP -> LEXP OP INFIX_EXP .)
    DIVIDE          reduce using rule 47 (INFIX_EXP -> LEXP OP INFIX_EXP .)
    MODULO          reduce using rule 47 (INFIX_EXP -> LEXP OP INFIX_EXP .)
    FPOW            reduce using rule 47 (INFIX_EXP -> LEXP OP INFIX_EXP .)
    IPOW            reduce using rule 47 (INFIX_EXP -> LEXP OP INFIX_EXP .)
    EQUALITY        reduce using rule 47 (INFIX_EXP -> LEXP OP INFIX_EXP .)
    INEQUALITY      reduce using rule 47 (INFIX_EXP -> LEXP OP INFIX_EXP .)
    LESS            reduce using rule 47 (INFIX_EXP -> LEXP OP INFIX_EXP .)
    LEQ             reduce using rule 47 (INFIX_EXP -> LEXP OP INFIX_EXP .)
    GREATER         reduce using rule 47 (INFIX_EXP -> LEXP OP INFIX_EXP .)
    GEQ             reduce using rule 47 (INFIX_EXP -> LEXP OP INFIX_EXP .)
    CONCAT          reduce using rule 47 (INFIX_EXP -> LEXP OP INFIX_EXP .)
    AND             reduce using rule 47 (INFIX_EXP -> LEXP OP INFIX_EXP .)
    OR              reduce using rule 47 (INFIX_EXP -> LEXP OP INFIX_EXP .)
    TILDE           reduce using rule 47 (INFIX_EXP -> LEXP OP INFIX_EXP .)
    IF              reduce using rule 46 (EXP -> INFIX_EXP .)

  ! IF              [ reduce using rule 47 (INFIX_EXP -> LEXP OP INFIX_EXP .) ]


state 142

    (55) LAMBDA_ABSTRACTION -> LAMBDA APAT APATS . ARROW EXP

    ARROW           shift and go to state 158


state 143

    (56) LET_EXPR -> LET DECLARATIONS IN . EXP
    (46) EXP -> . INFIX_EXP
    (47) INFIX_EXP -> . LEXP OP INFIX_EXP
    (48) INFIX_EXP -> . MINUS INFIX_EXP
    (49) INFIX_EXP -> . LEXP
    (50) LEXP -> . LAMBDA_ABSTRACTION
    (51) LEXP -> . LET_EXPR
    (52) LEXP -> . IF_EXPR
    (53) LEXP -> . MATCH_EXPR
    (54) LEXP -> . FUNCTION_EXPR
    (55) LAMBDA_ABSTRACTION -> . LAMBDA APAT APATS ARROW EXP
    (56) LET_EXPR -> . LET DECLARATIONS IN EXP
    (57) IF_EXPR -> . EXP IF EXP ELSE EXP
    (58) MATCH_EXPR -> . MATCH EXP ON OPEN_BRACE ALTS CLOSE_BRACE
    (59) FUNCTION_EXPR -> . FUNCTION_EXPR AEXP
    (60) FUNCTION_EXPR -> . AEXP
    (61) AEXP -> . USED_VAR
    (62) AEXP -> . USED_TYPENAME
    (63) AEXP -> . LITERAL
    (64) AEXP -> . OPERATOR_FUNC
    (65) AEXP -> . OPEN_PAREN EXP CLOSE_PAREN
    (106) USED_VAR -> . IDENTIFIER
    (107) USED_TYPENAME -> . TYPENAME
    (102) LITERAL -> . FLOAT
    (103) LITERAL -> . INTEGER
    (104) LITERAL -> . BOOL
    (105) LITERAL -> . STRING
    (66) OPERATOR_FUNC -> . OPEN_PAREN OP CLOSE_PAREN

    MINUS           shift and go to state 71
    LAMBDA          shift and go to state 77
    LET             shift and go to state 78
    MATCH           shift and go to state 79
    OPEN_PAREN      shift and go to state 85
    IDENTIFIER      shift and go to state 86
    TYPENAME        shift and go to state 87
    FLOAT           shift and go to state 33
    INTEGER         shift and go to state 23
    BOOL            shift and go to state 34
    STRING          shift and go to state 12

    EXP                            shift and go to state 159
    INFIX_EXP                      shift and go to state 69
    LEXP                           shift and go to state 70
    LAMBDA_ABSTRACTION             shift and go to state 72
    LET_EXPR                       shift and go to state 73
    IF_EXPR                        shift and go to state 74
    MATCH_EXPR                     shift and go to state 75
    FUNCTION_EXPR                  shift and go to state 76
    AEXP                           shift and go to state 80
    USED_VAR                       shift and go to state 81
    USED_TYPENAME                  shift and go to state 82
    LITERAL                        shift and go to state 83
    OPERATOR_FUNC                  shift and go to state 84

state 144

    (15) DECLARATIONS -> OPEN_BRACE DECLARATIONS_LIST . CLOSE_BRACE

    CLOSE_BRACE     shift and go to state 160


state 145

    (16) DECLARATIONS -> OPEN_BRACE CLOSE_BRACE .

    IN              reduce using rule 16 (DECLARATIONS -> OPEN_BRACE CLOSE_BRACE .)
    CLOSE_BRACE     reduce using rule 16 (DECLARATIONS -> OPEN_BRACE CLOSE_BRACE .)
    ENDSTATEMENT    reduce using rule 16 (DECLARATIONS -> OPEN_BRACE CLOSE_BRACE .)


state 146

    (17) DECLARATIONS_LIST -> DECLARATION . ENDSTATEMENT DECLARATIONS_LIST
    (18) DECLARATIONS_LIST -> DECLARATION .

    ENDSTATEMENT    shift and go to state 161
    CLOSE_BRACE     reduce using rule 18 (DECLARATIONS_LIST -> DECLARATION .)


state 147

    (58) MATCH_EXPR -> MATCH EXP ON . OPEN_BRACE ALTS CLOSE_BRACE

    OPEN_BRACE      shift and go to state 162


state 148

    (65) AEXP -> OPEN_PAREN EXP CLOSE_PAREN .

    OPEN_PAREN      reduce using rule 65 (AEXP -> OPEN_PAREN EXP CLOSE_PAREN .)
    IDENTIFIER      reduce using rule 65 (AEXP -> OPEN_PAREN EXP CLOSE_PAREN .)
    TYPENAME        reduce using rule 65 (AEXP -> OPEN_PAREN EXP CLOSE_PAREN .)
    FLOAT           reduce using rule 65 (AEXP -> OPEN_PAREN EXP CLOSE_PAREN .)
    INTEGER         reduce using rule 65 (AEXP -> OPEN_PAREN EXP CLOSE_PAREN .)
    BOOL            reduce using rule 65 (AEXP -> OPEN_PAREN EXP CLOSE_PAREN .)
    STRING          reduce using rule 65 (AEXP -> OPEN_PAREN EXP CLOSE_PAREN .)
    PLUS            reduce using rule 65 (AEXP -> OPEN_PAREN EXP CLOSE_PAREN .)
    MINUS           reduce using rule 65 (AEXP -> OPEN_PAREN EXP CLOSE_PAREN .)
    TIMES           reduce using rule 65 (AEXP -> OPEN_PAREN EXP CLOSE_PAREN .)
    DIVIDE          reduce using rule 65 (AEXP -> OPEN_PAREN EXP CLOSE_PAREN .)
    MODULO          reduce using rule 65 (AEXP -> OPEN_PAREN EXP CLOSE_PAREN .)
    FPOW            reduce using rule 65 (AEXP -> OPEN_PAREN EXP CLOSE_PAREN .)
    IPOW            reduce using rule 65 (AEXP -> OPEN_PAREN EXP CLOSE_PAREN .)
    EQUALITY        reduce using rule 65 (AEXP -> OPEN_PAREN EXP CLOSE_PAREN .)
    INEQUALITY      reduce using rule 65 (AEXP -> OPEN_PAREN EXP CLOSE_PAREN .)
    LESS            reduce using rule 65 (AEXP -> OPEN_PAREN EXP CLOSE_PAREN .)
    LEQ             reduce using rule 65 (AEXP -> OPEN_PAREN EXP CLOSE_PAREN .)
    GREATER         reduce using rule 65 (AEXP -> OPEN_PAREN EXP CLOSE_PAREN .)
    GEQ             reduce using rule 65 (AEXP -> OPEN_PAREN EXP CLOSE_PAREN .)
    CONCAT          reduce using rule 65 (AEXP -> OPEN_PAREN EXP CLOSE_PAREN .)
    AND             reduce using rule 65 (AEXP -> OPEN_PAREN EXP CLOSE_PAREN .)
    OR              reduce using rule 65 (AEXP -> OPEN_PAREN EXP CLOSE_PAREN .)
    TILDE           reduce using rule 65 (AEXP -> OPEN_PAREN EXP CLOSE_PAREN .)
    WITH            reduce using rule 65 (AEXP -> OPEN_PAREN EXP CLOSE_PAREN .)
    IF              reduce using rule 65 (AEXP -> OPEN_PAREN EXP CLOSE_PAREN .)
    CLOSE_BRACE     reduce using rule 65 (AEXP -> OPEN_PAREN EXP CLOSE_PAREN .)
    ENDSTATEMENT    reduce using rule 65 (AEXP -> OPEN_PAREN EXP CLOSE_PAREN .)
    EQUALS          reduce using rule 65 (AEXP -> OPEN_PAREN EXP CLOSE_PAREN .)
    ON              reduce using rule 65 (AEXP -> OPEN_PAREN EXP CLOSE_PAREN .)
    ELSE            reduce using rule 65 (AEXP -> OPEN_PAREN EXP CLOSE_PAREN .)
    CLOSE_PAREN     reduce using rule 65 (AEXP -> OPEN_PAREN EXP CLOSE_PAREN .)
    GIVEN           reduce using rule 65 (AEXP -> OPEN_PAREN EXP CLOSE_PAREN .)


state 149

    (66) OPERATOR_FUNC -> OPEN_PAREN OP CLOSE_PAREN .

    OPEN_PAREN      reduce using rule 66 (OPERATOR_FUNC -> OPEN_PAREN OP CLOSE_PAREN .)
    IDENTIFIER      reduce using rule 66 (OPERATOR_FUNC -> OPEN_PAREN OP CLOSE_PAREN .)
    TYPENAME        reduce using rule 66 (OPERATOR_FUNC -> OPEN_PAREN OP CLOSE_PAREN .)
    FLOAT           reduce using rule 66 (OPERATOR_FUNC -> OPEN_PAREN OP CLOSE_PAREN .)
    INTEGER         reduce using rule 66 (OPERATOR_FUNC -> OPEN_PAREN OP CLOSE_PAREN .)
    BOOL            reduce using rule 66 (OPERATOR_FUNC -> OPEN_PAREN OP CLOSE_PAREN .)
    STRING          reduce using rule 66 (OPERATOR_FUNC -> OPEN_PAREN OP CLOSE_PAREN .)
    PLUS            reduce using rule 66 (OPERATOR_FUNC -> OPEN_PAREN OP CLOSE_PAREN .)
    MINUS           reduce using rule 66 (OPERATOR_FUNC -> OPEN_PAREN OP CLOSE_PAREN .)
    TIMES           reduce using rule 66 (OPERATOR_FUNC -> OPEN_PAREN OP CLOSE_PAREN .)
    DIVIDE          reduce using rule 66 (OPERATOR_FUNC -> OPEN_PAREN OP CLOSE_PAREN .)
    MODULO          reduce using rule 66 (OPERATOR_FUNC -> OPEN_PAREN OP CLOSE_PAREN .)
    FPOW            reduce using rule 66 (OPERATOR_FUNC -> OPEN_PAREN OP CLOSE_PAREN .)
    IPOW            reduce using rule 66 (OPERATOR_FUNC -> OPEN_PAREN OP CLOSE_PAREN .)
    EQUALITY        reduce using rule 66 (OPERATOR_FUNC -> OPEN_PAREN OP CLOSE_PAREN .)
    INEQUALITY      reduce using rule 66 (OPERATOR_FUNC -> OPEN_PAREN OP CLOSE_PAREN .)
    LESS            reduce using rule 66 (OPERATOR_FUNC -> OPEN_PAREN OP CLOSE_PAREN .)
    LEQ             reduce using rule 66 (OPERATOR_FUNC -> OPEN_PAREN OP CLOSE_PAREN .)
    GREATER         reduce using rule 66 (OPERATOR_FUNC -> OPEN_PAREN OP CLOSE_PAREN .)
    GEQ             reduce using rule 66 (OPERATOR_FUNC -> OPEN_PAREN OP CLOSE_PAREN .)
    CONCAT          reduce using rule 66 (OPERATOR_FUNC -> OPEN_PAREN OP CLOSE_PAREN .)
    AND             reduce using rule 66 (OPERATOR_FUNC -> OPEN_PAREN OP CLOSE_PAREN .)
    OR              reduce using rule 66 (OPERATOR_FUNC -> OPEN_PAREN OP CLOSE_PAREN .)
    TILDE           reduce using rule 66 (OPERATOR_FUNC -> OPEN_PAREN OP CLOSE_PAREN .)
    WITH            reduce using rule 66 (OPERATOR_FUNC -> OPEN_PAREN OP CLOSE_PAREN .)
    IF              reduce using rule 66 (OPERATOR_FUNC -> OPEN_PAREN OP CLOSE_PAREN .)
    CLOSE_BRACE     reduce using rule 66 (OPERATOR_FUNC -> OPEN_PAREN OP CLOSE_PAREN .)
    ENDSTATEMENT    reduce using rule 66 (OPERATOR_FUNC -> OPEN_PAREN OP CLOSE_PAREN .)
    EQUALS          reduce using rule 66 (OPERATOR_FUNC -> OPEN_PAREN OP CLOSE_PAREN .)
    ON              reduce using rule 66 (OPERATOR_FUNC -> OPEN_PAREN OP CLOSE_PAREN .)
    ELSE            reduce using rule 66 (OPERATOR_FUNC -> OPEN_PAREN OP CLOSE_PAREN .)
    CLOSE_PAREN     reduce using rule 66 (OPERATOR_FUNC -> OPEN_PAREN OP CLOSE_PAREN .)
    GIVEN           reduce using rule 66 (OPERATOR_FUNC -> OPEN_PAREN OP CLOSE_PAREN .)


state 150

    (44) GDRHS -> GIVEN EXP EQUALS EXP .
    (45) GDRHS -> GIVEN EXP EQUALS EXP . GDRHS
    (57) IF_EXPR -> EXP . IF EXP ELSE EXP
    (44) GDRHS -> . GIVEN EXP EQUALS EXP
    (45) GDRHS -> . GIVEN EXP EQUALS EXP GDRHS

    WITH            reduce using rule 44 (GDRHS -> GIVEN EXP EQUALS EXP .)
    CLOSE_BRACE     reduce using rule 44 (GDRHS -> GIVEN EXP EQUALS EXP .)
    ENDSTATEMENT    reduce using rule 44 (GDRHS -> GIVEN EXP EQUALS EXP .)
    IF              shift and go to state 102
    GIVEN           shift and go to state 48

    GDRHS                          shift and go to state 163

state 151

    (37) FUNCTION_LHS -> OPEN_PAREN FUNCTION_LHS CLOSE_PAREN APAT APATS .

    EQUALS          reduce using rule 37 (FUNCTION_LHS -> OPEN_PAREN FUNCTION_LHS CLOSE_PAREN APAT APATS .)
    GIVEN           reduce using rule 37 (FUNCTION_LHS -> OPEN_PAREN FUNCTION_LHS CLOSE_PAREN APAT APATS .)
    CLOSE_PAREN     reduce using rule 37 (FUNCTION_LHS -> OPEN_PAREN FUNCTION_LHS CLOSE_PAREN APAT APATS .)


state 152

    (33) ATYPE -> TYPENAME .

    TYPENAME        reduce using rule 33 (ATYPE -> TYPENAME .)
    IDENTIFIER      reduce using rule 33 (ATYPE -> TYPENAME .)
    OPEN_PAREN      reduce using rule 33 (ATYPE -> TYPENAME .)
    PIPE            reduce using rule 33 (ATYPE -> TYPENAME .)
    CLOSE_BRACE     reduce using rule 33 (ATYPE -> TYPENAME .)
    ENDSTATEMENT    reduce using rule 33 (ATYPE -> TYPENAME .)
    ARROW           reduce using rule 33 (ATYPE -> TYPENAME .)
    CLOSE_PAREN     reduce using rule 33 (ATYPE -> TYPENAME .)


state 153

    (31) ATYPES -> ATYPES ATYPE .

    TYPENAME        reduce using rule 31 (ATYPES -> ATYPES ATYPE .)
    IDENTIFIER      reduce using rule 31 (ATYPES -> ATYPES ATYPE .)
    OPEN_PAREN      reduce using rule 31 (ATYPES -> ATYPES ATYPE .)
    PIPE            reduce using rule 31 (ATYPES -> ATYPES ATYPE .)
    CLOSE_BRACE     reduce using rule 31 (ATYPES -> ATYPES ATYPE .)
    ENDSTATEMENT    reduce using rule 31 (ATYPES -> ATYPES ATYPE .)


state 154

    (34) ATYPE -> IDENTIFIER .

    TYPENAME        reduce using rule 34 (ATYPE -> IDENTIFIER .)
    IDENTIFIER      reduce using rule 34 (ATYPE -> IDENTIFIER .)
    OPEN_PAREN      reduce using rule 34 (ATYPE -> IDENTIFIER .)
    PIPE            reduce using rule 34 (ATYPE -> IDENTIFIER .)
    CLOSE_BRACE     reduce using rule 34 (ATYPE -> IDENTIFIER .)
    ENDSTATEMENT    reduce using rule 34 (ATYPE -> IDENTIFIER .)
    ARROW           reduce using rule 34 (ATYPE -> IDENTIFIER .)
    CLOSE_PAREN     reduce using rule 34 (ATYPE -> IDENTIFIER .)


state 155

    (35) ATYPE -> OPEN_PAREN . TYPE CLOSE_PAREN
    (29) TYPE -> . ATYPE
    (30) TYPE -> . ATYPE ARROW TYPE
    (33) ATYPE -> . TYPENAME
    (34) ATYPE -> . IDENTIFIER
    (35) ATYPE -> . OPEN_PAREN TYPE CLOSE_PAREN

    TYPENAME        shift and go to state 152
    IDENTIFIER      shift and go to state 154
    OPEN_PAREN      shift and go to state 155

    TYPE                           shift and go to state 164
    ATYPE                          shift and go to state 165

state 156

    (12) CONSTRUCTORS -> CONSTRUCTORS PIPE CONSTRUCTOR .

    PIPE            reduce using rule 12 (CONSTRUCTORS -> CONSTRUCTORS PIPE CONSTRUCTOR .)
    CLOSE_BRACE     reduce using rule 12 (CONSTRUCTORS -> CONSTRUCTORS PIPE CONSTRUCTOR .)
    ENDSTATEMENT    reduce using rule 12 (CONSTRUCTORS -> CONSTRUCTORS PIPE CONSTRUCTOR .)


state 157

    (57) IF_EXPR -> EXP IF EXP ELSE . EXP
    (46) EXP -> . INFIX_EXP
    (47) INFIX_EXP -> . LEXP OP INFIX_EXP
    (48) INFIX_EXP -> . MINUS INFIX_EXP
    (49) INFIX_EXP -> . LEXP
    (50) LEXP -> . LAMBDA_ABSTRACTION
    (51) LEXP -> . LET_EXPR
    (52) LEXP -> . IF_EXPR
    (53) LEXP -> . MATCH_EXPR
    (54) LEXP -> . FUNCTION_EXPR
    (55) LAMBDA_ABSTRACTION -> . LAMBDA APAT APATS ARROW EXP
    (56) LET_EXPR -> . LET DECLARATIONS IN EXP
    (57) IF_EXPR -> . EXP IF EXP ELSE EXP
    (58) MATCH_EXPR -> . MATCH EXP ON OPEN_BRACE ALTS CLOSE_BRACE
    (59) FUNCTION_EXPR -> . FUNCTION_EXPR AEXP
    (60) FUNCTION_EXPR -> . AEXP
    (61) AEXP -> . USED_VAR
    (62) AEXP -> . USED_TYPENAME
    (63) AEXP -> . LITERAL
    (64) AEXP -> . OPERATOR_FUNC
    (65) AEXP -> . OPEN_PAREN EXP CLOSE_PAREN
    (106) USED_VAR -> . IDENTIFIER
    (107) USED_TYPENAME -> . TYPENAME
    (102) LITERAL -> . FLOAT
    (103) LITERAL -> . INTEGER
    (104) LITERAL -> . BOOL
    (105) LITERAL -> . STRING
    (66) OPERATOR_FUNC -> . OPEN_PAREN OP CLOSE_PAREN

    MINUS           shift and go to state 71
    LAMBDA          shift and go to state 77
    LET             shift and go to state 78
    MATCH           shift and go to state 79
    OPEN_PAREN      shift and go to state 85
    IDENTIFIER      shift and go to state 86
    TYPENAME        shift and go to state 87
    FLOAT           shift and go to state 33
    INTEGER         shift and go to state 23
    BOOL            shift and go to state 34
    STRING          shift and go to state 12

    EXP                            shift and go to state 166
    INFIX_EXP                      shift and go to state 69
    LEXP                           shift and go to state 70
    LAMBDA_ABSTRACTION             shift and go to state 72
    LET_EXPR                       shift and go to state 73
    IF_EXPR                        shift and go to state 74
    MATCH_EXPR                     shift and go to state 75
    FUNCTION_EXPR                  shift and go to state 76
    AEXP                           shift and go to state 80
    USED_VAR                       shift and go to state 81
    USED_TYPENAME                  shift and go to state 82
    LITERAL                        shift and go to state 83
    OPERATOR_FUNC                  shift and go to state 84

state 158

    (55) LAMBDA_ABSTRACTION -> LAMBDA APAT APATS ARROW . EXP
    (46) EXP -> . INFIX_EXP
    (47) INFIX_EXP -> . LEXP OP INFIX_EXP
    (48) INFIX_EXP -> . MINUS INFIX_EXP
    (49) INFIX_EXP -> . LEXP
    (50) LEXP -> . LAMBDA_ABSTRACTION
    (51) LEXP -> . LET_EXPR
    (52) LEXP -> . IF_EXPR
    (53) LEXP -> . MATCH_EXPR
    (54) LEXP -> . FUNCTION_EXPR
    (55) LAMBDA_ABSTRACTION -> . LAMBDA APAT APATS ARROW EXP
    (56) LET_EXPR -> . LET DECLARATIONS IN EXP
    (57) IF_EXPR -> . EXP IF EXP ELSE EXP
    (58) MATCH_EXPR -> . MATCH EXP ON OPEN_BRACE ALTS CLOSE_BRACE
    (59) FUNCTION_EXPR -> . FUNCTION_EXPR AEXP
    (60) FUNCTION_EXPR -> . AEXP
    (61) AEXP -> . USED_VAR
    (62) AEXP -> . USED_TYPENAME
    (63) AEXP -> . LITERAL
    (64) AEXP -> . OPERATOR_FUNC
    (65) AEXP -> . OPEN_PAREN EXP CLOSE_PAREN
    (106) USED_VAR -> . IDENTIFIER
    (107) USED_TYPENAME -> . TYPENAME
    (102) LITERAL -> . FLOAT
    (103) LITERAL -> . INTEGER
    (104) LITERAL -> . BOOL
    (105) LITERAL -> . STRING
    (66) OPERATOR_FUNC -> . OPEN_PAREN OP CLOSE_PAREN

    MINUS           shift and go to state 71
    LAMBDA          shift and go to state 77
    LET             shift and go to state 78
    MATCH           shift and go to state 79
    OPEN_PAREN      shift and go to state 85
    IDENTIFIER      shift and go to state 86
    TYPENAME        shift and go to state 87
    FLOAT           shift and go to state 33
    INTEGER         shift and go to state 23
    BOOL            shift and go to state 34
    STRING          shift and go to state 12

    EXP                            shift and go to state 167
    INFIX_EXP                      shift and go to state 69
    LEXP                           shift and go to state 70
    LAMBDA_ABSTRACTION             shift and go to state 72
    LET_EXPR                       shift and go to state 73
    IF_EXPR                        shift and go to state 74
    MATCH_EXPR                     shift and go to state 75
    FUNCTION_EXPR                  shift and go to state 76
    AEXP                           shift and go to state 80
    USED_VAR                       shift and go to state 81
    USED_TYPENAME                  shift and go to state 82
    LITERAL                        shift and go to state 83
    OPERATOR_FUNC                  shift and go to state 84

state 159

    (56) LET_EXPR -> LET DECLARATIONS IN EXP .
    (57) IF_EXPR -> EXP . IF EXP ELSE EXP

  ! shift/reduce conflict for IF resolved as shift
    PLUS            reduce using rule 56 (LET_EXPR -> LET DECLARATIONS IN EXP .)
    MINUS           reduce using rule 56 (LET_EXPR -> LET DECLARATIONS IN EXP .)
    TIMES           reduce using rule 56 (LET_EXPR -> LET DECLARATIONS IN EXP .)
    DIVIDE          reduce using rule 56 (LET_EXPR -> LET DECLARATIONS IN EXP .)
    MODULO          reduce using rule 56 (LET_EXPR -> LET DECLARATIONS IN EXP .)
    FPOW            reduce using rule 56 (LET_EXPR -> LET DECLARATIONS IN EXP .)
    IPOW            reduce using rule 56 (LET_EXPR -> LET DECLARATIONS IN EXP .)
    EQUALITY        reduce using rule 56 (LET_EXPR -> LET DECLARATIONS IN EXP .)
    INEQUALITY      reduce using rule 56 (LET_EXPR -> LET DECLARATIONS IN EXP .)
    LESS            reduce using rule 56 (LET_EXPR -> LET DECLARATIONS IN EXP .)
    LEQ             reduce using rule 56 (LET_EXPR -> LET DECLARATIONS IN EXP .)
    GREATER         reduce using rule 56 (LET_EXPR -> LET DECLARATIONS IN EXP .)
    GEQ             reduce using rule 56 (LET_EXPR -> LET DECLARATIONS IN EXP .)
    CONCAT          reduce using rule 56 (LET_EXPR -> LET DECLARATIONS IN EXP .)
    AND             reduce using rule 56 (LET_EXPR -> LET DECLARATIONS IN EXP .)
    OR              reduce using rule 56 (LET_EXPR -> LET DECLARATIONS IN EXP .)
    TILDE           reduce using rule 56 (LET_EXPR -> LET DECLARATIONS IN EXP .)
    WITH            reduce using rule 56 (LET_EXPR -> LET DECLARATIONS IN EXP .)
    CLOSE_BRACE     reduce using rule 56 (LET_EXPR -> LET DECLARATIONS IN EXP .)
    ENDSTATEMENT    reduce using rule 56 (LET_EXPR -> LET DECLARATIONS IN EXP .)
    EQUALS          reduce using rule 56 (LET_EXPR -> LET DECLARATIONS IN EXP .)
    ON              reduce using rule 56 (LET_EXPR -> LET DECLARATIONS IN EXP .)
    ELSE            reduce using rule 56 (LET_EXPR -> LET DECLARATIONS IN EXP .)
    CLOSE_PAREN     reduce using rule 56 (LET_EXPR -> LET DECLARATIONS IN EXP .)
    GIVEN           reduce using rule 56 (LET_EXPR -> LET DECLARATIONS IN EXP .)
    IF              shift and go to state 102

  ! IF              [ reduce using rule 56 (LET_EXPR -> LET DECLARATIONS IN EXP .) ]


state 160

    (15) DECLARATIONS -> OPEN_BRACE DECLARATIONS_LIST CLOSE_BRACE .

    IN              reduce using rule 15 (DECLARATIONS -> OPEN_BRACE DECLARATIONS_LIST CLOSE_BRACE .)
    CLOSE_BRACE     reduce using rule 15 (DECLARATIONS -> OPEN_BRACE DECLARATIONS_LIST CLOSE_BRACE .)
    ENDSTATEMENT    reduce using rule 15 (DECLARATIONS -> OPEN_BRACE DECLARATIONS_LIST CLOSE_BRACE .)


state 161

    (17) DECLARATIONS_LIST -> DECLARATION ENDSTATEMENT . DECLARATIONS_LIST
    (17) DECLARATIONS_LIST -> . DECLARATION ENDSTATEMENT DECLARATIONS_LIST
    (18) DECLARATIONS_LIST -> . DECLARATION
    (19) DECLARATION -> . FUNCTION_DEFINITION
    (20) DECLARATION -> . VARIABLE_DEFINITION
    (21) DECLARATION -> . FIXITY_DECLARATION
    (22) DECLARATION -> .
    (23) FUNCTION_DEFINITION -> . FUNCTION_LHS RHS
    (24) VARIABLE_DEFINITION -> . PARAM RHS
    (25) FIXITY_DECLARATION -> . SETFIX ASSOCIATIVITY INTEGER OP
    (36) FUNCTION_LHS -> . IDENTIFIER APAT APATS
    (37) FUNCTION_LHS -> . OPEN_PAREN FUNCTION_LHS CLOSE_PAREN APAT APATS
    (38) FUNCTION_LHS -> . INFIX_FUNCTION_DEFINITION
    (108) PARAM -> . IDENTIFIER
    (39) INFIX_FUNCTION_DEFINITION -> . LPAT INFIX_FUNCTION LPAT
    (71) LPAT -> . APAT
    (72) LPAT -> . CONSTRUCTOR_PATTERN
    (73) LPAT -> . NEGATIVE_LITERAL
    (77) APAT -> . PARAM
    (78) APAT -> . TYPENAME
    (79) APAT -> . LITERAL
    (80) APAT -> . OPEN_PAREN LPAT CLOSE_PAREN
    (74) CONSTRUCTOR_PATTERN -> . TYPENAME APAT APATS
    (75) NEGATIVE_LITERAL -> . MINUS INTEGER
    (76) NEGATIVE_LITERAL -> . MINUS FLOAT
    (102) LITERAL -> . FLOAT
    (103) LITERAL -> . INTEGER
    (104) LITERAL -> . BOOL
    (105) LITERAL -> . STRING

    ENDSTATEMENT    reduce using rule 22 (DECLARATION -> .)
    CLOSE_BRACE     reduce using rule 22 (DECLARATION -> .)
    SETFIX          shift and go to state 22
    IDENTIFIER      shift and go to state 24
    OPEN_PAREN      shift and go to state 26
    TYPENAME        shift and go to state 16
    MINUS           shift and go to state 32
    FLOAT           shift and go to state 33
    INTEGER         shift and go to state 23
    BOOL            shift and go to state 34
    STRING          shift and go to state 12

    DECLARATION                    shift and go to state 146
    DECLARATIONS_LIST              shift and go to state 168
    FUNCTION_DEFINITION            shift and go to state 17
    VARIABLE_DEFINITION            shift and go to state 18
    FIXITY_DECLARATION             shift and go to state 19
    FUNCTION_LHS                   shift and go to state 20
    PARAM                          shift and go to state 21
    APAT                           shift and go to state 25
    INFIX_FUNCTION_DEFINITION      shift and go to state 27
    LPAT                           shift and go to state 28
    CONSTRUCTOR_PATTERN            shift and go to state 29
    NEGATIVE_LITERAL               shift and go to state 30
    LITERAL                        shift and go to state 31

state 162

    (58) MATCH_EXPR -> MATCH EXP ON OPEN_BRACE . ALTS CLOSE_BRACE
    (67) ALTS -> . ALT ENDSTATEMENT ALTS
    (68) ALTS -> . ALT
    (69) ALT -> . LPAT ARROW EXP
    (70) ALT -> .
    (71) LPAT -> . APAT
    (72) LPAT -> . CONSTRUCTOR_PATTERN
    (73) LPAT -> . NEGATIVE_LITERAL
    (77) APAT -> . PARAM
    (78) APAT -> . TYPENAME
    (79) APAT -> . LITERAL
    (80) APAT -> . OPEN_PAREN LPAT CLOSE_PAREN
    (74) CONSTRUCTOR_PATTERN -> . TYPENAME APAT APATS
    (75) NEGATIVE_LITERAL -> . MINUS INTEGER
    (76) NEGATIVE_LITERAL -> . MINUS FLOAT
    (108) PARAM -> . IDENTIFIER
    (102) LITERAL -> . FLOAT
    (103) LITERAL -> . INTEGER
    (104) LITERAL -> . BOOL
    (105) LITERAL -> . STRING

    ENDSTATEMENT    reduce using rule 70 (ALT -> .)
    CLOSE_BRACE     reduce using rule 70 (ALT -> .)
    TYPENAME        shift and go to state 16
    OPEN_PAREN      shift and go to state 43
    MINUS           shift and go to state 32
    IDENTIFIER      shift and go to state 44
    FLOAT           shift and go to state 33
    INTEGER         shift and go to state 23
    BOOL            shift and go to state 34
    STRING          shift and go to state 12

    ALTS                           shift and go to state 169
    ALT                            shift and go to state 170
    LPAT                           shift and go to state 171
    APAT                           shift and go to state 25
    CONSTRUCTOR_PATTERN            shift and go to state 29
    NEGATIVE_LITERAL               shift and go to state 30
    PARAM                          shift and go to state 42
    LITERAL                        shift and go to state 31

state 163

    (45) GDRHS -> GIVEN EXP EQUALS EXP GDRHS .

    WITH            reduce using rule 45 (GDRHS -> GIVEN EXP EQUALS EXP GDRHS .)
    CLOSE_BRACE     reduce using rule 45 (GDRHS -> GIVEN EXP EQUALS EXP GDRHS .)
    ENDSTATEMENT    reduce using rule 45 (GDRHS -> GIVEN EXP EQUALS EXP GDRHS .)


state 164

    (35) ATYPE -> OPEN_PAREN TYPE . CLOSE_PAREN

    CLOSE_PAREN     shift and go to state 172


state 165

    (29) TYPE -> ATYPE .
    (30) TYPE -> ATYPE . ARROW TYPE

    CLOSE_PAREN     reduce using rule 29 (TYPE -> ATYPE .)
    ARROW           shift and go to state 173


state 166

    (57) IF_EXPR -> EXP IF EXP ELSE EXP .
    (57) IF_EXPR -> EXP . IF EXP ELSE EXP

  ! shift/reduce conflict for IF resolved as shift
    PLUS            reduce using rule 57 (IF_EXPR -> EXP IF EXP ELSE EXP .)
    MINUS           reduce using rule 57 (IF_EXPR -> EXP IF EXP ELSE EXP .)
    TIMES           reduce using rule 57 (IF_EXPR -> EXP IF EXP ELSE EXP .)
    DIVIDE          reduce using rule 57 (IF_EXPR -> EXP IF EXP ELSE EXP .)
    MODULO          reduce using rule 57 (IF_EXPR -> EXP IF EXP ELSE EXP .)
    FPOW            reduce using rule 57 (IF_EXPR -> EXP IF EXP ELSE EXP .)
    IPOW            reduce using rule 57 (IF_EXPR -> EXP IF EXP ELSE EXP .)
    EQUALITY        reduce using rule 57 (IF_EXPR -> EXP IF EXP ELSE EXP .)
    INEQUALITY      reduce using rule 57 (IF_EXPR -> EXP IF EXP ELSE EXP .)
    LESS            reduce using rule 57 (IF_EXPR -> EXP IF EXP ELSE EXP .)
    LEQ             reduce using rule 57 (IF_EXPR -> EXP IF EXP ELSE EXP .)
    GREATER         reduce using rule 57 (IF_EXPR -> EXP IF EXP ELSE EXP .)
    GEQ             reduce using rule 57 (IF_EXPR -> EXP IF EXP ELSE EXP .)
    CONCAT          reduce using rule 57 (IF_EXPR -> EXP IF EXP ELSE EXP .)
    AND             reduce using rule 57 (IF_EXPR -> EXP IF EXP ELSE EXP .)
    OR              reduce using rule 57 (IF_EXPR -> EXP IF EXP ELSE EXP .)
    TILDE           reduce using rule 57 (IF_EXPR -> EXP IF EXP ELSE EXP .)
    WITH            reduce using rule 57 (IF_EXPR -> EXP IF EXP ELSE EXP .)
    CLOSE_BRACE     reduce using rule 57 (IF_EXPR -> EXP IF EXP ELSE EXP .)
    ENDSTATEMENT    reduce using rule 57 (IF_EXPR -> EXP IF EXP ELSE EXP .)
    EQUALS          reduce using rule 57 (IF_EXPR -> EXP IF EXP ELSE EXP .)
    ON              reduce using rule 57 (IF_EXPR -> EXP IF EXP ELSE EXP .)
    ELSE            reduce using rule 57 (IF_EXPR -> EXP IF EXP ELSE EXP .)
    CLOSE_PAREN     reduce using rule 57 (IF_EXPR -> EXP IF EXP ELSE EXP .)
    GIVEN           reduce using rule 57 (IF_EXPR -> EXP IF EXP ELSE EXP .)
    IF              shift and go to state 102

  ! IF              [ reduce using rule 57 (IF_EXPR -> EXP IF EXP ELSE EXP .) ]


state 167

    (55) LAMBDA_ABSTRACTION -> LAMBDA APAT APATS ARROW EXP .
    (57) IF_EXPR -> EXP . IF EXP ELSE EXP

  ! shift/reduce conflict for IF resolved as shift
    PLUS            reduce using rule 55 (LAMBDA_ABSTRACTION -> LAMBDA APAT APATS ARROW EXP .)
    MINUS           reduce using rule 55 (LAMBDA_ABSTRACTION -> LAMBDA APAT APATS ARROW EXP .)
    TIMES           reduce using rule 55 (LAMBDA_ABSTRACTION -> LAMBDA APAT APATS ARROW EXP .)
    DIVIDE          reduce using rule 55 (LAMBDA_ABSTRACTION -> LAMBDA APAT APATS ARROW EXP .)
    MODULO          reduce using rule 55 (LAMBDA_ABSTRACTION -> LAMBDA APAT APATS ARROW EXP .)
    FPOW            reduce using rule 55 (LAMBDA_ABSTRACTION -> LAMBDA APAT APATS ARROW EXP .)
    IPOW            reduce using rule 55 (LAMBDA_ABSTRACTION -> LAMBDA APAT APATS ARROW EXP .)
    EQUALITY        reduce using rule 55 (LAMBDA_ABSTRACTION -> LAMBDA APAT APATS ARROW EXP .)
    INEQUALITY      reduce using rule 55 (LAMBDA_ABSTRACTION -> LAMBDA APAT APATS ARROW EXP .)
    LESS            reduce using rule 55 (LAMBDA_ABSTRACTION -> LAMBDA APAT APATS ARROW EXP .)
    LEQ             reduce using rule 55 (LAMBDA_ABSTRACTION -> LAMBDA APAT APATS ARROW EXP .)
    GREATER         reduce using rule 55 (LAMBDA_ABSTRACTION -> LAMBDA APAT APATS ARROW EXP .)
    GEQ             reduce using rule 55 (LAMBDA_ABSTRACTION -> LAMBDA APAT APATS ARROW EXP .)
    CONCAT          reduce using rule 55 (LAMBDA_ABSTRACTION -> LAMBDA APAT APATS ARROW EXP .)
    AND             reduce using rule 55 (LAMBDA_ABSTRACTION -> LAMBDA APAT APATS ARROW EXP .)
    OR              reduce using rule 55 (LAMBDA_ABSTRACTION -> LAMBDA APAT APATS ARROW EXP .)
    TILDE           reduce using rule 55 (LAMBDA_ABSTRACTION -> LAMBDA APAT APATS ARROW EXP .)
    WITH            reduce using rule 55 (LAMBDA_ABSTRACTION -> LAMBDA APAT APATS ARROW EXP .)
    CLOSE_BRACE     reduce using rule 55 (LAMBDA_ABSTRACTION -> LAMBDA APAT APATS ARROW EXP .)
    ENDSTATEMENT    reduce using rule 55 (LAMBDA_ABSTRACTION -> LAMBDA APAT APATS ARROW EXP .)
    EQUALS          reduce using rule 55 (LAMBDA_ABSTRACTION -> LAMBDA APAT APATS ARROW EXP .)
    ON              reduce using rule 55 (LAMBDA_ABSTRACTION -> LAMBDA APAT APATS ARROW EXP .)
    ELSE            reduce using rule 55 (LAMBDA_ABSTRACTION -> LAMBDA APAT APATS ARROW EXP .)
    CLOSE_PAREN     reduce using rule 55 (LAMBDA_ABSTRACTION -> LAMBDA APAT APATS ARROW EXP .)
    GIVEN           reduce using rule 55 (LAMBDA_ABSTRACTION -> LAMBDA APAT APATS ARROW EXP .)
    IF              shift and go to state 102

  ! IF              [ reduce using rule 55 (LAMBDA_ABSTRACTION -> LAMBDA APAT APATS ARROW EXP .) ]


state 168

    (17) DECLARATIONS_LIST -> DECLARATION ENDSTATEMENT DECLARATIONS_LIST .

    CLOSE_BRACE     reduce using rule 17 (DECLARATIONS_LIST -> DECLARATION ENDSTATEMENT DECLARATIONS_LIST .)


state 169

    (58) MATCH_EXPR -> MATCH EXP ON OPEN_BRACE ALTS . CLOSE_BRACE

    CLOSE_BRACE     shift and go to state 174


state 170

    (67) ALTS -> ALT . ENDSTATEMENT ALTS
    (68) ALTS -> ALT .

    ENDSTATEMENT    shift and go to state 175
    CLOSE_BRACE     reduce using rule 68 (ALTS -> ALT .)


state 171

    (69) ALT -> LPAT . ARROW EXP

    ARROW           shift and go to state 176


state 172

    (35) ATYPE -> OPEN_PAREN TYPE CLOSE_PAREN .

    TYPENAME        reduce using rule 35 (ATYPE -> OPEN_PAREN TYPE CLOSE_PAREN .)
    IDENTIFIER      reduce using rule 35 (ATYPE -> OPEN_PAREN TYPE CLOSE_PAREN .)
    OPEN_PAREN      reduce using rule 35 (ATYPE -> OPEN_PAREN TYPE CLOSE_PAREN .)
    PIPE            reduce using rule 35 (ATYPE -> OPEN_PAREN TYPE CLOSE_PAREN .)
    CLOSE_BRACE     reduce using rule 35 (ATYPE -> OPEN_PAREN TYPE CLOSE_PAREN .)
    ENDSTATEMENT    reduce using rule 35 (ATYPE -> OPEN_PAREN TYPE CLOSE_PAREN .)
    ARROW           reduce using rule 35 (ATYPE -> OPEN_PAREN TYPE CLOSE_PAREN .)
    CLOSE_PAREN     reduce using rule 35 (ATYPE -> OPEN_PAREN TYPE CLOSE_PAREN .)


state 173

    (30) TYPE -> ATYPE ARROW . TYPE
    (29) TYPE -> . ATYPE
    (30) TYPE -> . ATYPE ARROW TYPE
    (33) ATYPE -> . TYPENAME
    (34) ATYPE -> . IDENTIFIER
    (35) ATYPE -> . OPEN_PAREN TYPE CLOSE_PAREN

    TYPENAME        shift and go to state 152
    IDENTIFIER      shift and go to state 154
    OPEN_PAREN      shift and go to state 155

    ATYPE                          shift and go to state 165
    TYPE                           shift and go to state 177

state 174

    (58) MATCH_EXPR -> MATCH EXP ON OPEN_BRACE ALTS CLOSE_BRACE .

    PLUS            reduce using rule 58 (MATCH_EXPR -> MATCH EXP ON OPEN_BRACE ALTS CLOSE_BRACE .)
    MINUS           reduce using rule 58 (MATCH_EXPR -> MATCH EXP ON OPEN_BRACE ALTS CLOSE_BRACE .)
    TIMES           reduce using rule 58 (MATCH_EXPR -> MATCH EXP ON OPEN_BRACE ALTS CLOSE_BRACE .)
    DIVIDE          reduce using rule 58 (MATCH_EXPR -> MATCH EXP ON OPEN_BRACE ALTS CLOSE_BRACE .)
    MODULO          reduce using rule 58 (MATCH_EXPR -> MATCH EXP ON OPEN_BRACE ALTS CLOSE_BRACE .)
    FPOW            reduce using rule 58 (MATCH_EXPR -> MATCH EXP ON OPEN_BRACE ALTS CLOSE_BRACE .)
    IPOW            reduce using rule 58 (MATCH_EXPR -> MATCH EXP ON OPEN_BRACE ALTS CLOSE_BRACE .)
    EQUALITY        reduce using rule 58 (MATCH_EXPR -> MATCH EXP ON OPEN_BRACE ALTS CLOSE_BRACE .)
    INEQUALITY      reduce using rule 58 (MATCH_EXPR -> MATCH EXP ON OPEN_BRACE ALTS CLOSE_BRACE .)
    LESS            reduce using rule 58 (MATCH_EXPR -> MATCH EXP ON OPEN_BRACE ALTS CLOSE_BRACE .)
    LEQ             reduce using rule 58 (MATCH_EXPR -> MATCH EXP ON OPEN_BRACE ALTS CLOSE_BRACE .)
    GREATER         reduce using rule 58 (MATCH_EXPR -> MATCH EXP ON OPEN_BRACE ALTS CLOSE_BRACE .)
    GEQ             reduce using rule 58 (MATCH_EXPR -> MATCH EXP ON OPEN_BRACE ALTS CLOSE_BRACE .)
    CONCAT          reduce using rule 58 (MATCH_EXPR -> MATCH EXP ON OPEN_BRACE ALTS CLOSE_BRACE .)
    AND             reduce using rule 58 (MATCH_EXPR -> MATCH EXP ON OPEN_BRACE ALTS CLOSE_BRACE .)
    OR              reduce using rule 58 (MATCH_EXPR -> MATCH EXP ON OPEN_BRACE ALTS CLOSE_BRACE .)
    TILDE           reduce using rule 58 (MATCH_EXPR -> MATCH EXP ON OPEN_BRACE ALTS CLOSE_BRACE .)
    WITH            reduce using rule 58 (MATCH_EXPR -> MATCH EXP ON OPEN_BRACE ALTS CLOSE_BRACE .)
    IF              reduce using rule 58 (MATCH_EXPR -> MATCH EXP ON OPEN_BRACE ALTS CLOSE_BRACE .)
    CLOSE_BRACE     reduce using rule 58 (MATCH_EXPR -> MATCH EXP ON OPEN_BRACE ALTS CLOSE_BRACE .)
    ENDSTATEMENT    reduce using rule 58 (MATCH_EXPR -> MATCH EXP ON OPEN_BRACE ALTS CLOSE_BRACE .)
    EQUALS          reduce using rule 58 (MATCH_EXPR -> MATCH EXP ON OPEN_BRACE ALTS CLOSE_BRACE .)
    ON              reduce using rule 58 (MATCH_EXPR -> MATCH EXP ON OPEN_BRACE ALTS CLOSE_BRACE .)
    ELSE            reduce using rule 58 (MATCH_EXPR -> MATCH EXP ON OPEN_BRACE ALTS CLOSE_BRACE .)
    CLOSE_PAREN     reduce using rule 58 (MATCH_EXPR -> MATCH EXP ON OPEN_BRACE ALTS CLOSE_BRACE .)
    GIVEN           reduce using rule 58 (MATCH_EXPR -> MATCH EXP ON OPEN_BRACE ALTS CLOSE_BRACE .)


state 175

    (67) ALTS -> ALT ENDSTATEMENT . ALTS
    (67) ALTS -> . ALT ENDSTATEMENT ALTS
    (68) ALTS -> . ALT
    (69) ALT -> . LPAT ARROW EXP
    (70) ALT -> .
    (71) LPAT -> . APAT
    (72) LPAT -> . CONSTRUCTOR_PATTERN
    (73) LPAT -> . NEGATIVE_LITERAL
    (77) APAT -> . PARAM
    (78) APAT -> . TYPENAME
    (79) APAT -> . LITERAL
    (80) APAT -> . OPEN_PAREN LPAT CLOSE_PAREN
    (74) CONSTRUCTOR_PATTERN -> . TYPENAME APAT APATS
    (75) NEGATIVE_LITERAL -> . MINUS INTEGER
    (76) NEGATIVE_LITERAL -> . MINUS FLOAT
    (108) PARAM -> . IDENTIFIER
    (102) LITERAL -> . FLOAT
    (103) LITERAL -> . INTEGER
    (104) LITERAL -> . BOOL
    (105) LITERAL -> . STRING

    ENDSTATEMENT    reduce using rule 70 (ALT -> .)
    CLOSE_BRACE     reduce using rule 70 (ALT -> .)
    TYPENAME        shift and go to state 16
    OPEN_PAREN      shift and go to state 43
    MINUS           shift and go to state 32
    IDENTIFIER      shift and go to state 44
    FLOAT           shift and go to state 33
    INTEGER         shift and go to state 23
    BOOL            shift and go to state 34
    STRING          shift and go to state 12

    ALT                            shift and go to state 170
    ALTS                           shift and go to state 178
    LPAT                           shift and go to state 171
    APAT                           shift and go to state 25
    CONSTRUCTOR_PATTERN            shift and go to state 29
    NEGATIVE_LITERAL               shift and go to state 30
    PARAM                          shift and go to state 42
    LITERAL                        shift and go to state 31

state 176

    (69) ALT -> LPAT ARROW . EXP
    (46) EXP -> . INFIX_EXP
    (47) INFIX_EXP -> . LEXP OP INFIX_EXP
    (48) INFIX_EXP -> . MINUS INFIX_EXP
    (49) INFIX_EXP -> . LEXP
    (50) LEXP -> . LAMBDA_ABSTRACTION
    (51) LEXP -> . LET_EXPR
    (52) LEXP -> . IF_EXPR
    (53) LEXP -> . MATCH_EXPR
    (54) LEXP -> . FUNCTION_EXPR
    (55) LAMBDA_ABSTRACTION -> . LAMBDA APAT APATS ARROW EXP
    (56) LET_EXPR -> . LET DECLARATIONS IN EXP
    (57) IF_EXPR -> . EXP IF EXP ELSE EXP
    (58) MATCH_EXPR -> . MATCH EXP ON OPEN_BRACE ALTS CLOSE_BRACE
    (59) FUNCTION_EXPR -> . FUNCTION_EXPR AEXP
    (60) FUNCTION_EXPR -> . AEXP
    (61) AEXP -> . USED_VAR
    (62) AEXP -> . USED_TYPENAME
    (63) AEXP -> . LITERAL
    (64) AEXP -> . OPERATOR_FUNC
    (65) AEXP -> . OPEN_PAREN EXP CLOSE_PAREN
    (106) USED_VAR -> . IDENTIFIER
    (107) USED_TYPENAME -> . TYPENAME
    (102) LITERAL -> . FLOAT
    (103) LITERAL -> . INTEGER
    (104) LITERAL -> . BOOL
    (105) LITERAL -> . STRING
    (66) OPERATOR_FUNC -> . OPEN_PAREN OP CLOSE_PAREN

    MINUS           shift and go to state 71
    LAMBDA          shift and go to state 77
    LET             shift and go to state 78
    MATCH           shift and go to state 79
    OPEN_PAREN      shift and go to state 85
    IDENTIFIER      shift and go to state 86
    TYPENAME        shift and go to state 87
    FLOAT           shift and go to state 33
    INTEGER         shift and go to state 23
    BOOL            shift and go to state 34
    STRING          shift and go to state 12

    EXP                            shift and go to state 179
    INFIX_EXP                      shift and go to state 69
    LEXP                           shift and go to state 70
    LAMBDA_ABSTRACTION             shift and go to state 72
    LET_EXPR                       shift and go to state 73
    IF_EXPR                        shift and go to state 74
    MATCH_EXPR                     shift and go to state 75
    FUNCTION_EXPR                  shift and go to state 76
    AEXP                           shift and go to state 80
    USED_VAR                       shift and go to state 81
    USED_TYPENAME                  shift and go to state 82
    LITERAL                        shift and go to state 83
    OPERATOR_FUNC                  shift and go to state 84

state 177

    (30) TYPE -> ATYPE ARROW TYPE .

    CLOSE_PAREN     reduce using rule 30 (TYPE -> ATYPE ARROW TYPE .)


state 178

    (67) ALTS -> ALT ENDSTATEMENT ALTS .

    CLOSE_BRACE     reduce using rule 67 (ALTS -> ALT ENDSTATEMENT ALTS .)


state 179

    (69) ALT -> LPAT ARROW EXP .
    (57) IF_EXPR -> EXP . IF EXP ELSE EXP

    ENDSTATEMENT    reduce using rule 69 (ALT -> LPAT ARROW EXP .)
    CLOSE_BRACE     reduce using rule 69 (ALT -> LPAT ARROW EXP .)
    IF              shift and go to state 102

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for PLUS in state 70 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 70 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 70 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 70 resolved as shift
WARNING: shift/reduce conflict for MODULO in state 70 resolved as shift
WARNING: shift/reduce conflict for FPOW in state 70 resolved as shift
WARNING: shift/reduce conflict for IPOW in state 70 resolved as shift
WARNING: shift/reduce conflict for EQUALITY in state 70 resolved as shift
WARNING: shift/reduce conflict for INEQUALITY in state 70 resolved as shift
WARNING: shift/reduce conflict for LESS in state 70 resolved as shift
WARNING: shift/reduce conflict for LEQ in state 70 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 70 resolved as shift
WARNING: shift/reduce conflict for GEQ in state 70 resolved as shift
WARNING: shift/reduce conflict for CONCAT in state 70 resolved as shift
WARNING: shift/reduce conflict for AND in state 70 resolved as shift
WARNING: shift/reduce conflict for OR in state 70 resolved as shift
WARNING: shift/reduce conflict for TILDE in state 70 resolved as shift
WARNING: shift/reduce conflict for CLOSE_BRACE in state 127 resolved as shift
WARNING: shift/reduce conflict for IF in state 159 resolved as shift
WARNING: shift/reduce conflict for IF in state 166 resolved as shift
WARNING: shift/reduce conflict for IF in state 167 resolved as shift
WARNING: reduce/reduce conflict in state 122 resolved using rule (EXP -> INFIX_EXP)
WARNING: rejected rule (INFIX_EXP -> MINUS INFIX_EXP) in state 122
WARNING: reduce/reduce conflict in state 141 resolved using rule (EXP -> INFIX_EXP)
WARNING: rejected rule (INFIX_EXP -> LEXP OP INFIX_EXP) in state 141
