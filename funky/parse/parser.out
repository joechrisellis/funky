Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    AS
    CLOSE_SQUARE
    COMMA
    OPEN_SQUARE
    WHITESPACE

Grammar

Rule 0     S' -> MODULE_DEFINITION
Rule 1     MODULE_DEFINITION -> MODULE IDENTIFIER WHERE BODY
Rule 2     BODY -> OPEN_BRACE IMPORT_DECLARATIONS ENDSTATEMENT TOP_DECLARATIONS CLOSE_BRACE
Rule 3     BODY -> OPEN_BRACE TOP_DECLARATIONS CLOSE_BRACE
Rule 4     IMPORT_DECLARATIONS -> IMPORT_DECLARATIONS ENDSTATEMENT IMPORT_DECLARATION
Rule 5     IMPORT_DECLARATIONS -> IMPORT_DECLARATION
Rule 6     IMPORT_DECLARATION -> IMPORT IDENTIFIER
Rule 7     TOP_DECLARATIONS -> TOP_DECLARATIONS ENDSTATEMENT TOP_DECLARATION
Rule 8     TOP_DECLARATIONS -> TOP_DECLARATION
Rule 9     TOP_DECLARATION -> NEWTYPE TYPENAME EQUALS TYPE
Rule 10    TOP_DECLARATION -> NEWCONS TYPENAME EQUALS CONSTRUCTORS
Rule 11    TOP_DECLARATION -> DECLARATION
Rule 12    CONSTRUCTORS -> CONSTRUCTORS PIPE CONSTRUCTOR
Rule 13    CONSTRUCTORS -> CONSTRUCTOR
Rule 14    CONSTRUCTOR -> TYPENAME ATYPES
Rule 15    DECLARATIONS -> OPEN_BRACE DECLARATIONS_LIST CLOSE_BRACE
Rule 16    DECLARATIONS -> OPEN_BRACE CLOSE_BRACE
Rule 17    DECLARATIONS_LIST -> DECLARATION ENDSTATEMENT DECLARATIONS_LIST
Rule 18    DECLARATIONS_LIST -> DECLARATION
Rule 19    DECLARATION -> GEN_DECLARATION
Rule 20    DECLARATION -> FUNCTION_LHS RHS
Rule 21    DECLARATION -> LPAT RHS
Rule 22    GEN_DECLARATION -> IDENTIFIER TYPESIG TYPE
Rule 23    GEN_DECLARATION -> SETFIX ASSOCIATIVITY INTEGER OP
Rule 24    GEN_DECLARATION -> <empty>
Rule 25    ASSOCIATIVITY -> LEFTASSOC
Rule 26    ASSOCIATIVITY -> RIGHTASSOC
Rule 27    ASSOCIATIVITY -> NONASSOC
Rule 28    TYPE -> ATYPE
Rule 29    TYPE -> ATYPE ARROW TYPE
Rule 30    ATYPES -> ATYPES ATYPE
Rule 31    ATYPES -> <empty>
Rule 32    ATYPE -> TYPENAME
Rule 33    ATYPE -> OPEN_PAREN TYPE CLOSE_PAREN
Rule 34    FUNCTION_LHS -> IDENTIFIER APAT APATS
Rule 35    FUNCTION_LHS -> LPAT VAROP LPAT
Rule 36    FUNCTION_LHS -> OPEN_PAREN FUNCTION_LHS CLOSE_PAREN APAT APATS
Rule 37    RHS -> EQUALS EXP
Rule 38    RHS -> EQUALS EXP WHERE DECLARATIONS
Rule 39    RHS -> GDRHS
Rule 40    RHS -> GDRHS WHERE DECLARATIONS
Rule 41    GDRHS -> PIPE EXP EQUALS EXP
Rule 42    GDRHS -> PIPE EXP EQUALS EXP GDRHS
Rule 43    EXP -> INFIX_EXP
Rule 44    INFIX_EXP -> LEXP OP INFIX_EXP
Rule 45    INFIX_EXP -> MINUS INFIX_EXP
Rule 46    INFIX_EXP -> LEXP
Rule 47    LEXP -> LAMBDA APAT APATS ARROW EXP
Rule 48    LEXP -> LET DECLARATIONS IN EXP
Rule 49    LEXP -> IF EXP THEN EXP ELSE EXP
Rule 50    LEXP -> MATCH EXP OF OPEN_BRACE ALTS CLOSE_BRACE
Rule 51    LEXP -> FEXP
Rule 52    FEXP -> FEXP AEXP
Rule 53    FEXP -> AEXP
Rule 54    AEXP -> USED_VAR
Rule 55    AEXP -> TYPENAME
Rule 56    AEXP -> LITERAL
Rule 57    AEXP -> OPEN_PAREN EXP CLOSE_PAREN
Rule 58    CONSTRUCTION_PARAMS -> CONSTRUCTION_PARAMS AEXP
Rule 59    CONSTRUCTION_PARAMS -> AEXP
Rule 60    ALTS -> ALT ENDSTATEMENT ALTS
Rule 61    ALTS -> ALT
Rule 62    ALT -> LPAT ARROW EXP
Rule 63    ALT -> <empty>
Rule 64    LPAT -> APAT
Rule 65    LPAT -> MINUS OPEN_PAREN INTEGER CLOSE_PAREN
Rule 66    LPAT -> MINUS OPEN_PAREN FLOAT CLOSE_PAREN
Rule 67    LPAT -> TYPENAME APAT APATS
Rule 68    APAT -> PARAM
Rule 69    APAT -> TYPENAME
Rule 70    APAT -> LITERAL
Rule 71    APAT -> OPEN_PAREN LPAT CLOSE_PAREN
Rule 72    VAROP -> VARSYM
Rule 73    VAROP -> BACKTICK IDENTIFIER BACKTICK
Rule 74    OP -> VAROP
Rule 75    APATS -> APAT APATS
Rule 76    APATS -> <empty>
Rule 77    VARSYM -> PLUS
Rule 78    VARSYM -> MINUS
Rule 79    VARSYM -> TIMES
Rule 80    VARSYM -> DIVIDE
Rule 81    VARSYM -> MODULO
Rule 82    VARSYM -> POW
Rule 83    VARSYM -> EQUALITY
Rule 84    VARSYM -> INEQUALITY
Rule 85    VARSYM -> LESS
Rule 86    VARSYM -> LEQ
Rule 87    VARSYM -> GREATER
Rule 88    VARSYM -> GEQ
Rule 89    VARSYM -> AND
Rule 90    VARSYM -> OR
Rule 91    VARSYM -> LIST_CONSTRUCTOR
Rule 92    LITERAL -> FLOAT
Rule 93    LITERAL -> INTEGER
Rule 94    LITERAL -> BOOL
Rule 95    LITERAL -> CHAR
Rule 96    LITERAL -> STRING
Rule 97    USED_VAR -> IDENTIFIER
Rule 98    PARAM -> IDENTIFIER

Terminals, with rules where they appear

AND                  : 89
ARROW                : 29 47 62
AS                   : 
BACKTICK             : 73 73
BOOL                 : 94
CHAR                 : 95
CLOSE_BRACE          : 2 3 15 16 50
CLOSE_PAREN          : 33 36 57 65 66 71
CLOSE_SQUARE         : 
COMMA                : 
DIVIDE               : 80
ELSE                 : 49
ENDSTATEMENT         : 2 4 7 17 60
EQUALITY             : 83
EQUALS               : 9 10 37 38 41 42
FLOAT                : 66 92
GEQ                  : 88
GREATER              : 87
IDENTIFIER           : 1 6 22 34 73 97 98
IF                   : 49
IMPORT               : 6
IN                   : 48
INEQUALITY           : 84
INTEGER              : 23 65 93
LAMBDA               : 47
LEFTASSOC            : 25
LEQ                  : 86
LESS                 : 85
LET                  : 48
LIST_CONSTRUCTOR     : 91
MATCH                : 50
MINUS                : 45 65 66 78
MODULE               : 1
MODULO               : 81
NEWCONS              : 10
NEWTYPE              : 9
NONASSOC             : 27
OF                   : 50
OPEN_BRACE           : 2 3 15 16 50
OPEN_PAREN           : 33 36 57 65 66 71
OPEN_SQUARE          : 
OR                   : 90
PIPE                 : 12 41 42
PLUS                 : 77
POW                  : 82
RIGHTASSOC           : 26
SETFIX               : 23
STRING               : 96
THEN                 : 49
TIMES                : 79
TYPENAME             : 9 10 14 32 55 67 69
TYPESIG              : 22
WHERE                : 1 38 40
WHITESPACE           : 
error                : 

Nonterminals, with rules where they appear

AEXP                 : 52 53 58 59
ALT                  : 60 61
ALTS                 : 50 60
APAT                 : 34 36 47 64 67 75
APATS                : 34 36 47 67 75
ASSOCIATIVITY        : 23
ATYPE                : 28 29 30
ATYPES               : 14 30
BODY                 : 1
CONSTRUCTION_PARAMS  : 58
CONSTRUCTOR          : 12 13
CONSTRUCTORS         : 10 12
DECLARATION          : 11 17 18
DECLARATIONS         : 38 40 48
DECLARATIONS_LIST    : 15 17
EXP                  : 37 38 41 41 42 42 47 48 49 49 49 50 57 62
FEXP                 : 51 52
FUNCTION_LHS         : 20 36
GDRHS                : 39 40 42
GEN_DECLARATION      : 19
IMPORT_DECLARATION   : 4 5
IMPORT_DECLARATIONS  : 2 4
INFIX_EXP            : 43 44 45
LEXP                 : 44 46
LITERAL              : 56 70
LPAT                 : 21 35 35 62 71
MODULE_DEFINITION    : 0
OP                   : 23 44
PARAM                : 68
RHS                  : 20 21
TOP_DECLARATION      : 7 8
TOP_DECLARATIONS     : 2 3 7
TYPE                 : 9 22 29 33
USED_VAR             : 54
VAROP                : 35 74
VARSYM               : 72

Parsing method: LALR

state 0

    (0) S' -> . MODULE_DEFINITION
    (1) MODULE_DEFINITION -> . MODULE IDENTIFIER WHERE BODY

    MODULE          shift and go to state 2

    MODULE_DEFINITION              shift and go to state 1

state 1

    (0) S' -> MODULE_DEFINITION .



state 2

    (1) MODULE_DEFINITION -> MODULE . IDENTIFIER WHERE BODY

    IDENTIFIER      shift and go to state 3


state 3

    (1) MODULE_DEFINITION -> MODULE IDENTIFIER . WHERE BODY

    WHERE           shift and go to state 4


state 4

    (1) MODULE_DEFINITION -> MODULE IDENTIFIER WHERE . BODY
    (2) BODY -> . OPEN_BRACE IMPORT_DECLARATIONS ENDSTATEMENT TOP_DECLARATIONS CLOSE_BRACE
    (3) BODY -> . OPEN_BRACE TOP_DECLARATIONS CLOSE_BRACE

    OPEN_BRACE      shift and go to state 6

    BODY                           shift and go to state 5

state 5

    (1) MODULE_DEFINITION -> MODULE IDENTIFIER WHERE BODY .

    $end            reduce using rule 1 (MODULE_DEFINITION -> MODULE IDENTIFIER WHERE BODY .)


state 6

    (2) BODY -> OPEN_BRACE . IMPORT_DECLARATIONS ENDSTATEMENT TOP_DECLARATIONS CLOSE_BRACE
    (3) BODY -> OPEN_BRACE . TOP_DECLARATIONS CLOSE_BRACE
    (4) IMPORT_DECLARATIONS -> . IMPORT_DECLARATIONS ENDSTATEMENT IMPORT_DECLARATION
    (5) IMPORT_DECLARATIONS -> . IMPORT_DECLARATION
    (7) TOP_DECLARATIONS -> . TOP_DECLARATIONS ENDSTATEMENT TOP_DECLARATION
    (8) TOP_DECLARATIONS -> . TOP_DECLARATION
    (6) IMPORT_DECLARATION -> . IMPORT IDENTIFIER
    (9) TOP_DECLARATION -> . NEWTYPE TYPENAME EQUALS TYPE
    (10) TOP_DECLARATION -> . NEWCONS TYPENAME EQUALS CONSTRUCTORS
    (11) TOP_DECLARATION -> . DECLARATION
    (19) DECLARATION -> . GEN_DECLARATION
    (20) DECLARATION -> . FUNCTION_LHS RHS
    (21) DECLARATION -> . LPAT RHS
    (22) GEN_DECLARATION -> . IDENTIFIER TYPESIG TYPE
    (23) GEN_DECLARATION -> . SETFIX ASSOCIATIVITY INTEGER OP
    (24) GEN_DECLARATION -> .
    (34) FUNCTION_LHS -> . IDENTIFIER APAT APATS
    (35) FUNCTION_LHS -> . LPAT VAROP LPAT
    (36) FUNCTION_LHS -> . OPEN_PAREN FUNCTION_LHS CLOSE_PAREN APAT APATS
    (64) LPAT -> . APAT
    (65) LPAT -> . MINUS OPEN_PAREN INTEGER CLOSE_PAREN
    (66) LPAT -> . MINUS OPEN_PAREN FLOAT CLOSE_PAREN
    (67) LPAT -> . TYPENAME APAT APATS
    (68) APAT -> . PARAM
    (69) APAT -> . TYPENAME
    (70) APAT -> . LITERAL
    (71) APAT -> . OPEN_PAREN LPAT CLOSE_PAREN
    (98) PARAM -> . IDENTIFIER
    (92) LITERAL -> . FLOAT
    (93) LITERAL -> . INTEGER
    (94) LITERAL -> . BOOL
    (95) LITERAL -> . CHAR
    (96) LITERAL -> . STRING

    IMPORT          shift and go to state 11
    NEWTYPE         shift and go to state 13
    NEWCONS         shift and go to state 15
    IDENTIFIER      shift and go to state 12
    SETFIX          shift and go to state 20
    CLOSE_BRACE     reduce using rule 24 (GEN_DECLARATION -> .)
    ENDSTATEMENT    reduce using rule 24 (GEN_DECLARATION -> .)
    OPEN_PAREN      shift and go to state 23
    MINUS           shift and go to state 24
    TYPENAME        shift and go to state 14
    FLOAT           shift and go to state 25
    INTEGER         shift and go to state 21
    BOOL            shift and go to state 28
    CHAR            shift and go to state 29
    STRING          shift and go to state 30

    IMPORT_DECLARATIONS            shift and go to state 7
    TOP_DECLARATIONS               shift and go to state 8
    IMPORT_DECLARATION             shift and go to state 9
    TOP_DECLARATION                shift and go to state 10
    DECLARATION                    shift and go to state 16
    GEN_DECLARATION                shift and go to state 17
    FUNCTION_LHS                   shift and go to state 18
    LPAT                           shift and go to state 19
    APAT                           shift and go to state 22
    PARAM                          shift and go to state 26
    LITERAL                        shift and go to state 27

state 7

    (2) BODY -> OPEN_BRACE IMPORT_DECLARATIONS . ENDSTATEMENT TOP_DECLARATIONS CLOSE_BRACE
    (4) IMPORT_DECLARATIONS -> IMPORT_DECLARATIONS . ENDSTATEMENT IMPORT_DECLARATION

    ENDSTATEMENT    shift and go to state 31


state 8

    (3) BODY -> OPEN_BRACE TOP_DECLARATIONS . CLOSE_BRACE
    (7) TOP_DECLARATIONS -> TOP_DECLARATIONS . ENDSTATEMENT TOP_DECLARATION

    CLOSE_BRACE     shift and go to state 32
    ENDSTATEMENT    shift and go to state 33


state 9

    (5) IMPORT_DECLARATIONS -> IMPORT_DECLARATION .

    ENDSTATEMENT    reduce using rule 5 (IMPORT_DECLARATIONS -> IMPORT_DECLARATION .)


state 10

    (8) TOP_DECLARATIONS -> TOP_DECLARATION .

    CLOSE_BRACE     reduce using rule 8 (TOP_DECLARATIONS -> TOP_DECLARATION .)
    ENDSTATEMENT    reduce using rule 8 (TOP_DECLARATIONS -> TOP_DECLARATION .)


state 11

    (6) IMPORT_DECLARATION -> IMPORT . IDENTIFIER

    IDENTIFIER      shift and go to state 34


state 12

    (22) GEN_DECLARATION -> IDENTIFIER . TYPESIG TYPE
    (34) FUNCTION_LHS -> IDENTIFIER . APAT APATS
    (98) PARAM -> IDENTIFIER .
    (68) APAT -> . PARAM
    (69) APAT -> . TYPENAME
    (70) APAT -> . LITERAL
    (71) APAT -> . OPEN_PAREN LPAT CLOSE_PAREN
    (98) PARAM -> . IDENTIFIER
    (92) LITERAL -> . FLOAT
    (93) LITERAL -> . INTEGER
    (94) LITERAL -> . BOOL
    (95) LITERAL -> . CHAR
    (96) LITERAL -> . STRING

    TYPESIG         shift and go to state 36
    EQUALS          reduce using rule 98 (PARAM -> IDENTIFIER .)
    BACKTICK        reduce using rule 98 (PARAM -> IDENTIFIER .)
    PIPE            reduce using rule 98 (PARAM -> IDENTIFIER .)
    PLUS            reduce using rule 98 (PARAM -> IDENTIFIER .)
    MINUS           reduce using rule 98 (PARAM -> IDENTIFIER .)
    TIMES           reduce using rule 98 (PARAM -> IDENTIFIER .)
    DIVIDE          reduce using rule 98 (PARAM -> IDENTIFIER .)
    MODULO          reduce using rule 98 (PARAM -> IDENTIFIER .)
    POW             reduce using rule 98 (PARAM -> IDENTIFIER .)
    EQUALITY        reduce using rule 98 (PARAM -> IDENTIFIER .)
    INEQUALITY      reduce using rule 98 (PARAM -> IDENTIFIER .)
    LESS            reduce using rule 98 (PARAM -> IDENTIFIER .)
    LEQ             reduce using rule 98 (PARAM -> IDENTIFIER .)
    GREATER         reduce using rule 98 (PARAM -> IDENTIFIER .)
    GEQ             reduce using rule 98 (PARAM -> IDENTIFIER .)
    AND             reduce using rule 98 (PARAM -> IDENTIFIER .)
    OR              reduce using rule 98 (PARAM -> IDENTIFIER .)
    LIST_CONSTRUCTOR reduce using rule 98 (PARAM -> IDENTIFIER .)
    TYPENAME        shift and go to state 38
    OPEN_PAREN      shift and go to state 39
    IDENTIFIER      shift and go to state 35
    FLOAT           shift and go to state 25
    INTEGER         shift and go to state 21
    BOOL            shift and go to state 28
    CHAR            shift and go to state 29
    STRING          shift and go to state 30

    APAT                           shift and go to state 37
    PARAM                          shift and go to state 26
    LITERAL                        shift and go to state 27

state 13

    (9) TOP_DECLARATION -> NEWTYPE . TYPENAME EQUALS TYPE

    TYPENAME        shift and go to state 40


state 14

    (67) LPAT -> TYPENAME . APAT APATS
    (69) APAT -> TYPENAME .
    (68) APAT -> . PARAM
    (69) APAT -> . TYPENAME
    (70) APAT -> . LITERAL
    (71) APAT -> . OPEN_PAREN LPAT CLOSE_PAREN
    (98) PARAM -> . IDENTIFIER
    (92) LITERAL -> . FLOAT
    (93) LITERAL -> . INTEGER
    (94) LITERAL -> . BOOL
    (95) LITERAL -> . CHAR
    (96) LITERAL -> . STRING

    EQUALS          reduce using rule 69 (APAT -> TYPENAME .)
    BACKTICK        reduce using rule 69 (APAT -> TYPENAME .)
    PIPE            reduce using rule 69 (APAT -> TYPENAME .)
    PLUS            reduce using rule 69 (APAT -> TYPENAME .)
    MINUS           reduce using rule 69 (APAT -> TYPENAME .)
    TIMES           reduce using rule 69 (APAT -> TYPENAME .)
    DIVIDE          reduce using rule 69 (APAT -> TYPENAME .)
    MODULO          reduce using rule 69 (APAT -> TYPENAME .)
    POW             reduce using rule 69 (APAT -> TYPENAME .)
    EQUALITY        reduce using rule 69 (APAT -> TYPENAME .)
    INEQUALITY      reduce using rule 69 (APAT -> TYPENAME .)
    LESS            reduce using rule 69 (APAT -> TYPENAME .)
    LEQ             reduce using rule 69 (APAT -> TYPENAME .)
    GREATER         reduce using rule 69 (APAT -> TYPENAME .)
    GEQ             reduce using rule 69 (APAT -> TYPENAME .)
    AND             reduce using rule 69 (APAT -> TYPENAME .)
    OR              reduce using rule 69 (APAT -> TYPENAME .)
    LIST_CONSTRUCTOR reduce using rule 69 (APAT -> TYPENAME .)
    CLOSE_PAREN     reduce using rule 69 (APAT -> TYPENAME .)
    ARROW           reduce using rule 69 (APAT -> TYPENAME .)
    TYPENAME        shift and go to state 38
    OPEN_PAREN      shift and go to state 39
    IDENTIFIER      shift and go to state 35
    FLOAT           shift and go to state 25
    INTEGER         shift and go to state 21
    BOOL            shift and go to state 28
    CHAR            shift and go to state 29
    STRING          shift and go to state 30

    APAT                           shift and go to state 41
    PARAM                          shift and go to state 26
    LITERAL                        shift and go to state 27

state 15

    (10) TOP_DECLARATION -> NEWCONS . TYPENAME EQUALS CONSTRUCTORS

    TYPENAME        shift and go to state 42


state 16

    (11) TOP_DECLARATION -> DECLARATION .

    CLOSE_BRACE     reduce using rule 11 (TOP_DECLARATION -> DECLARATION .)
    ENDSTATEMENT    reduce using rule 11 (TOP_DECLARATION -> DECLARATION .)


state 17

    (19) DECLARATION -> GEN_DECLARATION .

    CLOSE_BRACE     reduce using rule 19 (DECLARATION -> GEN_DECLARATION .)
    ENDSTATEMENT    reduce using rule 19 (DECLARATION -> GEN_DECLARATION .)


state 18

    (20) DECLARATION -> FUNCTION_LHS . RHS
    (37) RHS -> . EQUALS EXP
    (38) RHS -> . EQUALS EXP WHERE DECLARATIONS
    (39) RHS -> . GDRHS
    (40) RHS -> . GDRHS WHERE DECLARATIONS
    (41) GDRHS -> . PIPE EXP EQUALS EXP
    (42) GDRHS -> . PIPE EXP EQUALS EXP GDRHS

    EQUALS          shift and go to state 44
    PIPE            shift and go to state 46

    RHS                            shift and go to state 43
    GDRHS                          shift and go to state 45

state 19

    (21) DECLARATION -> LPAT . RHS
    (35) FUNCTION_LHS -> LPAT . VAROP LPAT
    (37) RHS -> . EQUALS EXP
    (38) RHS -> . EQUALS EXP WHERE DECLARATIONS
    (39) RHS -> . GDRHS
    (40) RHS -> . GDRHS WHERE DECLARATIONS
    (72) VAROP -> . VARSYM
    (73) VAROP -> . BACKTICK IDENTIFIER BACKTICK
    (41) GDRHS -> . PIPE EXP EQUALS EXP
    (42) GDRHS -> . PIPE EXP EQUALS EXP GDRHS
    (77) VARSYM -> . PLUS
    (78) VARSYM -> . MINUS
    (79) VARSYM -> . TIMES
    (80) VARSYM -> . DIVIDE
    (81) VARSYM -> . MODULO
    (82) VARSYM -> . POW
    (83) VARSYM -> . EQUALITY
    (84) VARSYM -> . INEQUALITY
    (85) VARSYM -> . LESS
    (86) VARSYM -> . LEQ
    (87) VARSYM -> . GREATER
    (88) VARSYM -> . GEQ
    (89) VARSYM -> . AND
    (90) VARSYM -> . OR
    (91) VARSYM -> . LIST_CONSTRUCTOR

    EQUALS          shift and go to state 44
    BACKTICK        shift and go to state 50
    PIPE            shift and go to state 46
    PLUS            shift and go to state 51
    MINUS           shift and go to state 52
    TIMES           shift and go to state 53
    DIVIDE          shift and go to state 54
    MODULO          shift and go to state 55
    POW             shift and go to state 56
    EQUALITY        shift and go to state 57
    INEQUALITY      shift and go to state 58
    LESS            shift and go to state 59
    LEQ             shift and go to state 60
    GREATER         shift and go to state 61
    GEQ             shift and go to state 62
    AND             shift and go to state 63
    OR              shift and go to state 64
    LIST_CONSTRUCTOR shift and go to state 65

    RHS                            shift and go to state 47
    VAROP                          shift and go to state 48
    GDRHS                          shift and go to state 45
    VARSYM                         shift and go to state 49

state 20

    (23) GEN_DECLARATION -> SETFIX . ASSOCIATIVITY INTEGER OP
    (25) ASSOCIATIVITY -> . LEFTASSOC
    (26) ASSOCIATIVITY -> . RIGHTASSOC
    (27) ASSOCIATIVITY -> . NONASSOC

    LEFTASSOC       shift and go to state 67
    RIGHTASSOC      shift and go to state 68
    NONASSOC        shift and go to state 69

    ASSOCIATIVITY                  shift and go to state 66

state 21

    (93) LITERAL -> INTEGER .

    EQUALS          reduce using rule 93 (LITERAL -> INTEGER .)
    BACKTICK        reduce using rule 93 (LITERAL -> INTEGER .)
    PIPE            reduce using rule 93 (LITERAL -> INTEGER .)
    PLUS            reduce using rule 93 (LITERAL -> INTEGER .)
    MINUS           reduce using rule 93 (LITERAL -> INTEGER .)
    TIMES           reduce using rule 93 (LITERAL -> INTEGER .)
    DIVIDE          reduce using rule 93 (LITERAL -> INTEGER .)
    MODULO          reduce using rule 93 (LITERAL -> INTEGER .)
    POW             reduce using rule 93 (LITERAL -> INTEGER .)
    EQUALITY        reduce using rule 93 (LITERAL -> INTEGER .)
    INEQUALITY      reduce using rule 93 (LITERAL -> INTEGER .)
    LESS            reduce using rule 93 (LITERAL -> INTEGER .)
    LEQ             reduce using rule 93 (LITERAL -> INTEGER .)
    GREATER         reduce using rule 93 (LITERAL -> INTEGER .)
    GEQ             reduce using rule 93 (LITERAL -> INTEGER .)
    AND             reduce using rule 93 (LITERAL -> INTEGER .)
    OR              reduce using rule 93 (LITERAL -> INTEGER .)
    LIST_CONSTRUCTOR reduce using rule 93 (LITERAL -> INTEGER .)
    TYPENAME        reduce using rule 93 (LITERAL -> INTEGER .)
    OPEN_PAREN      reduce using rule 93 (LITERAL -> INTEGER .)
    IDENTIFIER      reduce using rule 93 (LITERAL -> INTEGER .)
    FLOAT           reduce using rule 93 (LITERAL -> INTEGER .)
    INTEGER         reduce using rule 93 (LITERAL -> INTEGER .)
    BOOL            reduce using rule 93 (LITERAL -> INTEGER .)
    CHAR            reduce using rule 93 (LITERAL -> INTEGER .)
    STRING          reduce using rule 93 (LITERAL -> INTEGER .)
    CLOSE_PAREN     reduce using rule 93 (LITERAL -> INTEGER .)
    ARROW           reduce using rule 93 (LITERAL -> INTEGER .)
    WHERE           reduce using rule 93 (LITERAL -> INTEGER .)
    CLOSE_BRACE     reduce using rule 93 (LITERAL -> INTEGER .)
    ENDSTATEMENT    reduce using rule 93 (LITERAL -> INTEGER .)
    THEN            reduce using rule 93 (LITERAL -> INTEGER .)
    OF              reduce using rule 93 (LITERAL -> INTEGER .)
    ELSE            reduce using rule 93 (LITERAL -> INTEGER .)


state 22

    (64) LPAT -> APAT .

    EQUALS          reduce using rule 64 (LPAT -> APAT .)
    BACKTICK        reduce using rule 64 (LPAT -> APAT .)
    PIPE            reduce using rule 64 (LPAT -> APAT .)
    PLUS            reduce using rule 64 (LPAT -> APAT .)
    MINUS           reduce using rule 64 (LPAT -> APAT .)
    TIMES           reduce using rule 64 (LPAT -> APAT .)
    DIVIDE          reduce using rule 64 (LPAT -> APAT .)
    MODULO          reduce using rule 64 (LPAT -> APAT .)
    POW             reduce using rule 64 (LPAT -> APAT .)
    EQUALITY        reduce using rule 64 (LPAT -> APAT .)
    INEQUALITY      reduce using rule 64 (LPAT -> APAT .)
    LESS            reduce using rule 64 (LPAT -> APAT .)
    LEQ             reduce using rule 64 (LPAT -> APAT .)
    GREATER         reduce using rule 64 (LPAT -> APAT .)
    GEQ             reduce using rule 64 (LPAT -> APAT .)
    AND             reduce using rule 64 (LPAT -> APAT .)
    OR              reduce using rule 64 (LPAT -> APAT .)
    LIST_CONSTRUCTOR reduce using rule 64 (LPAT -> APAT .)
    CLOSE_PAREN     reduce using rule 64 (LPAT -> APAT .)
    ARROW           reduce using rule 64 (LPAT -> APAT .)


state 23

    (36) FUNCTION_LHS -> OPEN_PAREN . FUNCTION_LHS CLOSE_PAREN APAT APATS
    (71) APAT -> OPEN_PAREN . LPAT CLOSE_PAREN
    (34) FUNCTION_LHS -> . IDENTIFIER APAT APATS
    (35) FUNCTION_LHS -> . LPAT VAROP LPAT
    (36) FUNCTION_LHS -> . OPEN_PAREN FUNCTION_LHS CLOSE_PAREN APAT APATS
    (64) LPAT -> . APAT
    (65) LPAT -> . MINUS OPEN_PAREN INTEGER CLOSE_PAREN
    (66) LPAT -> . MINUS OPEN_PAREN FLOAT CLOSE_PAREN
    (67) LPAT -> . TYPENAME APAT APATS
    (68) APAT -> . PARAM
    (69) APAT -> . TYPENAME
    (70) APAT -> . LITERAL
    (71) APAT -> . OPEN_PAREN LPAT CLOSE_PAREN
    (98) PARAM -> . IDENTIFIER
    (92) LITERAL -> . FLOAT
    (93) LITERAL -> . INTEGER
    (94) LITERAL -> . BOOL
    (95) LITERAL -> . CHAR
    (96) LITERAL -> . STRING

    IDENTIFIER      shift and go to state 72
    OPEN_PAREN      shift and go to state 23
    MINUS           shift and go to state 24
    TYPENAME        shift and go to state 14
    FLOAT           shift and go to state 25
    INTEGER         shift and go to state 21
    BOOL            shift and go to state 28
    CHAR            shift and go to state 29
    STRING          shift and go to state 30

    FUNCTION_LHS                   shift and go to state 70
    APAT                           shift and go to state 22
    LPAT                           shift and go to state 71
    PARAM                          shift and go to state 26
    LITERAL                        shift and go to state 27

state 24

    (65) LPAT -> MINUS . OPEN_PAREN INTEGER CLOSE_PAREN
    (66) LPAT -> MINUS . OPEN_PAREN FLOAT CLOSE_PAREN

    OPEN_PAREN      shift and go to state 73


state 25

    (92) LITERAL -> FLOAT .

    EQUALS          reduce using rule 92 (LITERAL -> FLOAT .)
    BACKTICK        reduce using rule 92 (LITERAL -> FLOAT .)
    PIPE            reduce using rule 92 (LITERAL -> FLOAT .)
    PLUS            reduce using rule 92 (LITERAL -> FLOAT .)
    MINUS           reduce using rule 92 (LITERAL -> FLOAT .)
    TIMES           reduce using rule 92 (LITERAL -> FLOAT .)
    DIVIDE          reduce using rule 92 (LITERAL -> FLOAT .)
    MODULO          reduce using rule 92 (LITERAL -> FLOAT .)
    POW             reduce using rule 92 (LITERAL -> FLOAT .)
    EQUALITY        reduce using rule 92 (LITERAL -> FLOAT .)
    INEQUALITY      reduce using rule 92 (LITERAL -> FLOAT .)
    LESS            reduce using rule 92 (LITERAL -> FLOAT .)
    LEQ             reduce using rule 92 (LITERAL -> FLOAT .)
    GREATER         reduce using rule 92 (LITERAL -> FLOAT .)
    GEQ             reduce using rule 92 (LITERAL -> FLOAT .)
    AND             reduce using rule 92 (LITERAL -> FLOAT .)
    OR              reduce using rule 92 (LITERAL -> FLOAT .)
    LIST_CONSTRUCTOR reduce using rule 92 (LITERAL -> FLOAT .)
    TYPENAME        reduce using rule 92 (LITERAL -> FLOAT .)
    OPEN_PAREN      reduce using rule 92 (LITERAL -> FLOAT .)
    IDENTIFIER      reduce using rule 92 (LITERAL -> FLOAT .)
    FLOAT           reduce using rule 92 (LITERAL -> FLOAT .)
    INTEGER         reduce using rule 92 (LITERAL -> FLOAT .)
    BOOL            reduce using rule 92 (LITERAL -> FLOAT .)
    CHAR            reduce using rule 92 (LITERAL -> FLOAT .)
    STRING          reduce using rule 92 (LITERAL -> FLOAT .)
    CLOSE_PAREN     reduce using rule 92 (LITERAL -> FLOAT .)
    ARROW           reduce using rule 92 (LITERAL -> FLOAT .)
    WHERE           reduce using rule 92 (LITERAL -> FLOAT .)
    CLOSE_BRACE     reduce using rule 92 (LITERAL -> FLOAT .)
    ENDSTATEMENT    reduce using rule 92 (LITERAL -> FLOAT .)
    THEN            reduce using rule 92 (LITERAL -> FLOAT .)
    OF              reduce using rule 92 (LITERAL -> FLOAT .)
    ELSE            reduce using rule 92 (LITERAL -> FLOAT .)


state 26

    (68) APAT -> PARAM .

    EQUALS          reduce using rule 68 (APAT -> PARAM .)
    BACKTICK        reduce using rule 68 (APAT -> PARAM .)
    PIPE            reduce using rule 68 (APAT -> PARAM .)
    PLUS            reduce using rule 68 (APAT -> PARAM .)
    MINUS           reduce using rule 68 (APAT -> PARAM .)
    TIMES           reduce using rule 68 (APAT -> PARAM .)
    DIVIDE          reduce using rule 68 (APAT -> PARAM .)
    MODULO          reduce using rule 68 (APAT -> PARAM .)
    POW             reduce using rule 68 (APAT -> PARAM .)
    EQUALITY        reduce using rule 68 (APAT -> PARAM .)
    INEQUALITY      reduce using rule 68 (APAT -> PARAM .)
    LESS            reduce using rule 68 (APAT -> PARAM .)
    LEQ             reduce using rule 68 (APAT -> PARAM .)
    GREATER         reduce using rule 68 (APAT -> PARAM .)
    GEQ             reduce using rule 68 (APAT -> PARAM .)
    AND             reduce using rule 68 (APAT -> PARAM .)
    OR              reduce using rule 68 (APAT -> PARAM .)
    LIST_CONSTRUCTOR reduce using rule 68 (APAT -> PARAM .)
    TYPENAME        reduce using rule 68 (APAT -> PARAM .)
    OPEN_PAREN      reduce using rule 68 (APAT -> PARAM .)
    IDENTIFIER      reduce using rule 68 (APAT -> PARAM .)
    FLOAT           reduce using rule 68 (APAT -> PARAM .)
    INTEGER         reduce using rule 68 (APAT -> PARAM .)
    BOOL            reduce using rule 68 (APAT -> PARAM .)
    CHAR            reduce using rule 68 (APAT -> PARAM .)
    STRING          reduce using rule 68 (APAT -> PARAM .)
    CLOSE_PAREN     reduce using rule 68 (APAT -> PARAM .)
    ARROW           reduce using rule 68 (APAT -> PARAM .)


state 27

    (70) APAT -> LITERAL .

    EQUALS          reduce using rule 70 (APAT -> LITERAL .)
    BACKTICK        reduce using rule 70 (APAT -> LITERAL .)
    PIPE            reduce using rule 70 (APAT -> LITERAL .)
    PLUS            reduce using rule 70 (APAT -> LITERAL .)
    MINUS           reduce using rule 70 (APAT -> LITERAL .)
    TIMES           reduce using rule 70 (APAT -> LITERAL .)
    DIVIDE          reduce using rule 70 (APAT -> LITERAL .)
    MODULO          reduce using rule 70 (APAT -> LITERAL .)
    POW             reduce using rule 70 (APAT -> LITERAL .)
    EQUALITY        reduce using rule 70 (APAT -> LITERAL .)
    INEQUALITY      reduce using rule 70 (APAT -> LITERAL .)
    LESS            reduce using rule 70 (APAT -> LITERAL .)
    LEQ             reduce using rule 70 (APAT -> LITERAL .)
    GREATER         reduce using rule 70 (APAT -> LITERAL .)
    GEQ             reduce using rule 70 (APAT -> LITERAL .)
    AND             reduce using rule 70 (APAT -> LITERAL .)
    OR              reduce using rule 70 (APAT -> LITERAL .)
    LIST_CONSTRUCTOR reduce using rule 70 (APAT -> LITERAL .)
    TYPENAME        reduce using rule 70 (APAT -> LITERAL .)
    OPEN_PAREN      reduce using rule 70 (APAT -> LITERAL .)
    IDENTIFIER      reduce using rule 70 (APAT -> LITERAL .)
    FLOAT           reduce using rule 70 (APAT -> LITERAL .)
    INTEGER         reduce using rule 70 (APAT -> LITERAL .)
    BOOL            reduce using rule 70 (APAT -> LITERAL .)
    CHAR            reduce using rule 70 (APAT -> LITERAL .)
    STRING          reduce using rule 70 (APAT -> LITERAL .)
    CLOSE_PAREN     reduce using rule 70 (APAT -> LITERAL .)
    ARROW           reduce using rule 70 (APAT -> LITERAL .)


state 28

    (94) LITERAL -> BOOL .

    EQUALS          reduce using rule 94 (LITERAL -> BOOL .)
    BACKTICK        reduce using rule 94 (LITERAL -> BOOL .)
    PIPE            reduce using rule 94 (LITERAL -> BOOL .)
    PLUS            reduce using rule 94 (LITERAL -> BOOL .)
    MINUS           reduce using rule 94 (LITERAL -> BOOL .)
    TIMES           reduce using rule 94 (LITERAL -> BOOL .)
    DIVIDE          reduce using rule 94 (LITERAL -> BOOL .)
    MODULO          reduce using rule 94 (LITERAL -> BOOL .)
    POW             reduce using rule 94 (LITERAL -> BOOL .)
    EQUALITY        reduce using rule 94 (LITERAL -> BOOL .)
    INEQUALITY      reduce using rule 94 (LITERAL -> BOOL .)
    LESS            reduce using rule 94 (LITERAL -> BOOL .)
    LEQ             reduce using rule 94 (LITERAL -> BOOL .)
    GREATER         reduce using rule 94 (LITERAL -> BOOL .)
    GEQ             reduce using rule 94 (LITERAL -> BOOL .)
    AND             reduce using rule 94 (LITERAL -> BOOL .)
    OR              reduce using rule 94 (LITERAL -> BOOL .)
    LIST_CONSTRUCTOR reduce using rule 94 (LITERAL -> BOOL .)
    TYPENAME        reduce using rule 94 (LITERAL -> BOOL .)
    OPEN_PAREN      reduce using rule 94 (LITERAL -> BOOL .)
    IDENTIFIER      reduce using rule 94 (LITERAL -> BOOL .)
    FLOAT           reduce using rule 94 (LITERAL -> BOOL .)
    INTEGER         reduce using rule 94 (LITERAL -> BOOL .)
    BOOL            reduce using rule 94 (LITERAL -> BOOL .)
    CHAR            reduce using rule 94 (LITERAL -> BOOL .)
    STRING          reduce using rule 94 (LITERAL -> BOOL .)
    CLOSE_PAREN     reduce using rule 94 (LITERAL -> BOOL .)
    ARROW           reduce using rule 94 (LITERAL -> BOOL .)
    WHERE           reduce using rule 94 (LITERAL -> BOOL .)
    CLOSE_BRACE     reduce using rule 94 (LITERAL -> BOOL .)
    ENDSTATEMENT    reduce using rule 94 (LITERAL -> BOOL .)
    THEN            reduce using rule 94 (LITERAL -> BOOL .)
    OF              reduce using rule 94 (LITERAL -> BOOL .)
    ELSE            reduce using rule 94 (LITERAL -> BOOL .)


state 29

    (95) LITERAL -> CHAR .

    EQUALS          reduce using rule 95 (LITERAL -> CHAR .)
    BACKTICK        reduce using rule 95 (LITERAL -> CHAR .)
    PIPE            reduce using rule 95 (LITERAL -> CHAR .)
    PLUS            reduce using rule 95 (LITERAL -> CHAR .)
    MINUS           reduce using rule 95 (LITERAL -> CHAR .)
    TIMES           reduce using rule 95 (LITERAL -> CHAR .)
    DIVIDE          reduce using rule 95 (LITERAL -> CHAR .)
    MODULO          reduce using rule 95 (LITERAL -> CHAR .)
    POW             reduce using rule 95 (LITERAL -> CHAR .)
    EQUALITY        reduce using rule 95 (LITERAL -> CHAR .)
    INEQUALITY      reduce using rule 95 (LITERAL -> CHAR .)
    LESS            reduce using rule 95 (LITERAL -> CHAR .)
    LEQ             reduce using rule 95 (LITERAL -> CHAR .)
    GREATER         reduce using rule 95 (LITERAL -> CHAR .)
    GEQ             reduce using rule 95 (LITERAL -> CHAR .)
    AND             reduce using rule 95 (LITERAL -> CHAR .)
    OR              reduce using rule 95 (LITERAL -> CHAR .)
    LIST_CONSTRUCTOR reduce using rule 95 (LITERAL -> CHAR .)
    TYPENAME        reduce using rule 95 (LITERAL -> CHAR .)
    OPEN_PAREN      reduce using rule 95 (LITERAL -> CHAR .)
    IDENTIFIER      reduce using rule 95 (LITERAL -> CHAR .)
    FLOAT           reduce using rule 95 (LITERAL -> CHAR .)
    INTEGER         reduce using rule 95 (LITERAL -> CHAR .)
    BOOL            reduce using rule 95 (LITERAL -> CHAR .)
    CHAR            reduce using rule 95 (LITERAL -> CHAR .)
    STRING          reduce using rule 95 (LITERAL -> CHAR .)
    CLOSE_PAREN     reduce using rule 95 (LITERAL -> CHAR .)
    ARROW           reduce using rule 95 (LITERAL -> CHAR .)
    WHERE           reduce using rule 95 (LITERAL -> CHAR .)
    CLOSE_BRACE     reduce using rule 95 (LITERAL -> CHAR .)
    ENDSTATEMENT    reduce using rule 95 (LITERAL -> CHAR .)
    THEN            reduce using rule 95 (LITERAL -> CHAR .)
    OF              reduce using rule 95 (LITERAL -> CHAR .)
    ELSE            reduce using rule 95 (LITERAL -> CHAR .)


state 30

    (96) LITERAL -> STRING .

    EQUALS          reduce using rule 96 (LITERAL -> STRING .)
    BACKTICK        reduce using rule 96 (LITERAL -> STRING .)
    PIPE            reduce using rule 96 (LITERAL -> STRING .)
    PLUS            reduce using rule 96 (LITERAL -> STRING .)
    MINUS           reduce using rule 96 (LITERAL -> STRING .)
    TIMES           reduce using rule 96 (LITERAL -> STRING .)
    DIVIDE          reduce using rule 96 (LITERAL -> STRING .)
    MODULO          reduce using rule 96 (LITERAL -> STRING .)
    POW             reduce using rule 96 (LITERAL -> STRING .)
    EQUALITY        reduce using rule 96 (LITERAL -> STRING .)
    INEQUALITY      reduce using rule 96 (LITERAL -> STRING .)
    LESS            reduce using rule 96 (LITERAL -> STRING .)
    LEQ             reduce using rule 96 (LITERAL -> STRING .)
    GREATER         reduce using rule 96 (LITERAL -> STRING .)
    GEQ             reduce using rule 96 (LITERAL -> STRING .)
    AND             reduce using rule 96 (LITERAL -> STRING .)
    OR              reduce using rule 96 (LITERAL -> STRING .)
    LIST_CONSTRUCTOR reduce using rule 96 (LITERAL -> STRING .)
    TYPENAME        reduce using rule 96 (LITERAL -> STRING .)
    OPEN_PAREN      reduce using rule 96 (LITERAL -> STRING .)
    IDENTIFIER      reduce using rule 96 (LITERAL -> STRING .)
    FLOAT           reduce using rule 96 (LITERAL -> STRING .)
    INTEGER         reduce using rule 96 (LITERAL -> STRING .)
    BOOL            reduce using rule 96 (LITERAL -> STRING .)
    CHAR            reduce using rule 96 (LITERAL -> STRING .)
    STRING          reduce using rule 96 (LITERAL -> STRING .)
    CLOSE_PAREN     reduce using rule 96 (LITERAL -> STRING .)
    ARROW           reduce using rule 96 (LITERAL -> STRING .)
    WHERE           reduce using rule 96 (LITERAL -> STRING .)
    CLOSE_BRACE     reduce using rule 96 (LITERAL -> STRING .)
    ENDSTATEMENT    reduce using rule 96 (LITERAL -> STRING .)
    THEN            reduce using rule 96 (LITERAL -> STRING .)
    OF              reduce using rule 96 (LITERAL -> STRING .)
    ELSE            reduce using rule 96 (LITERAL -> STRING .)


state 31

    (2) BODY -> OPEN_BRACE IMPORT_DECLARATIONS ENDSTATEMENT . TOP_DECLARATIONS CLOSE_BRACE
    (4) IMPORT_DECLARATIONS -> IMPORT_DECLARATIONS ENDSTATEMENT . IMPORT_DECLARATION
    (7) TOP_DECLARATIONS -> . TOP_DECLARATIONS ENDSTATEMENT TOP_DECLARATION
    (8) TOP_DECLARATIONS -> . TOP_DECLARATION
    (6) IMPORT_DECLARATION -> . IMPORT IDENTIFIER
    (9) TOP_DECLARATION -> . NEWTYPE TYPENAME EQUALS TYPE
    (10) TOP_DECLARATION -> . NEWCONS TYPENAME EQUALS CONSTRUCTORS
    (11) TOP_DECLARATION -> . DECLARATION
    (19) DECLARATION -> . GEN_DECLARATION
    (20) DECLARATION -> . FUNCTION_LHS RHS
    (21) DECLARATION -> . LPAT RHS
    (22) GEN_DECLARATION -> . IDENTIFIER TYPESIG TYPE
    (23) GEN_DECLARATION -> . SETFIX ASSOCIATIVITY INTEGER OP
    (24) GEN_DECLARATION -> .
    (34) FUNCTION_LHS -> . IDENTIFIER APAT APATS
    (35) FUNCTION_LHS -> . LPAT VAROP LPAT
    (36) FUNCTION_LHS -> . OPEN_PAREN FUNCTION_LHS CLOSE_PAREN APAT APATS
    (64) LPAT -> . APAT
    (65) LPAT -> . MINUS OPEN_PAREN INTEGER CLOSE_PAREN
    (66) LPAT -> . MINUS OPEN_PAREN FLOAT CLOSE_PAREN
    (67) LPAT -> . TYPENAME APAT APATS
    (68) APAT -> . PARAM
    (69) APAT -> . TYPENAME
    (70) APAT -> . LITERAL
    (71) APAT -> . OPEN_PAREN LPAT CLOSE_PAREN
    (98) PARAM -> . IDENTIFIER
    (92) LITERAL -> . FLOAT
    (93) LITERAL -> . INTEGER
    (94) LITERAL -> . BOOL
    (95) LITERAL -> . CHAR
    (96) LITERAL -> . STRING

    IMPORT          shift and go to state 11
    NEWTYPE         shift and go to state 13
    NEWCONS         shift and go to state 15
    IDENTIFIER      shift and go to state 12
    SETFIX          shift and go to state 20
    CLOSE_BRACE     reduce using rule 24 (GEN_DECLARATION -> .)
    ENDSTATEMENT    reduce using rule 24 (GEN_DECLARATION -> .)
    OPEN_PAREN      shift and go to state 23
    MINUS           shift and go to state 24
    TYPENAME        shift and go to state 14
    FLOAT           shift and go to state 25
    INTEGER         shift and go to state 21
    BOOL            shift and go to state 28
    CHAR            shift and go to state 29
    STRING          shift and go to state 30

    TOP_DECLARATIONS               shift and go to state 74
    IMPORT_DECLARATION             shift and go to state 75
    TOP_DECLARATION                shift and go to state 10
    DECLARATION                    shift and go to state 16
    GEN_DECLARATION                shift and go to state 17
    FUNCTION_LHS                   shift and go to state 18
    LPAT                           shift and go to state 19
    APAT                           shift and go to state 22
    PARAM                          shift and go to state 26
    LITERAL                        shift and go to state 27

state 32

    (3) BODY -> OPEN_BRACE TOP_DECLARATIONS CLOSE_BRACE .

    $end            reduce using rule 3 (BODY -> OPEN_BRACE TOP_DECLARATIONS CLOSE_BRACE .)


state 33

    (7) TOP_DECLARATIONS -> TOP_DECLARATIONS ENDSTATEMENT . TOP_DECLARATION
    (9) TOP_DECLARATION -> . NEWTYPE TYPENAME EQUALS TYPE
    (10) TOP_DECLARATION -> . NEWCONS TYPENAME EQUALS CONSTRUCTORS
    (11) TOP_DECLARATION -> . DECLARATION
    (19) DECLARATION -> . GEN_DECLARATION
    (20) DECLARATION -> . FUNCTION_LHS RHS
    (21) DECLARATION -> . LPAT RHS
    (22) GEN_DECLARATION -> . IDENTIFIER TYPESIG TYPE
    (23) GEN_DECLARATION -> . SETFIX ASSOCIATIVITY INTEGER OP
    (24) GEN_DECLARATION -> .
    (34) FUNCTION_LHS -> . IDENTIFIER APAT APATS
    (35) FUNCTION_LHS -> . LPAT VAROP LPAT
    (36) FUNCTION_LHS -> . OPEN_PAREN FUNCTION_LHS CLOSE_PAREN APAT APATS
    (64) LPAT -> . APAT
    (65) LPAT -> . MINUS OPEN_PAREN INTEGER CLOSE_PAREN
    (66) LPAT -> . MINUS OPEN_PAREN FLOAT CLOSE_PAREN
    (67) LPAT -> . TYPENAME APAT APATS
    (68) APAT -> . PARAM
    (69) APAT -> . TYPENAME
    (70) APAT -> . LITERAL
    (71) APAT -> . OPEN_PAREN LPAT CLOSE_PAREN
    (98) PARAM -> . IDENTIFIER
    (92) LITERAL -> . FLOAT
    (93) LITERAL -> . INTEGER
    (94) LITERAL -> . BOOL
    (95) LITERAL -> . CHAR
    (96) LITERAL -> . STRING

    NEWTYPE         shift and go to state 13
    NEWCONS         shift and go to state 15
    IDENTIFIER      shift and go to state 12
    SETFIX          shift and go to state 20
    CLOSE_BRACE     reduce using rule 24 (GEN_DECLARATION -> .)
    ENDSTATEMENT    reduce using rule 24 (GEN_DECLARATION -> .)
    OPEN_PAREN      shift and go to state 23
    MINUS           shift and go to state 24
    TYPENAME        shift and go to state 14
    FLOAT           shift and go to state 25
    INTEGER         shift and go to state 21
    BOOL            shift and go to state 28
    CHAR            shift and go to state 29
    STRING          shift and go to state 30

    TOP_DECLARATION                shift and go to state 76
    DECLARATION                    shift and go to state 16
    GEN_DECLARATION                shift and go to state 17
    FUNCTION_LHS                   shift and go to state 18
    LPAT                           shift and go to state 19
    APAT                           shift and go to state 22
    PARAM                          shift and go to state 26
    LITERAL                        shift and go to state 27

state 34

    (6) IMPORT_DECLARATION -> IMPORT IDENTIFIER .

    ENDSTATEMENT    reduce using rule 6 (IMPORT_DECLARATION -> IMPORT IDENTIFIER .)


state 35

    (98) PARAM -> IDENTIFIER .

    TYPENAME        reduce using rule 98 (PARAM -> IDENTIFIER .)
    OPEN_PAREN      reduce using rule 98 (PARAM -> IDENTIFIER .)
    IDENTIFIER      reduce using rule 98 (PARAM -> IDENTIFIER .)
    FLOAT           reduce using rule 98 (PARAM -> IDENTIFIER .)
    INTEGER         reduce using rule 98 (PARAM -> IDENTIFIER .)
    BOOL            reduce using rule 98 (PARAM -> IDENTIFIER .)
    CHAR            reduce using rule 98 (PARAM -> IDENTIFIER .)
    STRING          reduce using rule 98 (PARAM -> IDENTIFIER .)
    EQUALS          reduce using rule 98 (PARAM -> IDENTIFIER .)
    PIPE            reduce using rule 98 (PARAM -> IDENTIFIER .)
    BACKTICK        reduce using rule 98 (PARAM -> IDENTIFIER .)
    PLUS            reduce using rule 98 (PARAM -> IDENTIFIER .)
    MINUS           reduce using rule 98 (PARAM -> IDENTIFIER .)
    TIMES           reduce using rule 98 (PARAM -> IDENTIFIER .)
    DIVIDE          reduce using rule 98 (PARAM -> IDENTIFIER .)
    MODULO          reduce using rule 98 (PARAM -> IDENTIFIER .)
    POW             reduce using rule 98 (PARAM -> IDENTIFIER .)
    EQUALITY        reduce using rule 98 (PARAM -> IDENTIFIER .)
    INEQUALITY      reduce using rule 98 (PARAM -> IDENTIFIER .)
    LESS            reduce using rule 98 (PARAM -> IDENTIFIER .)
    LEQ             reduce using rule 98 (PARAM -> IDENTIFIER .)
    GREATER         reduce using rule 98 (PARAM -> IDENTIFIER .)
    GEQ             reduce using rule 98 (PARAM -> IDENTIFIER .)
    AND             reduce using rule 98 (PARAM -> IDENTIFIER .)
    OR              reduce using rule 98 (PARAM -> IDENTIFIER .)
    LIST_CONSTRUCTOR reduce using rule 98 (PARAM -> IDENTIFIER .)
    CLOSE_PAREN     reduce using rule 98 (PARAM -> IDENTIFIER .)
    ARROW           reduce using rule 98 (PARAM -> IDENTIFIER .)


state 36

    (22) GEN_DECLARATION -> IDENTIFIER TYPESIG . TYPE
    (28) TYPE -> . ATYPE
    (29) TYPE -> . ATYPE ARROW TYPE
    (32) ATYPE -> . TYPENAME
    (33) ATYPE -> . OPEN_PAREN TYPE CLOSE_PAREN

    TYPENAME        shift and go to state 79
    OPEN_PAREN      shift and go to state 80

    TYPE                           shift and go to state 77
    ATYPE                          shift and go to state 78

state 37

    (34) FUNCTION_LHS -> IDENTIFIER APAT . APATS
    (75) APATS -> . APAT APATS
    (76) APATS -> .
    (68) APAT -> . PARAM
    (69) APAT -> . TYPENAME
    (70) APAT -> . LITERAL
    (71) APAT -> . OPEN_PAREN LPAT CLOSE_PAREN
    (98) PARAM -> . IDENTIFIER
    (92) LITERAL -> . FLOAT
    (93) LITERAL -> . INTEGER
    (94) LITERAL -> . BOOL
    (95) LITERAL -> . CHAR
    (96) LITERAL -> . STRING

    EQUALS          reduce using rule 76 (APATS -> .)
    PIPE            reduce using rule 76 (APATS -> .)
    CLOSE_PAREN     reduce using rule 76 (APATS -> .)
    TYPENAME        shift and go to state 38
    OPEN_PAREN      shift and go to state 39
    IDENTIFIER      shift and go to state 35
    FLOAT           shift and go to state 25
    INTEGER         shift and go to state 21
    BOOL            shift and go to state 28
    CHAR            shift and go to state 29
    STRING          shift and go to state 30

    APAT                           shift and go to state 81
    APATS                          shift and go to state 82
    PARAM                          shift and go to state 26
    LITERAL                        shift and go to state 27

state 38

    (69) APAT -> TYPENAME .

    TYPENAME        reduce using rule 69 (APAT -> TYPENAME .)
    OPEN_PAREN      reduce using rule 69 (APAT -> TYPENAME .)
    IDENTIFIER      reduce using rule 69 (APAT -> TYPENAME .)
    FLOAT           reduce using rule 69 (APAT -> TYPENAME .)
    INTEGER         reduce using rule 69 (APAT -> TYPENAME .)
    BOOL            reduce using rule 69 (APAT -> TYPENAME .)
    CHAR            reduce using rule 69 (APAT -> TYPENAME .)
    STRING          reduce using rule 69 (APAT -> TYPENAME .)
    EQUALS          reduce using rule 69 (APAT -> TYPENAME .)
    PIPE            reduce using rule 69 (APAT -> TYPENAME .)
    BACKTICK        reduce using rule 69 (APAT -> TYPENAME .)
    PLUS            reduce using rule 69 (APAT -> TYPENAME .)
    MINUS           reduce using rule 69 (APAT -> TYPENAME .)
    TIMES           reduce using rule 69 (APAT -> TYPENAME .)
    DIVIDE          reduce using rule 69 (APAT -> TYPENAME .)
    MODULO          reduce using rule 69 (APAT -> TYPENAME .)
    POW             reduce using rule 69 (APAT -> TYPENAME .)
    EQUALITY        reduce using rule 69 (APAT -> TYPENAME .)
    INEQUALITY      reduce using rule 69 (APAT -> TYPENAME .)
    LESS            reduce using rule 69 (APAT -> TYPENAME .)
    LEQ             reduce using rule 69 (APAT -> TYPENAME .)
    GREATER         reduce using rule 69 (APAT -> TYPENAME .)
    GEQ             reduce using rule 69 (APAT -> TYPENAME .)
    AND             reduce using rule 69 (APAT -> TYPENAME .)
    OR              reduce using rule 69 (APAT -> TYPENAME .)
    LIST_CONSTRUCTOR reduce using rule 69 (APAT -> TYPENAME .)
    CLOSE_PAREN     reduce using rule 69 (APAT -> TYPENAME .)
    ARROW           reduce using rule 69 (APAT -> TYPENAME .)


state 39

    (71) APAT -> OPEN_PAREN . LPAT CLOSE_PAREN
    (64) LPAT -> . APAT
    (65) LPAT -> . MINUS OPEN_PAREN INTEGER CLOSE_PAREN
    (66) LPAT -> . MINUS OPEN_PAREN FLOAT CLOSE_PAREN
    (67) LPAT -> . TYPENAME APAT APATS
    (68) APAT -> . PARAM
    (69) APAT -> . TYPENAME
    (70) APAT -> . LITERAL
    (71) APAT -> . OPEN_PAREN LPAT CLOSE_PAREN
    (98) PARAM -> . IDENTIFIER
    (92) LITERAL -> . FLOAT
    (93) LITERAL -> . INTEGER
    (94) LITERAL -> . BOOL
    (95) LITERAL -> . CHAR
    (96) LITERAL -> . STRING

    MINUS           shift and go to state 24
    TYPENAME        shift and go to state 14
    OPEN_PAREN      shift and go to state 39
    IDENTIFIER      shift and go to state 35
    FLOAT           shift and go to state 25
    INTEGER         shift and go to state 21
    BOOL            shift and go to state 28
    CHAR            shift and go to state 29
    STRING          shift and go to state 30

    LPAT                           shift and go to state 83
    APAT                           shift and go to state 22
    PARAM                          shift and go to state 26
    LITERAL                        shift and go to state 27

state 40

    (9) TOP_DECLARATION -> NEWTYPE TYPENAME . EQUALS TYPE

    EQUALS          shift and go to state 84


state 41

    (67) LPAT -> TYPENAME APAT . APATS
    (75) APATS -> . APAT APATS
    (76) APATS -> .
    (68) APAT -> . PARAM
    (69) APAT -> . TYPENAME
    (70) APAT -> . LITERAL
    (71) APAT -> . OPEN_PAREN LPAT CLOSE_PAREN
    (98) PARAM -> . IDENTIFIER
    (92) LITERAL -> . FLOAT
    (93) LITERAL -> . INTEGER
    (94) LITERAL -> . BOOL
    (95) LITERAL -> . CHAR
    (96) LITERAL -> . STRING

    EQUALS          reduce using rule 76 (APATS -> .)
    BACKTICK        reduce using rule 76 (APATS -> .)
    PIPE            reduce using rule 76 (APATS -> .)
    PLUS            reduce using rule 76 (APATS -> .)
    MINUS           reduce using rule 76 (APATS -> .)
    TIMES           reduce using rule 76 (APATS -> .)
    DIVIDE          reduce using rule 76 (APATS -> .)
    MODULO          reduce using rule 76 (APATS -> .)
    POW             reduce using rule 76 (APATS -> .)
    EQUALITY        reduce using rule 76 (APATS -> .)
    INEQUALITY      reduce using rule 76 (APATS -> .)
    LESS            reduce using rule 76 (APATS -> .)
    LEQ             reduce using rule 76 (APATS -> .)
    GREATER         reduce using rule 76 (APATS -> .)
    GEQ             reduce using rule 76 (APATS -> .)
    AND             reduce using rule 76 (APATS -> .)
    OR              reduce using rule 76 (APATS -> .)
    LIST_CONSTRUCTOR reduce using rule 76 (APATS -> .)
    CLOSE_PAREN     reduce using rule 76 (APATS -> .)
    ARROW           reduce using rule 76 (APATS -> .)
    TYPENAME        shift and go to state 38
    OPEN_PAREN      shift and go to state 39
    IDENTIFIER      shift and go to state 35
    FLOAT           shift and go to state 25
    INTEGER         shift and go to state 21
    BOOL            shift and go to state 28
    CHAR            shift and go to state 29
    STRING          shift and go to state 30

    APAT                           shift and go to state 81
    APATS                          shift and go to state 85
    PARAM                          shift and go to state 26
    LITERAL                        shift and go to state 27

state 42

    (10) TOP_DECLARATION -> NEWCONS TYPENAME . EQUALS CONSTRUCTORS

    EQUALS          shift and go to state 86


state 43

    (20) DECLARATION -> FUNCTION_LHS RHS .

    CLOSE_BRACE     reduce using rule 20 (DECLARATION -> FUNCTION_LHS RHS .)
    ENDSTATEMENT    reduce using rule 20 (DECLARATION -> FUNCTION_LHS RHS .)


state 44

    (37) RHS -> EQUALS . EXP
    (38) RHS -> EQUALS . EXP WHERE DECLARATIONS
    (43) EXP -> . INFIX_EXP
    (44) INFIX_EXP -> . LEXP OP INFIX_EXP
    (45) INFIX_EXP -> . MINUS INFIX_EXP
    (46) INFIX_EXP -> . LEXP
    (47) LEXP -> . LAMBDA APAT APATS ARROW EXP
    (48) LEXP -> . LET DECLARATIONS IN EXP
    (49) LEXP -> . IF EXP THEN EXP ELSE EXP
    (50) LEXP -> . MATCH EXP OF OPEN_BRACE ALTS CLOSE_BRACE
    (51) LEXP -> . FEXP
    (52) FEXP -> . FEXP AEXP
    (53) FEXP -> . AEXP
    (54) AEXP -> . USED_VAR
    (55) AEXP -> . TYPENAME
    (56) AEXP -> . LITERAL
    (57) AEXP -> . OPEN_PAREN EXP CLOSE_PAREN
    (97) USED_VAR -> . IDENTIFIER
    (92) LITERAL -> . FLOAT
    (93) LITERAL -> . INTEGER
    (94) LITERAL -> . BOOL
    (95) LITERAL -> . CHAR
    (96) LITERAL -> . STRING

    MINUS           shift and go to state 90
    LAMBDA          shift and go to state 91
    LET             shift and go to state 92
    IF              shift and go to state 93
    MATCH           shift and go to state 94
    TYPENAME        shift and go to state 98
    OPEN_PAREN      shift and go to state 100
    IDENTIFIER      shift and go to state 101
    FLOAT           shift and go to state 25
    INTEGER         shift and go to state 21
    BOOL            shift and go to state 28
    CHAR            shift and go to state 29
    STRING          shift and go to state 30

    EXP                            shift and go to state 87
    INFIX_EXP                      shift and go to state 88
    LEXP                           shift and go to state 89
    FEXP                           shift and go to state 95
    AEXP                           shift and go to state 96
    USED_VAR                       shift and go to state 97
    LITERAL                        shift and go to state 99

state 45

    (39) RHS -> GDRHS .
    (40) RHS -> GDRHS . WHERE DECLARATIONS

    CLOSE_BRACE     reduce using rule 39 (RHS -> GDRHS .)
    ENDSTATEMENT    reduce using rule 39 (RHS -> GDRHS .)
    WHERE           shift and go to state 102


state 46

    (41) GDRHS -> PIPE . EXP EQUALS EXP
    (42) GDRHS -> PIPE . EXP EQUALS EXP GDRHS
    (43) EXP -> . INFIX_EXP
    (44) INFIX_EXP -> . LEXP OP INFIX_EXP
    (45) INFIX_EXP -> . MINUS INFIX_EXP
    (46) INFIX_EXP -> . LEXP
    (47) LEXP -> . LAMBDA APAT APATS ARROW EXP
    (48) LEXP -> . LET DECLARATIONS IN EXP
    (49) LEXP -> . IF EXP THEN EXP ELSE EXP
    (50) LEXP -> . MATCH EXP OF OPEN_BRACE ALTS CLOSE_BRACE
    (51) LEXP -> . FEXP
    (52) FEXP -> . FEXP AEXP
    (53) FEXP -> . AEXP
    (54) AEXP -> . USED_VAR
    (55) AEXP -> . TYPENAME
    (56) AEXP -> . LITERAL
    (57) AEXP -> . OPEN_PAREN EXP CLOSE_PAREN
    (97) USED_VAR -> . IDENTIFIER
    (92) LITERAL -> . FLOAT
    (93) LITERAL -> . INTEGER
    (94) LITERAL -> . BOOL
    (95) LITERAL -> . CHAR
    (96) LITERAL -> . STRING

    MINUS           shift and go to state 90
    LAMBDA          shift and go to state 91
    LET             shift and go to state 92
    IF              shift and go to state 93
    MATCH           shift and go to state 94
    TYPENAME        shift and go to state 98
    OPEN_PAREN      shift and go to state 100
    IDENTIFIER      shift and go to state 101
    FLOAT           shift and go to state 25
    INTEGER         shift and go to state 21
    BOOL            shift and go to state 28
    CHAR            shift and go to state 29
    STRING          shift and go to state 30

    EXP                            shift and go to state 103
    INFIX_EXP                      shift and go to state 88
    LEXP                           shift and go to state 89
    FEXP                           shift and go to state 95
    AEXP                           shift and go to state 96
    USED_VAR                       shift and go to state 97
    LITERAL                        shift and go to state 99

state 47

    (21) DECLARATION -> LPAT RHS .

    CLOSE_BRACE     reduce using rule 21 (DECLARATION -> LPAT RHS .)
    ENDSTATEMENT    reduce using rule 21 (DECLARATION -> LPAT RHS .)


state 48

    (35) FUNCTION_LHS -> LPAT VAROP . LPAT
    (64) LPAT -> . APAT
    (65) LPAT -> . MINUS OPEN_PAREN INTEGER CLOSE_PAREN
    (66) LPAT -> . MINUS OPEN_PAREN FLOAT CLOSE_PAREN
    (67) LPAT -> . TYPENAME APAT APATS
    (68) APAT -> . PARAM
    (69) APAT -> . TYPENAME
    (70) APAT -> . LITERAL
    (71) APAT -> . OPEN_PAREN LPAT CLOSE_PAREN
    (98) PARAM -> . IDENTIFIER
    (92) LITERAL -> . FLOAT
    (93) LITERAL -> . INTEGER
    (94) LITERAL -> . BOOL
    (95) LITERAL -> . CHAR
    (96) LITERAL -> . STRING

    MINUS           shift and go to state 24
    TYPENAME        shift and go to state 14
    OPEN_PAREN      shift and go to state 39
    IDENTIFIER      shift and go to state 35
    FLOAT           shift and go to state 25
    INTEGER         shift and go to state 21
    BOOL            shift and go to state 28
    CHAR            shift and go to state 29
    STRING          shift and go to state 30

    LPAT                           shift and go to state 104
    APAT                           shift and go to state 22
    PARAM                          shift and go to state 26
    LITERAL                        shift and go to state 27

state 49

    (72) VAROP -> VARSYM .

    MINUS           reduce using rule 72 (VAROP -> VARSYM .)
    TYPENAME        reduce using rule 72 (VAROP -> VARSYM .)
    OPEN_PAREN      reduce using rule 72 (VAROP -> VARSYM .)
    IDENTIFIER      reduce using rule 72 (VAROP -> VARSYM .)
    FLOAT           reduce using rule 72 (VAROP -> VARSYM .)
    INTEGER         reduce using rule 72 (VAROP -> VARSYM .)
    BOOL            reduce using rule 72 (VAROP -> VARSYM .)
    CHAR            reduce using rule 72 (VAROP -> VARSYM .)
    STRING          reduce using rule 72 (VAROP -> VARSYM .)
    LAMBDA          reduce using rule 72 (VAROP -> VARSYM .)
    LET             reduce using rule 72 (VAROP -> VARSYM .)
    IF              reduce using rule 72 (VAROP -> VARSYM .)
    MATCH           reduce using rule 72 (VAROP -> VARSYM .)
    CLOSE_BRACE     reduce using rule 72 (VAROP -> VARSYM .)
    ENDSTATEMENT    reduce using rule 72 (VAROP -> VARSYM .)


state 50

    (73) VAROP -> BACKTICK . IDENTIFIER BACKTICK

    IDENTIFIER      shift and go to state 105


state 51

    (77) VARSYM -> PLUS .

    MINUS           reduce using rule 77 (VARSYM -> PLUS .)
    TYPENAME        reduce using rule 77 (VARSYM -> PLUS .)
    OPEN_PAREN      reduce using rule 77 (VARSYM -> PLUS .)
    IDENTIFIER      reduce using rule 77 (VARSYM -> PLUS .)
    FLOAT           reduce using rule 77 (VARSYM -> PLUS .)
    INTEGER         reduce using rule 77 (VARSYM -> PLUS .)
    BOOL            reduce using rule 77 (VARSYM -> PLUS .)
    CHAR            reduce using rule 77 (VARSYM -> PLUS .)
    STRING          reduce using rule 77 (VARSYM -> PLUS .)
    LAMBDA          reduce using rule 77 (VARSYM -> PLUS .)
    LET             reduce using rule 77 (VARSYM -> PLUS .)
    IF              reduce using rule 77 (VARSYM -> PLUS .)
    MATCH           reduce using rule 77 (VARSYM -> PLUS .)
    CLOSE_BRACE     reduce using rule 77 (VARSYM -> PLUS .)
    ENDSTATEMENT    reduce using rule 77 (VARSYM -> PLUS .)


state 52

    (78) VARSYM -> MINUS .

    MINUS           reduce using rule 78 (VARSYM -> MINUS .)
    TYPENAME        reduce using rule 78 (VARSYM -> MINUS .)
    OPEN_PAREN      reduce using rule 78 (VARSYM -> MINUS .)
    IDENTIFIER      reduce using rule 78 (VARSYM -> MINUS .)
    FLOAT           reduce using rule 78 (VARSYM -> MINUS .)
    INTEGER         reduce using rule 78 (VARSYM -> MINUS .)
    BOOL            reduce using rule 78 (VARSYM -> MINUS .)
    CHAR            reduce using rule 78 (VARSYM -> MINUS .)
    STRING          reduce using rule 78 (VARSYM -> MINUS .)
    LAMBDA          reduce using rule 78 (VARSYM -> MINUS .)
    LET             reduce using rule 78 (VARSYM -> MINUS .)
    IF              reduce using rule 78 (VARSYM -> MINUS .)
    MATCH           reduce using rule 78 (VARSYM -> MINUS .)
    CLOSE_BRACE     reduce using rule 78 (VARSYM -> MINUS .)
    ENDSTATEMENT    reduce using rule 78 (VARSYM -> MINUS .)


state 53

    (79) VARSYM -> TIMES .

    MINUS           reduce using rule 79 (VARSYM -> TIMES .)
    TYPENAME        reduce using rule 79 (VARSYM -> TIMES .)
    OPEN_PAREN      reduce using rule 79 (VARSYM -> TIMES .)
    IDENTIFIER      reduce using rule 79 (VARSYM -> TIMES .)
    FLOAT           reduce using rule 79 (VARSYM -> TIMES .)
    INTEGER         reduce using rule 79 (VARSYM -> TIMES .)
    BOOL            reduce using rule 79 (VARSYM -> TIMES .)
    CHAR            reduce using rule 79 (VARSYM -> TIMES .)
    STRING          reduce using rule 79 (VARSYM -> TIMES .)
    LAMBDA          reduce using rule 79 (VARSYM -> TIMES .)
    LET             reduce using rule 79 (VARSYM -> TIMES .)
    IF              reduce using rule 79 (VARSYM -> TIMES .)
    MATCH           reduce using rule 79 (VARSYM -> TIMES .)
    CLOSE_BRACE     reduce using rule 79 (VARSYM -> TIMES .)
    ENDSTATEMENT    reduce using rule 79 (VARSYM -> TIMES .)


state 54

    (80) VARSYM -> DIVIDE .

    MINUS           reduce using rule 80 (VARSYM -> DIVIDE .)
    TYPENAME        reduce using rule 80 (VARSYM -> DIVIDE .)
    OPEN_PAREN      reduce using rule 80 (VARSYM -> DIVIDE .)
    IDENTIFIER      reduce using rule 80 (VARSYM -> DIVIDE .)
    FLOAT           reduce using rule 80 (VARSYM -> DIVIDE .)
    INTEGER         reduce using rule 80 (VARSYM -> DIVIDE .)
    BOOL            reduce using rule 80 (VARSYM -> DIVIDE .)
    CHAR            reduce using rule 80 (VARSYM -> DIVIDE .)
    STRING          reduce using rule 80 (VARSYM -> DIVIDE .)
    LAMBDA          reduce using rule 80 (VARSYM -> DIVIDE .)
    LET             reduce using rule 80 (VARSYM -> DIVIDE .)
    IF              reduce using rule 80 (VARSYM -> DIVIDE .)
    MATCH           reduce using rule 80 (VARSYM -> DIVIDE .)
    CLOSE_BRACE     reduce using rule 80 (VARSYM -> DIVIDE .)
    ENDSTATEMENT    reduce using rule 80 (VARSYM -> DIVIDE .)


state 55

    (81) VARSYM -> MODULO .

    MINUS           reduce using rule 81 (VARSYM -> MODULO .)
    TYPENAME        reduce using rule 81 (VARSYM -> MODULO .)
    OPEN_PAREN      reduce using rule 81 (VARSYM -> MODULO .)
    IDENTIFIER      reduce using rule 81 (VARSYM -> MODULO .)
    FLOAT           reduce using rule 81 (VARSYM -> MODULO .)
    INTEGER         reduce using rule 81 (VARSYM -> MODULO .)
    BOOL            reduce using rule 81 (VARSYM -> MODULO .)
    CHAR            reduce using rule 81 (VARSYM -> MODULO .)
    STRING          reduce using rule 81 (VARSYM -> MODULO .)
    LAMBDA          reduce using rule 81 (VARSYM -> MODULO .)
    LET             reduce using rule 81 (VARSYM -> MODULO .)
    IF              reduce using rule 81 (VARSYM -> MODULO .)
    MATCH           reduce using rule 81 (VARSYM -> MODULO .)
    CLOSE_BRACE     reduce using rule 81 (VARSYM -> MODULO .)
    ENDSTATEMENT    reduce using rule 81 (VARSYM -> MODULO .)


state 56

    (82) VARSYM -> POW .

    MINUS           reduce using rule 82 (VARSYM -> POW .)
    TYPENAME        reduce using rule 82 (VARSYM -> POW .)
    OPEN_PAREN      reduce using rule 82 (VARSYM -> POW .)
    IDENTIFIER      reduce using rule 82 (VARSYM -> POW .)
    FLOAT           reduce using rule 82 (VARSYM -> POW .)
    INTEGER         reduce using rule 82 (VARSYM -> POW .)
    BOOL            reduce using rule 82 (VARSYM -> POW .)
    CHAR            reduce using rule 82 (VARSYM -> POW .)
    STRING          reduce using rule 82 (VARSYM -> POW .)
    LAMBDA          reduce using rule 82 (VARSYM -> POW .)
    LET             reduce using rule 82 (VARSYM -> POW .)
    IF              reduce using rule 82 (VARSYM -> POW .)
    MATCH           reduce using rule 82 (VARSYM -> POW .)
    CLOSE_BRACE     reduce using rule 82 (VARSYM -> POW .)
    ENDSTATEMENT    reduce using rule 82 (VARSYM -> POW .)


state 57

    (83) VARSYM -> EQUALITY .

    MINUS           reduce using rule 83 (VARSYM -> EQUALITY .)
    TYPENAME        reduce using rule 83 (VARSYM -> EQUALITY .)
    OPEN_PAREN      reduce using rule 83 (VARSYM -> EQUALITY .)
    IDENTIFIER      reduce using rule 83 (VARSYM -> EQUALITY .)
    FLOAT           reduce using rule 83 (VARSYM -> EQUALITY .)
    INTEGER         reduce using rule 83 (VARSYM -> EQUALITY .)
    BOOL            reduce using rule 83 (VARSYM -> EQUALITY .)
    CHAR            reduce using rule 83 (VARSYM -> EQUALITY .)
    STRING          reduce using rule 83 (VARSYM -> EQUALITY .)
    LAMBDA          reduce using rule 83 (VARSYM -> EQUALITY .)
    LET             reduce using rule 83 (VARSYM -> EQUALITY .)
    IF              reduce using rule 83 (VARSYM -> EQUALITY .)
    MATCH           reduce using rule 83 (VARSYM -> EQUALITY .)
    CLOSE_BRACE     reduce using rule 83 (VARSYM -> EQUALITY .)
    ENDSTATEMENT    reduce using rule 83 (VARSYM -> EQUALITY .)


state 58

    (84) VARSYM -> INEQUALITY .

    MINUS           reduce using rule 84 (VARSYM -> INEQUALITY .)
    TYPENAME        reduce using rule 84 (VARSYM -> INEQUALITY .)
    OPEN_PAREN      reduce using rule 84 (VARSYM -> INEQUALITY .)
    IDENTIFIER      reduce using rule 84 (VARSYM -> INEQUALITY .)
    FLOAT           reduce using rule 84 (VARSYM -> INEQUALITY .)
    INTEGER         reduce using rule 84 (VARSYM -> INEQUALITY .)
    BOOL            reduce using rule 84 (VARSYM -> INEQUALITY .)
    CHAR            reduce using rule 84 (VARSYM -> INEQUALITY .)
    STRING          reduce using rule 84 (VARSYM -> INEQUALITY .)
    LAMBDA          reduce using rule 84 (VARSYM -> INEQUALITY .)
    LET             reduce using rule 84 (VARSYM -> INEQUALITY .)
    IF              reduce using rule 84 (VARSYM -> INEQUALITY .)
    MATCH           reduce using rule 84 (VARSYM -> INEQUALITY .)
    CLOSE_BRACE     reduce using rule 84 (VARSYM -> INEQUALITY .)
    ENDSTATEMENT    reduce using rule 84 (VARSYM -> INEQUALITY .)


state 59

    (85) VARSYM -> LESS .

    MINUS           reduce using rule 85 (VARSYM -> LESS .)
    TYPENAME        reduce using rule 85 (VARSYM -> LESS .)
    OPEN_PAREN      reduce using rule 85 (VARSYM -> LESS .)
    IDENTIFIER      reduce using rule 85 (VARSYM -> LESS .)
    FLOAT           reduce using rule 85 (VARSYM -> LESS .)
    INTEGER         reduce using rule 85 (VARSYM -> LESS .)
    BOOL            reduce using rule 85 (VARSYM -> LESS .)
    CHAR            reduce using rule 85 (VARSYM -> LESS .)
    STRING          reduce using rule 85 (VARSYM -> LESS .)
    LAMBDA          reduce using rule 85 (VARSYM -> LESS .)
    LET             reduce using rule 85 (VARSYM -> LESS .)
    IF              reduce using rule 85 (VARSYM -> LESS .)
    MATCH           reduce using rule 85 (VARSYM -> LESS .)
    CLOSE_BRACE     reduce using rule 85 (VARSYM -> LESS .)
    ENDSTATEMENT    reduce using rule 85 (VARSYM -> LESS .)


state 60

    (86) VARSYM -> LEQ .

    MINUS           reduce using rule 86 (VARSYM -> LEQ .)
    TYPENAME        reduce using rule 86 (VARSYM -> LEQ .)
    OPEN_PAREN      reduce using rule 86 (VARSYM -> LEQ .)
    IDENTIFIER      reduce using rule 86 (VARSYM -> LEQ .)
    FLOAT           reduce using rule 86 (VARSYM -> LEQ .)
    INTEGER         reduce using rule 86 (VARSYM -> LEQ .)
    BOOL            reduce using rule 86 (VARSYM -> LEQ .)
    CHAR            reduce using rule 86 (VARSYM -> LEQ .)
    STRING          reduce using rule 86 (VARSYM -> LEQ .)
    LAMBDA          reduce using rule 86 (VARSYM -> LEQ .)
    LET             reduce using rule 86 (VARSYM -> LEQ .)
    IF              reduce using rule 86 (VARSYM -> LEQ .)
    MATCH           reduce using rule 86 (VARSYM -> LEQ .)
    CLOSE_BRACE     reduce using rule 86 (VARSYM -> LEQ .)
    ENDSTATEMENT    reduce using rule 86 (VARSYM -> LEQ .)


state 61

    (87) VARSYM -> GREATER .

    MINUS           reduce using rule 87 (VARSYM -> GREATER .)
    TYPENAME        reduce using rule 87 (VARSYM -> GREATER .)
    OPEN_PAREN      reduce using rule 87 (VARSYM -> GREATER .)
    IDENTIFIER      reduce using rule 87 (VARSYM -> GREATER .)
    FLOAT           reduce using rule 87 (VARSYM -> GREATER .)
    INTEGER         reduce using rule 87 (VARSYM -> GREATER .)
    BOOL            reduce using rule 87 (VARSYM -> GREATER .)
    CHAR            reduce using rule 87 (VARSYM -> GREATER .)
    STRING          reduce using rule 87 (VARSYM -> GREATER .)
    LAMBDA          reduce using rule 87 (VARSYM -> GREATER .)
    LET             reduce using rule 87 (VARSYM -> GREATER .)
    IF              reduce using rule 87 (VARSYM -> GREATER .)
    MATCH           reduce using rule 87 (VARSYM -> GREATER .)
    CLOSE_BRACE     reduce using rule 87 (VARSYM -> GREATER .)
    ENDSTATEMENT    reduce using rule 87 (VARSYM -> GREATER .)


state 62

    (88) VARSYM -> GEQ .

    MINUS           reduce using rule 88 (VARSYM -> GEQ .)
    TYPENAME        reduce using rule 88 (VARSYM -> GEQ .)
    OPEN_PAREN      reduce using rule 88 (VARSYM -> GEQ .)
    IDENTIFIER      reduce using rule 88 (VARSYM -> GEQ .)
    FLOAT           reduce using rule 88 (VARSYM -> GEQ .)
    INTEGER         reduce using rule 88 (VARSYM -> GEQ .)
    BOOL            reduce using rule 88 (VARSYM -> GEQ .)
    CHAR            reduce using rule 88 (VARSYM -> GEQ .)
    STRING          reduce using rule 88 (VARSYM -> GEQ .)
    LAMBDA          reduce using rule 88 (VARSYM -> GEQ .)
    LET             reduce using rule 88 (VARSYM -> GEQ .)
    IF              reduce using rule 88 (VARSYM -> GEQ .)
    MATCH           reduce using rule 88 (VARSYM -> GEQ .)
    CLOSE_BRACE     reduce using rule 88 (VARSYM -> GEQ .)
    ENDSTATEMENT    reduce using rule 88 (VARSYM -> GEQ .)


state 63

    (89) VARSYM -> AND .

    MINUS           reduce using rule 89 (VARSYM -> AND .)
    TYPENAME        reduce using rule 89 (VARSYM -> AND .)
    OPEN_PAREN      reduce using rule 89 (VARSYM -> AND .)
    IDENTIFIER      reduce using rule 89 (VARSYM -> AND .)
    FLOAT           reduce using rule 89 (VARSYM -> AND .)
    INTEGER         reduce using rule 89 (VARSYM -> AND .)
    BOOL            reduce using rule 89 (VARSYM -> AND .)
    CHAR            reduce using rule 89 (VARSYM -> AND .)
    STRING          reduce using rule 89 (VARSYM -> AND .)
    LAMBDA          reduce using rule 89 (VARSYM -> AND .)
    LET             reduce using rule 89 (VARSYM -> AND .)
    IF              reduce using rule 89 (VARSYM -> AND .)
    MATCH           reduce using rule 89 (VARSYM -> AND .)
    CLOSE_BRACE     reduce using rule 89 (VARSYM -> AND .)
    ENDSTATEMENT    reduce using rule 89 (VARSYM -> AND .)


state 64

    (90) VARSYM -> OR .

    MINUS           reduce using rule 90 (VARSYM -> OR .)
    TYPENAME        reduce using rule 90 (VARSYM -> OR .)
    OPEN_PAREN      reduce using rule 90 (VARSYM -> OR .)
    IDENTIFIER      reduce using rule 90 (VARSYM -> OR .)
    FLOAT           reduce using rule 90 (VARSYM -> OR .)
    INTEGER         reduce using rule 90 (VARSYM -> OR .)
    BOOL            reduce using rule 90 (VARSYM -> OR .)
    CHAR            reduce using rule 90 (VARSYM -> OR .)
    STRING          reduce using rule 90 (VARSYM -> OR .)
    LAMBDA          reduce using rule 90 (VARSYM -> OR .)
    LET             reduce using rule 90 (VARSYM -> OR .)
    IF              reduce using rule 90 (VARSYM -> OR .)
    MATCH           reduce using rule 90 (VARSYM -> OR .)
    CLOSE_BRACE     reduce using rule 90 (VARSYM -> OR .)
    ENDSTATEMENT    reduce using rule 90 (VARSYM -> OR .)


state 65

    (91) VARSYM -> LIST_CONSTRUCTOR .

    MINUS           reduce using rule 91 (VARSYM -> LIST_CONSTRUCTOR .)
    TYPENAME        reduce using rule 91 (VARSYM -> LIST_CONSTRUCTOR .)
    OPEN_PAREN      reduce using rule 91 (VARSYM -> LIST_CONSTRUCTOR .)
    IDENTIFIER      reduce using rule 91 (VARSYM -> LIST_CONSTRUCTOR .)
    FLOAT           reduce using rule 91 (VARSYM -> LIST_CONSTRUCTOR .)
    INTEGER         reduce using rule 91 (VARSYM -> LIST_CONSTRUCTOR .)
    BOOL            reduce using rule 91 (VARSYM -> LIST_CONSTRUCTOR .)
    CHAR            reduce using rule 91 (VARSYM -> LIST_CONSTRUCTOR .)
    STRING          reduce using rule 91 (VARSYM -> LIST_CONSTRUCTOR .)
    LAMBDA          reduce using rule 91 (VARSYM -> LIST_CONSTRUCTOR .)
    LET             reduce using rule 91 (VARSYM -> LIST_CONSTRUCTOR .)
    IF              reduce using rule 91 (VARSYM -> LIST_CONSTRUCTOR .)
    MATCH           reduce using rule 91 (VARSYM -> LIST_CONSTRUCTOR .)
    CLOSE_BRACE     reduce using rule 91 (VARSYM -> LIST_CONSTRUCTOR .)
    ENDSTATEMENT    reduce using rule 91 (VARSYM -> LIST_CONSTRUCTOR .)


state 66

    (23) GEN_DECLARATION -> SETFIX ASSOCIATIVITY . INTEGER OP

    INTEGER         shift and go to state 106


state 67

    (25) ASSOCIATIVITY -> LEFTASSOC .

    INTEGER         reduce using rule 25 (ASSOCIATIVITY -> LEFTASSOC .)


state 68

    (26) ASSOCIATIVITY -> RIGHTASSOC .

    INTEGER         reduce using rule 26 (ASSOCIATIVITY -> RIGHTASSOC .)


state 69

    (27) ASSOCIATIVITY -> NONASSOC .

    INTEGER         reduce using rule 27 (ASSOCIATIVITY -> NONASSOC .)


state 70

    (36) FUNCTION_LHS -> OPEN_PAREN FUNCTION_LHS . CLOSE_PAREN APAT APATS

    CLOSE_PAREN     shift and go to state 107


state 71

    (71) APAT -> OPEN_PAREN LPAT . CLOSE_PAREN
    (35) FUNCTION_LHS -> LPAT . VAROP LPAT
    (72) VAROP -> . VARSYM
    (73) VAROP -> . BACKTICK IDENTIFIER BACKTICK
    (77) VARSYM -> . PLUS
    (78) VARSYM -> . MINUS
    (79) VARSYM -> . TIMES
    (80) VARSYM -> . DIVIDE
    (81) VARSYM -> . MODULO
    (82) VARSYM -> . POW
    (83) VARSYM -> . EQUALITY
    (84) VARSYM -> . INEQUALITY
    (85) VARSYM -> . LESS
    (86) VARSYM -> . LEQ
    (87) VARSYM -> . GREATER
    (88) VARSYM -> . GEQ
    (89) VARSYM -> . AND
    (90) VARSYM -> . OR
    (91) VARSYM -> . LIST_CONSTRUCTOR

    CLOSE_PAREN     shift and go to state 108
    BACKTICK        shift and go to state 50
    PLUS            shift and go to state 51
    MINUS           shift and go to state 52
    TIMES           shift and go to state 53
    DIVIDE          shift and go to state 54
    MODULO          shift and go to state 55
    POW             shift and go to state 56
    EQUALITY        shift and go to state 57
    INEQUALITY      shift and go to state 58
    LESS            shift and go to state 59
    LEQ             shift and go to state 60
    GREATER         shift and go to state 61
    GEQ             shift and go to state 62
    AND             shift and go to state 63
    OR              shift and go to state 64
    LIST_CONSTRUCTOR shift and go to state 65

    VAROP                          shift and go to state 48
    VARSYM                         shift and go to state 49

state 72

    (34) FUNCTION_LHS -> IDENTIFIER . APAT APATS
    (98) PARAM -> IDENTIFIER .
    (68) APAT -> . PARAM
    (69) APAT -> . TYPENAME
    (70) APAT -> . LITERAL
    (71) APAT -> . OPEN_PAREN LPAT CLOSE_PAREN
    (98) PARAM -> . IDENTIFIER
    (92) LITERAL -> . FLOAT
    (93) LITERAL -> . INTEGER
    (94) LITERAL -> . BOOL
    (95) LITERAL -> . CHAR
    (96) LITERAL -> . STRING

    CLOSE_PAREN     reduce using rule 98 (PARAM -> IDENTIFIER .)
    BACKTICK        reduce using rule 98 (PARAM -> IDENTIFIER .)
    PLUS            reduce using rule 98 (PARAM -> IDENTIFIER .)
    MINUS           reduce using rule 98 (PARAM -> IDENTIFIER .)
    TIMES           reduce using rule 98 (PARAM -> IDENTIFIER .)
    DIVIDE          reduce using rule 98 (PARAM -> IDENTIFIER .)
    MODULO          reduce using rule 98 (PARAM -> IDENTIFIER .)
    POW             reduce using rule 98 (PARAM -> IDENTIFIER .)
    EQUALITY        reduce using rule 98 (PARAM -> IDENTIFIER .)
    INEQUALITY      reduce using rule 98 (PARAM -> IDENTIFIER .)
    LESS            reduce using rule 98 (PARAM -> IDENTIFIER .)
    LEQ             reduce using rule 98 (PARAM -> IDENTIFIER .)
    GREATER         reduce using rule 98 (PARAM -> IDENTIFIER .)
    GEQ             reduce using rule 98 (PARAM -> IDENTIFIER .)
    AND             reduce using rule 98 (PARAM -> IDENTIFIER .)
    OR              reduce using rule 98 (PARAM -> IDENTIFIER .)
    LIST_CONSTRUCTOR reduce using rule 98 (PARAM -> IDENTIFIER .)
    TYPENAME        shift and go to state 38
    OPEN_PAREN      shift and go to state 39
    IDENTIFIER      shift and go to state 35
    FLOAT           shift and go to state 25
    INTEGER         shift and go to state 21
    BOOL            shift and go to state 28
    CHAR            shift and go to state 29
    STRING          shift and go to state 30

    APAT                           shift and go to state 37
    PARAM                          shift and go to state 26
    LITERAL                        shift and go to state 27

state 73

    (65) LPAT -> MINUS OPEN_PAREN . INTEGER CLOSE_PAREN
    (66) LPAT -> MINUS OPEN_PAREN . FLOAT CLOSE_PAREN

    INTEGER         shift and go to state 109
    FLOAT           shift and go to state 110


state 74

    (2) BODY -> OPEN_BRACE IMPORT_DECLARATIONS ENDSTATEMENT TOP_DECLARATIONS . CLOSE_BRACE
    (7) TOP_DECLARATIONS -> TOP_DECLARATIONS . ENDSTATEMENT TOP_DECLARATION

    CLOSE_BRACE     shift and go to state 111
    ENDSTATEMENT    shift and go to state 33


state 75

    (4) IMPORT_DECLARATIONS -> IMPORT_DECLARATIONS ENDSTATEMENT IMPORT_DECLARATION .

    ENDSTATEMENT    reduce using rule 4 (IMPORT_DECLARATIONS -> IMPORT_DECLARATIONS ENDSTATEMENT IMPORT_DECLARATION .)


state 76

    (7) TOP_DECLARATIONS -> TOP_DECLARATIONS ENDSTATEMENT TOP_DECLARATION .

    CLOSE_BRACE     reduce using rule 7 (TOP_DECLARATIONS -> TOP_DECLARATIONS ENDSTATEMENT TOP_DECLARATION .)
    ENDSTATEMENT    reduce using rule 7 (TOP_DECLARATIONS -> TOP_DECLARATIONS ENDSTATEMENT TOP_DECLARATION .)


state 77

    (22) GEN_DECLARATION -> IDENTIFIER TYPESIG TYPE .

    CLOSE_BRACE     reduce using rule 22 (GEN_DECLARATION -> IDENTIFIER TYPESIG TYPE .)
    ENDSTATEMENT    reduce using rule 22 (GEN_DECLARATION -> IDENTIFIER TYPESIG TYPE .)


state 78

    (28) TYPE -> ATYPE .
    (29) TYPE -> ATYPE . ARROW TYPE

    CLOSE_BRACE     reduce using rule 28 (TYPE -> ATYPE .)
    ENDSTATEMENT    reduce using rule 28 (TYPE -> ATYPE .)
    CLOSE_PAREN     reduce using rule 28 (TYPE -> ATYPE .)
    ARROW           shift and go to state 112


state 79

    (32) ATYPE -> TYPENAME .

    ARROW           reduce using rule 32 (ATYPE -> TYPENAME .)
    CLOSE_BRACE     reduce using rule 32 (ATYPE -> TYPENAME .)
    ENDSTATEMENT    reduce using rule 32 (ATYPE -> TYPENAME .)
    CLOSE_PAREN     reduce using rule 32 (ATYPE -> TYPENAME .)
    TYPENAME        reduce using rule 32 (ATYPE -> TYPENAME .)
    OPEN_PAREN      reduce using rule 32 (ATYPE -> TYPENAME .)
    PIPE            reduce using rule 32 (ATYPE -> TYPENAME .)


state 80

    (33) ATYPE -> OPEN_PAREN . TYPE CLOSE_PAREN
    (28) TYPE -> . ATYPE
    (29) TYPE -> . ATYPE ARROW TYPE
    (32) ATYPE -> . TYPENAME
    (33) ATYPE -> . OPEN_PAREN TYPE CLOSE_PAREN

    TYPENAME        shift and go to state 79
    OPEN_PAREN      shift and go to state 80

    TYPE                           shift and go to state 113
    ATYPE                          shift and go to state 78

state 81

    (75) APATS -> APAT . APATS
    (75) APATS -> . APAT APATS
    (76) APATS -> .
    (68) APAT -> . PARAM
    (69) APAT -> . TYPENAME
    (70) APAT -> . LITERAL
    (71) APAT -> . OPEN_PAREN LPAT CLOSE_PAREN
    (98) PARAM -> . IDENTIFIER
    (92) LITERAL -> . FLOAT
    (93) LITERAL -> . INTEGER
    (94) LITERAL -> . BOOL
    (95) LITERAL -> . CHAR
    (96) LITERAL -> . STRING

    EQUALS          reduce using rule 76 (APATS -> .)
    PIPE            reduce using rule 76 (APATS -> .)
    CLOSE_PAREN     reduce using rule 76 (APATS -> .)
    BACKTICK        reduce using rule 76 (APATS -> .)
    PLUS            reduce using rule 76 (APATS -> .)
    MINUS           reduce using rule 76 (APATS -> .)
    TIMES           reduce using rule 76 (APATS -> .)
    DIVIDE          reduce using rule 76 (APATS -> .)
    MODULO          reduce using rule 76 (APATS -> .)
    POW             reduce using rule 76 (APATS -> .)
    EQUALITY        reduce using rule 76 (APATS -> .)
    INEQUALITY      reduce using rule 76 (APATS -> .)
    LESS            reduce using rule 76 (APATS -> .)
    LEQ             reduce using rule 76 (APATS -> .)
    GREATER         reduce using rule 76 (APATS -> .)
    GEQ             reduce using rule 76 (APATS -> .)
    AND             reduce using rule 76 (APATS -> .)
    OR              reduce using rule 76 (APATS -> .)
    LIST_CONSTRUCTOR reduce using rule 76 (APATS -> .)
    ARROW           reduce using rule 76 (APATS -> .)
    TYPENAME        shift and go to state 38
    OPEN_PAREN      shift and go to state 39
    IDENTIFIER      shift and go to state 35
    FLOAT           shift and go to state 25
    INTEGER         shift and go to state 21
    BOOL            shift and go to state 28
    CHAR            shift and go to state 29
    STRING          shift and go to state 30

    APAT                           shift and go to state 81
    APATS                          shift and go to state 114
    PARAM                          shift and go to state 26
    LITERAL                        shift and go to state 27

state 82

    (34) FUNCTION_LHS -> IDENTIFIER APAT APATS .

    EQUALS          reduce using rule 34 (FUNCTION_LHS -> IDENTIFIER APAT APATS .)
    PIPE            reduce using rule 34 (FUNCTION_LHS -> IDENTIFIER APAT APATS .)
    CLOSE_PAREN     reduce using rule 34 (FUNCTION_LHS -> IDENTIFIER APAT APATS .)


state 83

    (71) APAT -> OPEN_PAREN LPAT . CLOSE_PAREN

    CLOSE_PAREN     shift and go to state 108


state 84

    (9) TOP_DECLARATION -> NEWTYPE TYPENAME EQUALS . TYPE
    (28) TYPE -> . ATYPE
    (29) TYPE -> . ATYPE ARROW TYPE
    (32) ATYPE -> . TYPENAME
    (33) ATYPE -> . OPEN_PAREN TYPE CLOSE_PAREN

    TYPENAME        shift and go to state 79
    OPEN_PAREN      shift and go to state 80

    TYPE                           shift and go to state 115
    ATYPE                          shift and go to state 78

state 85

    (67) LPAT -> TYPENAME APAT APATS .

    EQUALS          reduce using rule 67 (LPAT -> TYPENAME APAT APATS .)
    BACKTICK        reduce using rule 67 (LPAT -> TYPENAME APAT APATS .)
    PIPE            reduce using rule 67 (LPAT -> TYPENAME APAT APATS .)
    PLUS            reduce using rule 67 (LPAT -> TYPENAME APAT APATS .)
    MINUS           reduce using rule 67 (LPAT -> TYPENAME APAT APATS .)
    TIMES           reduce using rule 67 (LPAT -> TYPENAME APAT APATS .)
    DIVIDE          reduce using rule 67 (LPAT -> TYPENAME APAT APATS .)
    MODULO          reduce using rule 67 (LPAT -> TYPENAME APAT APATS .)
    POW             reduce using rule 67 (LPAT -> TYPENAME APAT APATS .)
    EQUALITY        reduce using rule 67 (LPAT -> TYPENAME APAT APATS .)
    INEQUALITY      reduce using rule 67 (LPAT -> TYPENAME APAT APATS .)
    LESS            reduce using rule 67 (LPAT -> TYPENAME APAT APATS .)
    LEQ             reduce using rule 67 (LPAT -> TYPENAME APAT APATS .)
    GREATER         reduce using rule 67 (LPAT -> TYPENAME APAT APATS .)
    GEQ             reduce using rule 67 (LPAT -> TYPENAME APAT APATS .)
    AND             reduce using rule 67 (LPAT -> TYPENAME APAT APATS .)
    OR              reduce using rule 67 (LPAT -> TYPENAME APAT APATS .)
    LIST_CONSTRUCTOR reduce using rule 67 (LPAT -> TYPENAME APAT APATS .)
    CLOSE_PAREN     reduce using rule 67 (LPAT -> TYPENAME APAT APATS .)
    ARROW           reduce using rule 67 (LPAT -> TYPENAME APAT APATS .)


state 86

    (10) TOP_DECLARATION -> NEWCONS TYPENAME EQUALS . CONSTRUCTORS
    (12) CONSTRUCTORS -> . CONSTRUCTORS PIPE CONSTRUCTOR
    (13) CONSTRUCTORS -> . CONSTRUCTOR
    (14) CONSTRUCTOR -> . TYPENAME ATYPES

    TYPENAME        shift and go to state 116

    CONSTRUCTORS                   shift and go to state 117
    CONSTRUCTOR                    shift and go to state 118

state 87

    (37) RHS -> EQUALS EXP .
    (38) RHS -> EQUALS EXP . WHERE DECLARATIONS

    CLOSE_BRACE     reduce using rule 37 (RHS -> EQUALS EXP .)
    ENDSTATEMENT    reduce using rule 37 (RHS -> EQUALS EXP .)
    WHERE           shift and go to state 119


state 88

    (43) EXP -> INFIX_EXP .

    WHERE           reduce using rule 43 (EXP -> INFIX_EXP .)
    CLOSE_BRACE     reduce using rule 43 (EXP -> INFIX_EXP .)
    ENDSTATEMENT    reduce using rule 43 (EXP -> INFIX_EXP .)
    EQUALS          reduce using rule 43 (EXP -> INFIX_EXP .)
    THEN            reduce using rule 43 (EXP -> INFIX_EXP .)
    OF              reduce using rule 43 (EXP -> INFIX_EXP .)
    CLOSE_PAREN     reduce using rule 43 (EXP -> INFIX_EXP .)
    PIPE            reduce using rule 43 (EXP -> INFIX_EXP .)
    BACKTICK        reduce using rule 43 (EXP -> INFIX_EXP .)
    PLUS            reduce using rule 43 (EXP -> INFIX_EXP .)
    MINUS           reduce using rule 43 (EXP -> INFIX_EXP .)
    TIMES           reduce using rule 43 (EXP -> INFIX_EXP .)
    DIVIDE          reduce using rule 43 (EXP -> INFIX_EXP .)
    MODULO          reduce using rule 43 (EXP -> INFIX_EXP .)
    POW             reduce using rule 43 (EXP -> INFIX_EXP .)
    EQUALITY        reduce using rule 43 (EXP -> INFIX_EXP .)
    INEQUALITY      reduce using rule 43 (EXP -> INFIX_EXP .)
    LESS            reduce using rule 43 (EXP -> INFIX_EXP .)
    LEQ             reduce using rule 43 (EXP -> INFIX_EXP .)
    GREATER         reduce using rule 43 (EXP -> INFIX_EXP .)
    GEQ             reduce using rule 43 (EXP -> INFIX_EXP .)
    AND             reduce using rule 43 (EXP -> INFIX_EXP .)
    OR              reduce using rule 43 (EXP -> INFIX_EXP .)
    LIST_CONSTRUCTOR reduce using rule 43 (EXP -> INFIX_EXP .)
    ELSE            reduce using rule 43 (EXP -> INFIX_EXP .)


state 89

    (44) INFIX_EXP -> LEXP . OP INFIX_EXP
    (46) INFIX_EXP -> LEXP .
    (74) OP -> . VAROP
    (72) VAROP -> . VARSYM
    (73) VAROP -> . BACKTICK IDENTIFIER BACKTICK
    (77) VARSYM -> . PLUS
    (78) VARSYM -> . MINUS
    (79) VARSYM -> . TIMES
    (80) VARSYM -> . DIVIDE
    (81) VARSYM -> . MODULO
    (82) VARSYM -> . POW
    (83) VARSYM -> . EQUALITY
    (84) VARSYM -> . INEQUALITY
    (85) VARSYM -> . LESS
    (86) VARSYM -> . LEQ
    (87) VARSYM -> . GREATER
    (88) VARSYM -> . GEQ
    (89) VARSYM -> . AND
    (90) VARSYM -> . OR
    (91) VARSYM -> . LIST_CONSTRUCTOR

  ! shift/reduce conflict for BACKTICK resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MODULO resolved as shift
  ! shift/reduce conflict for POW resolved as shift
  ! shift/reduce conflict for EQUALITY resolved as shift
  ! shift/reduce conflict for INEQUALITY resolved as shift
  ! shift/reduce conflict for LESS resolved as shift
  ! shift/reduce conflict for LEQ resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for GEQ resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for LIST_CONSTRUCTOR resolved as shift
    WHERE           reduce using rule 46 (INFIX_EXP -> LEXP .)
    CLOSE_BRACE     reduce using rule 46 (INFIX_EXP -> LEXP .)
    ENDSTATEMENT    reduce using rule 46 (INFIX_EXP -> LEXP .)
    EQUALS          reduce using rule 46 (INFIX_EXP -> LEXP .)
    THEN            reduce using rule 46 (INFIX_EXP -> LEXP .)
    OF              reduce using rule 46 (INFIX_EXP -> LEXP .)
    CLOSE_PAREN     reduce using rule 46 (INFIX_EXP -> LEXP .)
    PIPE            reduce using rule 46 (INFIX_EXP -> LEXP .)
    ELSE            reduce using rule 46 (INFIX_EXP -> LEXP .)
    BACKTICK        shift and go to state 50
    PLUS            shift and go to state 51
    MINUS           shift and go to state 52
    TIMES           shift and go to state 53
    DIVIDE          shift and go to state 54
    MODULO          shift and go to state 55
    POW             shift and go to state 56
    EQUALITY        shift and go to state 57
    INEQUALITY      shift and go to state 58
    LESS            shift and go to state 59
    LEQ             shift and go to state 60
    GREATER         shift and go to state 61
    GEQ             shift and go to state 62
    AND             shift and go to state 63
    OR              shift and go to state 64
    LIST_CONSTRUCTOR shift and go to state 65

  ! BACKTICK        [ reduce using rule 46 (INFIX_EXP -> LEXP .) ]
  ! PLUS            [ reduce using rule 46 (INFIX_EXP -> LEXP .) ]
  ! MINUS           [ reduce using rule 46 (INFIX_EXP -> LEXP .) ]
  ! TIMES           [ reduce using rule 46 (INFIX_EXP -> LEXP .) ]
  ! DIVIDE          [ reduce using rule 46 (INFIX_EXP -> LEXP .) ]
  ! MODULO          [ reduce using rule 46 (INFIX_EXP -> LEXP .) ]
  ! POW             [ reduce using rule 46 (INFIX_EXP -> LEXP .) ]
  ! EQUALITY        [ reduce using rule 46 (INFIX_EXP -> LEXP .) ]
  ! INEQUALITY      [ reduce using rule 46 (INFIX_EXP -> LEXP .) ]
  ! LESS            [ reduce using rule 46 (INFIX_EXP -> LEXP .) ]
  ! LEQ             [ reduce using rule 46 (INFIX_EXP -> LEXP .) ]
  ! GREATER         [ reduce using rule 46 (INFIX_EXP -> LEXP .) ]
  ! GEQ             [ reduce using rule 46 (INFIX_EXP -> LEXP .) ]
  ! AND             [ reduce using rule 46 (INFIX_EXP -> LEXP .) ]
  ! OR              [ reduce using rule 46 (INFIX_EXP -> LEXP .) ]
  ! LIST_CONSTRUCTOR [ reduce using rule 46 (INFIX_EXP -> LEXP .) ]

    OP                             shift and go to state 120
    VAROP                          shift and go to state 121
    VARSYM                         shift and go to state 49

state 90

    (45) INFIX_EXP -> MINUS . INFIX_EXP
    (44) INFIX_EXP -> . LEXP OP INFIX_EXP
    (45) INFIX_EXP -> . MINUS INFIX_EXP
    (46) INFIX_EXP -> . LEXP
    (47) LEXP -> . LAMBDA APAT APATS ARROW EXP
    (48) LEXP -> . LET DECLARATIONS IN EXP
    (49) LEXP -> . IF EXP THEN EXP ELSE EXP
    (50) LEXP -> . MATCH EXP OF OPEN_BRACE ALTS CLOSE_BRACE
    (51) LEXP -> . FEXP
    (52) FEXP -> . FEXP AEXP
    (53) FEXP -> . AEXP
    (54) AEXP -> . USED_VAR
    (55) AEXP -> . TYPENAME
    (56) AEXP -> . LITERAL
    (57) AEXP -> . OPEN_PAREN EXP CLOSE_PAREN
    (97) USED_VAR -> . IDENTIFIER
    (92) LITERAL -> . FLOAT
    (93) LITERAL -> . INTEGER
    (94) LITERAL -> . BOOL
    (95) LITERAL -> . CHAR
    (96) LITERAL -> . STRING

    MINUS           shift and go to state 90
    LAMBDA          shift and go to state 91
    LET             shift and go to state 92
    IF              shift and go to state 93
    MATCH           shift and go to state 94
    TYPENAME        shift and go to state 98
    OPEN_PAREN      shift and go to state 100
    IDENTIFIER      shift and go to state 101
    FLOAT           shift and go to state 25
    INTEGER         shift and go to state 21
    BOOL            shift and go to state 28
    CHAR            shift and go to state 29
    STRING          shift and go to state 30

    INFIX_EXP                      shift and go to state 122
    LEXP                           shift and go to state 89
    FEXP                           shift and go to state 95
    AEXP                           shift and go to state 96
    USED_VAR                       shift and go to state 97
    LITERAL                        shift and go to state 99

state 91

    (47) LEXP -> LAMBDA . APAT APATS ARROW EXP
    (68) APAT -> . PARAM
    (69) APAT -> . TYPENAME
    (70) APAT -> . LITERAL
    (71) APAT -> . OPEN_PAREN LPAT CLOSE_PAREN
    (98) PARAM -> . IDENTIFIER
    (92) LITERAL -> . FLOAT
    (93) LITERAL -> . INTEGER
    (94) LITERAL -> . BOOL
    (95) LITERAL -> . CHAR
    (96) LITERAL -> . STRING

    TYPENAME        shift and go to state 38
    OPEN_PAREN      shift and go to state 39
    IDENTIFIER      shift and go to state 35
    FLOAT           shift and go to state 25
    INTEGER         shift and go to state 21
    BOOL            shift and go to state 28
    CHAR            shift and go to state 29
    STRING          shift and go to state 30

    APAT                           shift and go to state 123
    PARAM                          shift and go to state 26
    LITERAL                        shift and go to state 27

state 92

    (48) LEXP -> LET . DECLARATIONS IN EXP
    (15) DECLARATIONS -> . OPEN_BRACE DECLARATIONS_LIST CLOSE_BRACE
    (16) DECLARATIONS -> . OPEN_BRACE CLOSE_BRACE

    OPEN_BRACE      shift and go to state 125

    DECLARATIONS                   shift and go to state 124

state 93

    (49) LEXP -> IF . EXP THEN EXP ELSE EXP
    (43) EXP -> . INFIX_EXP
    (44) INFIX_EXP -> . LEXP OP INFIX_EXP
    (45) INFIX_EXP -> . MINUS INFIX_EXP
    (46) INFIX_EXP -> . LEXP
    (47) LEXP -> . LAMBDA APAT APATS ARROW EXP
    (48) LEXP -> . LET DECLARATIONS IN EXP
    (49) LEXP -> . IF EXP THEN EXP ELSE EXP
    (50) LEXP -> . MATCH EXP OF OPEN_BRACE ALTS CLOSE_BRACE
    (51) LEXP -> . FEXP
    (52) FEXP -> . FEXP AEXP
    (53) FEXP -> . AEXP
    (54) AEXP -> . USED_VAR
    (55) AEXP -> . TYPENAME
    (56) AEXP -> . LITERAL
    (57) AEXP -> . OPEN_PAREN EXP CLOSE_PAREN
    (97) USED_VAR -> . IDENTIFIER
    (92) LITERAL -> . FLOAT
    (93) LITERAL -> . INTEGER
    (94) LITERAL -> . BOOL
    (95) LITERAL -> . CHAR
    (96) LITERAL -> . STRING

    MINUS           shift and go to state 90
    LAMBDA          shift and go to state 91
    LET             shift and go to state 92
    IF              shift and go to state 93
    MATCH           shift and go to state 94
    TYPENAME        shift and go to state 98
    OPEN_PAREN      shift and go to state 100
    IDENTIFIER      shift and go to state 101
    FLOAT           shift and go to state 25
    INTEGER         shift and go to state 21
    BOOL            shift and go to state 28
    CHAR            shift and go to state 29
    STRING          shift and go to state 30

    EXP                            shift and go to state 126
    INFIX_EXP                      shift and go to state 88
    LEXP                           shift and go to state 89
    FEXP                           shift and go to state 95
    AEXP                           shift and go to state 96
    USED_VAR                       shift and go to state 97
    LITERAL                        shift and go to state 99

state 94

    (50) LEXP -> MATCH . EXP OF OPEN_BRACE ALTS CLOSE_BRACE
    (43) EXP -> . INFIX_EXP
    (44) INFIX_EXP -> . LEXP OP INFIX_EXP
    (45) INFIX_EXP -> . MINUS INFIX_EXP
    (46) INFIX_EXP -> . LEXP
    (47) LEXP -> . LAMBDA APAT APATS ARROW EXP
    (48) LEXP -> . LET DECLARATIONS IN EXP
    (49) LEXP -> . IF EXP THEN EXP ELSE EXP
    (50) LEXP -> . MATCH EXP OF OPEN_BRACE ALTS CLOSE_BRACE
    (51) LEXP -> . FEXP
    (52) FEXP -> . FEXP AEXP
    (53) FEXP -> . AEXP
    (54) AEXP -> . USED_VAR
    (55) AEXP -> . TYPENAME
    (56) AEXP -> . LITERAL
    (57) AEXP -> . OPEN_PAREN EXP CLOSE_PAREN
    (97) USED_VAR -> . IDENTIFIER
    (92) LITERAL -> . FLOAT
    (93) LITERAL -> . INTEGER
    (94) LITERAL -> . BOOL
    (95) LITERAL -> . CHAR
    (96) LITERAL -> . STRING

    MINUS           shift and go to state 90
    LAMBDA          shift and go to state 91
    LET             shift and go to state 92
    IF              shift and go to state 93
    MATCH           shift and go to state 94
    TYPENAME        shift and go to state 98
    OPEN_PAREN      shift and go to state 100
    IDENTIFIER      shift and go to state 101
    FLOAT           shift and go to state 25
    INTEGER         shift and go to state 21
    BOOL            shift and go to state 28
    CHAR            shift and go to state 29
    STRING          shift and go to state 30

    EXP                            shift and go to state 127
    INFIX_EXP                      shift and go to state 88
    LEXP                           shift and go to state 89
    FEXP                           shift and go to state 95
    AEXP                           shift and go to state 96
    USED_VAR                       shift and go to state 97
    LITERAL                        shift and go to state 99

state 95

    (51) LEXP -> FEXP .
    (52) FEXP -> FEXP . AEXP
    (54) AEXP -> . USED_VAR
    (55) AEXP -> . TYPENAME
    (56) AEXP -> . LITERAL
    (57) AEXP -> . OPEN_PAREN EXP CLOSE_PAREN
    (97) USED_VAR -> . IDENTIFIER
    (92) LITERAL -> . FLOAT
    (93) LITERAL -> . INTEGER
    (94) LITERAL -> . BOOL
    (95) LITERAL -> . CHAR
    (96) LITERAL -> . STRING

    BACKTICK        reduce using rule 51 (LEXP -> FEXP .)
    PLUS            reduce using rule 51 (LEXP -> FEXP .)
    MINUS           reduce using rule 51 (LEXP -> FEXP .)
    TIMES           reduce using rule 51 (LEXP -> FEXP .)
    DIVIDE          reduce using rule 51 (LEXP -> FEXP .)
    MODULO          reduce using rule 51 (LEXP -> FEXP .)
    POW             reduce using rule 51 (LEXP -> FEXP .)
    EQUALITY        reduce using rule 51 (LEXP -> FEXP .)
    INEQUALITY      reduce using rule 51 (LEXP -> FEXP .)
    LESS            reduce using rule 51 (LEXP -> FEXP .)
    LEQ             reduce using rule 51 (LEXP -> FEXP .)
    GREATER         reduce using rule 51 (LEXP -> FEXP .)
    GEQ             reduce using rule 51 (LEXP -> FEXP .)
    AND             reduce using rule 51 (LEXP -> FEXP .)
    OR              reduce using rule 51 (LEXP -> FEXP .)
    LIST_CONSTRUCTOR reduce using rule 51 (LEXP -> FEXP .)
    WHERE           reduce using rule 51 (LEXP -> FEXP .)
    CLOSE_BRACE     reduce using rule 51 (LEXP -> FEXP .)
    ENDSTATEMENT    reduce using rule 51 (LEXP -> FEXP .)
    EQUALS          reduce using rule 51 (LEXP -> FEXP .)
    THEN            reduce using rule 51 (LEXP -> FEXP .)
    OF              reduce using rule 51 (LEXP -> FEXP .)
    CLOSE_PAREN     reduce using rule 51 (LEXP -> FEXP .)
    PIPE            reduce using rule 51 (LEXP -> FEXP .)
    ELSE            reduce using rule 51 (LEXP -> FEXP .)
    TYPENAME        shift and go to state 98
    OPEN_PAREN      shift and go to state 100
    IDENTIFIER      shift and go to state 101
    FLOAT           shift and go to state 25
    INTEGER         shift and go to state 21
    BOOL            shift and go to state 28
    CHAR            shift and go to state 29
    STRING          shift and go to state 30

    AEXP                           shift and go to state 128
    USED_VAR                       shift and go to state 97
    LITERAL                        shift and go to state 99

state 96

    (53) FEXP -> AEXP .

    TYPENAME        reduce using rule 53 (FEXP -> AEXP .)
    OPEN_PAREN      reduce using rule 53 (FEXP -> AEXP .)
    IDENTIFIER      reduce using rule 53 (FEXP -> AEXP .)
    FLOAT           reduce using rule 53 (FEXP -> AEXP .)
    INTEGER         reduce using rule 53 (FEXP -> AEXP .)
    BOOL            reduce using rule 53 (FEXP -> AEXP .)
    CHAR            reduce using rule 53 (FEXP -> AEXP .)
    STRING          reduce using rule 53 (FEXP -> AEXP .)
    BACKTICK        reduce using rule 53 (FEXP -> AEXP .)
    PLUS            reduce using rule 53 (FEXP -> AEXP .)
    MINUS           reduce using rule 53 (FEXP -> AEXP .)
    TIMES           reduce using rule 53 (FEXP -> AEXP .)
    DIVIDE          reduce using rule 53 (FEXP -> AEXP .)
    MODULO          reduce using rule 53 (FEXP -> AEXP .)
    POW             reduce using rule 53 (FEXP -> AEXP .)
    EQUALITY        reduce using rule 53 (FEXP -> AEXP .)
    INEQUALITY      reduce using rule 53 (FEXP -> AEXP .)
    LESS            reduce using rule 53 (FEXP -> AEXP .)
    LEQ             reduce using rule 53 (FEXP -> AEXP .)
    GREATER         reduce using rule 53 (FEXP -> AEXP .)
    GEQ             reduce using rule 53 (FEXP -> AEXP .)
    AND             reduce using rule 53 (FEXP -> AEXP .)
    OR              reduce using rule 53 (FEXP -> AEXP .)
    LIST_CONSTRUCTOR reduce using rule 53 (FEXP -> AEXP .)
    WHERE           reduce using rule 53 (FEXP -> AEXP .)
    CLOSE_BRACE     reduce using rule 53 (FEXP -> AEXP .)
    ENDSTATEMENT    reduce using rule 53 (FEXP -> AEXP .)
    EQUALS          reduce using rule 53 (FEXP -> AEXP .)
    THEN            reduce using rule 53 (FEXP -> AEXP .)
    OF              reduce using rule 53 (FEXP -> AEXP .)
    CLOSE_PAREN     reduce using rule 53 (FEXP -> AEXP .)
    PIPE            reduce using rule 53 (FEXP -> AEXP .)
    ELSE            reduce using rule 53 (FEXP -> AEXP .)


state 97

    (54) AEXP -> USED_VAR .

    TYPENAME        reduce using rule 54 (AEXP -> USED_VAR .)
    OPEN_PAREN      reduce using rule 54 (AEXP -> USED_VAR .)
    IDENTIFIER      reduce using rule 54 (AEXP -> USED_VAR .)
    FLOAT           reduce using rule 54 (AEXP -> USED_VAR .)
    INTEGER         reduce using rule 54 (AEXP -> USED_VAR .)
    BOOL            reduce using rule 54 (AEXP -> USED_VAR .)
    CHAR            reduce using rule 54 (AEXP -> USED_VAR .)
    STRING          reduce using rule 54 (AEXP -> USED_VAR .)
    BACKTICK        reduce using rule 54 (AEXP -> USED_VAR .)
    PLUS            reduce using rule 54 (AEXP -> USED_VAR .)
    MINUS           reduce using rule 54 (AEXP -> USED_VAR .)
    TIMES           reduce using rule 54 (AEXP -> USED_VAR .)
    DIVIDE          reduce using rule 54 (AEXP -> USED_VAR .)
    MODULO          reduce using rule 54 (AEXP -> USED_VAR .)
    POW             reduce using rule 54 (AEXP -> USED_VAR .)
    EQUALITY        reduce using rule 54 (AEXP -> USED_VAR .)
    INEQUALITY      reduce using rule 54 (AEXP -> USED_VAR .)
    LESS            reduce using rule 54 (AEXP -> USED_VAR .)
    LEQ             reduce using rule 54 (AEXP -> USED_VAR .)
    GREATER         reduce using rule 54 (AEXP -> USED_VAR .)
    GEQ             reduce using rule 54 (AEXP -> USED_VAR .)
    AND             reduce using rule 54 (AEXP -> USED_VAR .)
    OR              reduce using rule 54 (AEXP -> USED_VAR .)
    LIST_CONSTRUCTOR reduce using rule 54 (AEXP -> USED_VAR .)
    WHERE           reduce using rule 54 (AEXP -> USED_VAR .)
    CLOSE_BRACE     reduce using rule 54 (AEXP -> USED_VAR .)
    ENDSTATEMENT    reduce using rule 54 (AEXP -> USED_VAR .)
    EQUALS          reduce using rule 54 (AEXP -> USED_VAR .)
    THEN            reduce using rule 54 (AEXP -> USED_VAR .)
    OF              reduce using rule 54 (AEXP -> USED_VAR .)
    CLOSE_PAREN     reduce using rule 54 (AEXP -> USED_VAR .)
    PIPE            reduce using rule 54 (AEXP -> USED_VAR .)
    ELSE            reduce using rule 54 (AEXP -> USED_VAR .)


state 98

    (55) AEXP -> TYPENAME .

    TYPENAME        reduce using rule 55 (AEXP -> TYPENAME .)
    OPEN_PAREN      reduce using rule 55 (AEXP -> TYPENAME .)
    IDENTIFIER      reduce using rule 55 (AEXP -> TYPENAME .)
    FLOAT           reduce using rule 55 (AEXP -> TYPENAME .)
    INTEGER         reduce using rule 55 (AEXP -> TYPENAME .)
    BOOL            reduce using rule 55 (AEXP -> TYPENAME .)
    CHAR            reduce using rule 55 (AEXP -> TYPENAME .)
    STRING          reduce using rule 55 (AEXP -> TYPENAME .)
    BACKTICK        reduce using rule 55 (AEXP -> TYPENAME .)
    PLUS            reduce using rule 55 (AEXP -> TYPENAME .)
    MINUS           reduce using rule 55 (AEXP -> TYPENAME .)
    TIMES           reduce using rule 55 (AEXP -> TYPENAME .)
    DIVIDE          reduce using rule 55 (AEXP -> TYPENAME .)
    MODULO          reduce using rule 55 (AEXP -> TYPENAME .)
    POW             reduce using rule 55 (AEXP -> TYPENAME .)
    EQUALITY        reduce using rule 55 (AEXP -> TYPENAME .)
    INEQUALITY      reduce using rule 55 (AEXP -> TYPENAME .)
    LESS            reduce using rule 55 (AEXP -> TYPENAME .)
    LEQ             reduce using rule 55 (AEXP -> TYPENAME .)
    GREATER         reduce using rule 55 (AEXP -> TYPENAME .)
    GEQ             reduce using rule 55 (AEXP -> TYPENAME .)
    AND             reduce using rule 55 (AEXP -> TYPENAME .)
    OR              reduce using rule 55 (AEXP -> TYPENAME .)
    LIST_CONSTRUCTOR reduce using rule 55 (AEXP -> TYPENAME .)
    WHERE           reduce using rule 55 (AEXP -> TYPENAME .)
    CLOSE_BRACE     reduce using rule 55 (AEXP -> TYPENAME .)
    ENDSTATEMENT    reduce using rule 55 (AEXP -> TYPENAME .)
    EQUALS          reduce using rule 55 (AEXP -> TYPENAME .)
    THEN            reduce using rule 55 (AEXP -> TYPENAME .)
    OF              reduce using rule 55 (AEXP -> TYPENAME .)
    CLOSE_PAREN     reduce using rule 55 (AEXP -> TYPENAME .)
    PIPE            reduce using rule 55 (AEXP -> TYPENAME .)
    ELSE            reduce using rule 55 (AEXP -> TYPENAME .)


state 99

    (56) AEXP -> LITERAL .

    TYPENAME        reduce using rule 56 (AEXP -> LITERAL .)
    OPEN_PAREN      reduce using rule 56 (AEXP -> LITERAL .)
    IDENTIFIER      reduce using rule 56 (AEXP -> LITERAL .)
    FLOAT           reduce using rule 56 (AEXP -> LITERAL .)
    INTEGER         reduce using rule 56 (AEXP -> LITERAL .)
    BOOL            reduce using rule 56 (AEXP -> LITERAL .)
    CHAR            reduce using rule 56 (AEXP -> LITERAL .)
    STRING          reduce using rule 56 (AEXP -> LITERAL .)
    BACKTICK        reduce using rule 56 (AEXP -> LITERAL .)
    PLUS            reduce using rule 56 (AEXP -> LITERAL .)
    MINUS           reduce using rule 56 (AEXP -> LITERAL .)
    TIMES           reduce using rule 56 (AEXP -> LITERAL .)
    DIVIDE          reduce using rule 56 (AEXP -> LITERAL .)
    MODULO          reduce using rule 56 (AEXP -> LITERAL .)
    POW             reduce using rule 56 (AEXP -> LITERAL .)
    EQUALITY        reduce using rule 56 (AEXP -> LITERAL .)
    INEQUALITY      reduce using rule 56 (AEXP -> LITERAL .)
    LESS            reduce using rule 56 (AEXP -> LITERAL .)
    LEQ             reduce using rule 56 (AEXP -> LITERAL .)
    GREATER         reduce using rule 56 (AEXP -> LITERAL .)
    GEQ             reduce using rule 56 (AEXP -> LITERAL .)
    AND             reduce using rule 56 (AEXP -> LITERAL .)
    OR              reduce using rule 56 (AEXP -> LITERAL .)
    LIST_CONSTRUCTOR reduce using rule 56 (AEXP -> LITERAL .)
    WHERE           reduce using rule 56 (AEXP -> LITERAL .)
    CLOSE_BRACE     reduce using rule 56 (AEXP -> LITERAL .)
    ENDSTATEMENT    reduce using rule 56 (AEXP -> LITERAL .)
    EQUALS          reduce using rule 56 (AEXP -> LITERAL .)
    THEN            reduce using rule 56 (AEXP -> LITERAL .)
    OF              reduce using rule 56 (AEXP -> LITERAL .)
    CLOSE_PAREN     reduce using rule 56 (AEXP -> LITERAL .)
    PIPE            reduce using rule 56 (AEXP -> LITERAL .)
    ELSE            reduce using rule 56 (AEXP -> LITERAL .)


state 100

    (57) AEXP -> OPEN_PAREN . EXP CLOSE_PAREN
    (43) EXP -> . INFIX_EXP
    (44) INFIX_EXP -> . LEXP OP INFIX_EXP
    (45) INFIX_EXP -> . MINUS INFIX_EXP
    (46) INFIX_EXP -> . LEXP
    (47) LEXP -> . LAMBDA APAT APATS ARROW EXP
    (48) LEXP -> . LET DECLARATIONS IN EXP
    (49) LEXP -> . IF EXP THEN EXP ELSE EXP
    (50) LEXP -> . MATCH EXP OF OPEN_BRACE ALTS CLOSE_BRACE
    (51) LEXP -> . FEXP
    (52) FEXP -> . FEXP AEXP
    (53) FEXP -> . AEXP
    (54) AEXP -> . USED_VAR
    (55) AEXP -> . TYPENAME
    (56) AEXP -> . LITERAL
    (57) AEXP -> . OPEN_PAREN EXP CLOSE_PAREN
    (97) USED_VAR -> . IDENTIFIER
    (92) LITERAL -> . FLOAT
    (93) LITERAL -> . INTEGER
    (94) LITERAL -> . BOOL
    (95) LITERAL -> . CHAR
    (96) LITERAL -> . STRING

    MINUS           shift and go to state 90
    LAMBDA          shift and go to state 91
    LET             shift and go to state 92
    IF              shift and go to state 93
    MATCH           shift and go to state 94
    TYPENAME        shift and go to state 98
    OPEN_PAREN      shift and go to state 100
    IDENTIFIER      shift and go to state 101
    FLOAT           shift and go to state 25
    INTEGER         shift and go to state 21
    BOOL            shift and go to state 28
    CHAR            shift and go to state 29
    STRING          shift and go to state 30

    EXP                            shift and go to state 129
    INFIX_EXP                      shift and go to state 88
    LEXP                           shift and go to state 89
    FEXP                           shift and go to state 95
    AEXP                           shift and go to state 96
    USED_VAR                       shift and go to state 97
    LITERAL                        shift and go to state 99

state 101

    (97) USED_VAR -> IDENTIFIER .

    TYPENAME        reduce using rule 97 (USED_VAR -> IDENTIFIER .)
    OPEN_PAREN      reduce using rule 97 (USED_VAR -> IDENTIFIER .)
    IDENTIFIER      reduce using rule 97 (USED_VAR -> IDENTIFIER .)
    FLOAT           reduce using rule 97 (USED_VAR -> IDENTIFIER .)
    INTEGER         reduce using rule 97 (USED_VAR -> IDENTIFIER .)
    BOOL            reduce using rule 97 (USED_VAR -> IDENTIFIER .)
    CHAR            reduce using rule 97 (USED_VAR -> IDENTIFIER .)
    STRING          reduce using rule 97 (USED_VAR -> IDENTIFIER .)
    BACKTICK        reduce using rule 97 (USED_VAR -> IDENTIFIER .)
    PLUS            reduce using rule 97 (USED_VAR -> IDENTIFIER .)
    MINUS           reduce using rule 97 (USED_VAR -> IDENTIFIER .)
    TIMES           reduce using rule 97 (USED_VAR -> IDENTIFIER .)
    DIVIDE          reduce using rule 97 (USED_VAR -> IDENTIFIER .)
    MODULO          reduce using rule 97 (USED_VAR -> IDENTIFIER .)
    POW             reduce using rule 97 (USED_VAR -> IDENTIFIER .)
    EQUALITY        reduce using rule 97 (USED_VAR -> IDENTIFIER .)
    INEQUALITY      reduce using rule 97 (USED_VAR -> IDENTIFIER .)
    LESS            reduce using rule 97 (USED_VAR -> IDENTIFIER .)
    LEQ             reduce using rule 97 (USED_VAR -> IDENTIFIER .)
    GREATER         reduce using rule 97 (USED_VAR -> IDENTIFIER .)
    GEQ             reduce using rule 97 (USED_VAR -> IDENTIFIER .)
    AND             reduce using rule 97 (USED_VAR -> IDENTIFIER .)
    OR              reduce using rule 97 (USED_VAR -> IDENTIFIER .)
    LIST_CONSTRUCTOR reduce using rule 97 (USED_VAR -> IDENTIFIER .)
    WHERE           reduce using rule 97 (USED_VAR -> IDENTIFIER .)
    CLOSE_BRACE     reduce using rule 97 (USED_VAR -> IDENTIFIER .)
    ENDSTATEMENT    reduce using rule 97 (USED_VAR -> IDENTIFIER .)
    EQUALS          reduce using rule 97 (USED_VAR -> IDENTIFIER .)
    THEN            reduce using rule 97 (USED_VAR -> IDENTIFIER .)
    OF              reduce using rule 97 (USED_VAR -> IDENTIFIER .)
    CLOSE_PAREN     reduce using rule 97 (USED_VAR -> IDENTIFIER .)
    PIPE            reduce using rule 97 (USED_VAR -> IDENTIFIER .)
    ELSE            reduce using rule 97 (USED_VAR -> IDENTIFIER .)


state 102

    (40) RHS -> GDRHS WHERE . DECLARATIONS
    (15) DECLARATIONS -> . OPEN_BRACE DECLARATIONS_LIST CLOSE_BRACE
    (16) DECLARATIONS -> . OPEN_BRACE CLOSE_BRACE

    OPEN_BRACE      shift and go to state 125

    DECLARATIONS                   shift and go to state 130

state 103

    (41) GDRHS -> PIPE EXP . EQUALS EXP
    (42) GDRHS -> PIPE EXP . EQUALS EXP GDRHS

    EQUALS          shift and go to state 131


state 104

    (35) FUNCTION_LHS -> LPAT VAROP LPAT .

    EQUALS          reduce using rule 35 (FUNCTION_LHS -> LPAT VAROP LPAT .)
    PIPE            reduce using rule 35 (FUNCTION_LHS -> LPAT VAROP LPAT .)
    CLOSE_PAREN     reduce using rule 35 (FUNCTION_LHS -> LPAT VAROP LPAT .)


state 105

    (73) VAROP -> BACKTICK IDENTIFIER . BACKTICK

    BACKTICK        shift and go to state 132


state 106

    (23) GEN_DECLARATION -> SETFIX ASSOCIATIVITY INTEGER . OP
    (74) OP -> . VAROP
    (72) VAROP -> . VARSYM
    (73) VAROP -> . BACKTICK IDENTIFIER BACKTICK
    (77) VARSYM -> . PLUS
    (78) VARSYM -> . MINUS
    (79) VARSYM -> . TIMES
    (80) VARSYM -> . DIVIDE
    (81) VARSYM -> . MODULO
    (82) VARSYM -> . POW
    (83) VARSYM -> . EQUALITY
    (84) VARSYM -> . INEQUALITY
    (85) VARSYM -> . LESS
    (86) VARSYM -> . LEQ
    (87) VARSYM -> . GREATER
    (88) VARSYM -> . GEQ
    (89) VARSYM -> . AND
    (90) VARSYM -> . OR
    (91) VARSYM -> . LIST_CONSTRUCTOR

    BACKTICK        shift and go to state 50
    PLUS            shift and go to state 51
    MINUS           shift and go to state 52
    TIMES           shift and go to state 53
    DIVIDE          shift and go to state 54
    MODULO          shift and go to state 55
    POW             shift and go to state 56
    EQUALITY        shift and go to state 57
    INEQUALITY      shift and go to state 58
    LESS            shift and go to state 59
    LEQ             shift and go to state 60
    GREATER         shift and go to state 61
    GEQ             shift and go to state 62
    AND             shift and go to state 63
    OR              shift and go to state 64
    LIST_CONSTRUCTOR shift and go to state 65

    OP                             shift and go to state 133
    VAROP                          shift and go to state 121
    VARSYM                         shift and go to state 49

state 107

    (36) FUNCTION_LHS -> OPEN_PAREN FUNCTION_LHS CLOSE_PAREN . APAT APATS
    (68) APAT -> . PARAM
    (69) APAT -> . TYPENAME
    (70) APAT -> . LITERAL
    (71) APAT -> . OPEN_PAREN LPAT CLOSE_PAREN
    (98) PARAM -> . IDENTIFIER
    (92) LITERAL -> . FLOAT
    (93) LITERAL -> . INTEGER
    (94) LITERAL -> . BOOL
    (95) LITERAL -> . CHAR
    (96) LITERAL -> . STRING

    TYPENAME        shift and go to state 38
    OPEN_PAREN      shift and go to state 39
    IDENTIFIER      shift and go to state 35
    FLOAT           shift and go to state 25
    INTEGER         shift and go to state 21
    BOOL            shift and go to state 28
    CHAR            shift and go to state 29
    STRING          shift and go to state 30

    APAT                           shift and go to state 134
    PARAM                          shift and go to state 26
    LITERAL                        shift and go to state 27

state 108

    (71) APAT -> OPEN_PAREN LPAT CLOSE_PAREN .

    EQUALS          reduce using rule 71 (APAT -> OPEN_PAREN LPAT CLOSE_PAREN .)
    BACKTICK        reduce using rule 71 (APAT -> OPEN_PAREN LPAT CLOSE_PAREN .)
    PIPE            reduce using rule 71 (APAT -> OPEN_PAREN LPAT CLOSE_PAREN .)
    PLUS            reduce using rule 71 (APAT -> OPEN_PAREN LPAT CLOSE_PAREN .)
    MINUS           reduce using rule 71 (APAT -> OPEN_PAREN LPAT CLOSE_PAREN .)
    TIMES           reduce using rule 71 (APAT -> OPEN_PAREN LPAT CLOSE_PAREN .)
    DIVIDE          reduce using rule 71 (APAT -> OPEN_PAREN LPAT CLOSE_PAREN .)
    MODULO          reduce using rule 71 (APAT -> OPEN_PAREN LPAT CLOSE_PAREN .)
    POW             reduce using rule 71 (APAT -> OPEN_PAREN LPAT CLOSE_PAREN .)
    EQUALITY        reduce using rule 71 (APAT -> OPEN_PAREN LPAT CLOSE_PAREN .)
    INEQUALITY      reduce using rule 71 (APAT -> OPEN_PAREN LPAT CLOSE_PAREN .)
    LESS            reduce using rule 71 (APAT -> OPEN_PAREN LPAT CLOSE_PAREN .)
    LEQ             reduce using rule 71 (APAT -> OPEN_PAREN LPAT CLOSE_PAREN .)
    GREATER         reduce using rule 71 (APAT -> OPEN_PAREN LPAT CLOSE_PAREN .)
    GEQ             reduce using rule 71 (APAT -> OPEN_PAREN LPAT CLOSE_PAREN .)
    AND             reduce using rule 71 (APAT -> OPEN_PAREN LPAT CLOSE_PAREN .)
    OR              reduce using rule 71 (APAT -> OPEN_PAREN LPAT CLOSE_PAREN .)
    LIST_CONSTRUCTOR reduce using rule 71 (APAT -> OPEN_PAREN LPAT CLOSE_PAREN .)
    TYPENAME        reduce using rule 71 (APAT -> OPEN_PAREN LPAT CLOSE_PAREN .)
    OPEN_PAREN      reduce using rule 71 (APAT -> OPEN_PAREN LPAT CLOSE_PAREN .)
    IDENTIFIER      reduce using rule 71 (APAT -> OPEN_PAREN LPAT CLOSE_PAREN .)
    FLOAT           reduce using rule 71 (APAT -> OPEN_PAREN LPAT CLOSE_PAREN .)
    INTEGER         reduce using rule 71 (APAT -> OPEN_PAREN LPAT CLOSE_PAREN .)
    BOOL            reduce using rule 71 (APAT -> OPEN_PAREN LPAT CLOSE_PAREN .)
    CHAR            reduce using rule 71 (APAT -> OPEN_PAREN LPAT CLOSE_PAREN .)
    STRING          reduce using rule 71 (APAT -> OPEN_PAREN LPAT CLOSE_PAREN .)
    CLOSE_PAREN     reduce using rule 71 (APAT -> OPEN_PAREN LPAT CLOSE_PAREN .)
    ARROW           reduce using rule 71 (APAT -> OPEN_PAREN LPAT CLOSE_PAREN .)


state 109

    (65) LPAT -> MINUS OPEN_PAREN INTEGER . CLOSE_PAREN

    CLOSE_PAREN     shift and go to state 135


state 110

    (66) LPAT -> MINUS OPEN_PAREN FLOAT . CLOSE_PAREN

    CLOSE_PAREN     shift and go to state 136


state 111

    (2) BODY -> OPEN_BRACE IMPORT_DECLARATIONS ENDSTATEMENT TOP_DECLARATIONS CLOSE_BRACE .

    $end            reduce using rule 2 (BODY -> OPEN_BRACE IMPORT_DECLARATIONS ENDSTATEMENT TOP_DECLARATIONS CLOSE_BRACE .)


state 112

    (29) TYPE -> ATYPE ARROW . TYPE
    (28) TYPE -> . ATYPE
    (29) TYPE -> . ATYPE ARROW TYPE
    (32) ATYPE -> . TYPENAME
    (33) ATYPE -> . OPEN_PAREN TYPE CLOSE_PAREN

    TYPENAME        shift and go to state 79
    OPEN_PAREN      shift and go to state 80

    ATYPE                          shift and go to state 78
    TYPE                           shift and go to state 137

state 113

    (33) ATYPE -> OPEN_PAREN TYPE . CLOSE_PAREN

    CLOSE_PAREN     shift and go to state 138


state 114

    (75) APATS -> APAT APATS .

    EQUALS          reduce using rule 75 (APATS -> APAT APATS .)
    PIPE            reduce using rule 75 (APATS -> APAT APATS .)
    CLOSE_PAREN     reduce using rule 75 (APATS -> APAT APATS .)
    BACKTICK        reduce using rule 75 (APATS -> APAT APATS .)
    PLUS            reduce using rule 75 (APATS -> APAT APATS .)
    MINUS           reduce using rule 75 (APATS -> APAT APATS .)
    TIMES           reduce using rule 75 (APATS -> APAT APATS .)
    DIVIDE          reduce using rule 75 (APATS -> APAT APATS .)
    MODULO          reduce using rule 75 (APATS -> APAT APATS .)
    POW             reduce using rule 75 (APATS -> APAT APATS .)
    EQUALITY        reduce using rule 75 (APATS -> APAT APATS .)
    INEQUALITY      reduce using rule 75 (APATS -> APAT APATS .)
    LESS            reduce using rule 75 (APATS -> APAT APATS .)
    LEQ             reduce using rule 75 (APATS -> APAT APATS .)
    GREATER         reduce using rule 75 (APATS -> APAT APATS .)
    GEQ             reduce using rule 75 (APATS -> APAT APATS .)
    AND             reduce using rule 75 (APATS -> APAT APATS .)
    OR              reduce using rule 75 (APATS -> APAT APATS .)
    LIST_CONSTRUCTOR reduce using rule 75 (APATS -> APAT APATS .)
    ARROW           reduce using rule 75 (APATS -> APAT APATS .)


state 115

    (9) TOP_DECLARATION -> NEWTYPE TYPENAME EQUALS TYPE .

    CLOSE_BRACE     reduce using rule 9 (TOP_DECLARATION -> NEWTYPE TYPENAME EQUALS TYPE .)
    ENDSTATEMENT    reduce using rule 9 (TOP_DECLARATION -> NEWTYPE TYPENAME EQUALS TYPE .)


state 116

    (14) CONSTRUCTOR -> TYPENAME . ATYPES
    (30) ATYPES -> . ATYPES ATYPE
    (31) ATYPES -> .

    TYPENAME        reduce using rule 31 (ATYPES -> .)
    OPEN_PAREN      reduce using rule 31 (ATYPES -> .)
    PIPE            reduce using rule 31 (ATYPES -> .)
    CLOSE_BRACE     reduce using rule 31 (ATYPES -> .)
    ENDSTATEMENT    reduce using rule 31 (ATYPES -> .)

    ATYPES                         shift and go to state 139

state 117

    (10) TOP_DECLARATION -> NEWCONS TYPENAME EQUALS CONSTRUCTORS .
    (12) CONSTRUCTORS -> CONSTRUCTORS . PIPE CONSTRUCTOR

    CLOSE_BRACE     reduce using rule 10 (TOP_DECLARATION -> NEWCONS TYPENAME EQUALS CONSTRUCTORS .)
    ENDSTATEMENT    reduce using rule 10 (TOP_DECLARATION -> NEWCONS TYPENAME EQUALS CONSTRUCTORS .)
    PIPE            shift and go to state 140


state 118

    (13) CONSTRUCTORS -> CONSTRUCTOR .

    PIPE            reduce using rule 13 (CONSTRUCTORS -> CONSTRUCTOR .)
    CLOSE_BRACE     reduce using rule 13 (CONSTRUCTORS -> CONSTRUCTOR .)
    ENDSTATEMENT    reduce using rule 13 (CONSTRUCTORS -> CONSTRUCTOR .)


state 119

    (38) RHS -> EQUALS EXP WHERE . DECLARATIONS
    (15) DECLARATIONS -> . OPEN_BRACE DECLARATIONS_LIST CLOSE_BRACE
    (16) DECLARATIONS -> . OPEN_BRACE CLOSE_BRACE

    OPEN_BRACE      shift and go to state 125

    DECLARATIONS                   shift and go to state 141

state 120

    (44) INFIX_EXP -> LEXP OP . INFIX_EXP
    (44) INFIX_EXP -> . LEXP OP INFIX_EXP
    (45) INFIX_EXP -> . MINUS INFIX_EXP
    (46) INFIX_EXP -> . LEXP
    (47) LEXP -> . LAMBDA APAT APATS ARROW EXP
    (48) LEXP -> . LET DECLARATIONS IN EXP
    (49) LEXP -> . IF EXP THEN EXP ELSE EXP
    (50) LEXP -> . MATCH EXP OF OPEN_BRACE ALTS CLOSE_BRACE
    (51) LEXP -> . FEXP
    (52) FEXP -> . FEXP AEXP
    (53) FEXP -> . AEXP
    (54) AEXP -> . USED_VAR
    (55) AEXP -> . TYPENAME
    (56) AEXP -> . LITERAL
    (57) AEXP -> . OPEN_PAREN EXP CLOSE_PAREN
    (97) USED_VAR -> . IDENTIFIER
    (92) LITERAL -> . FLOAT
    (93) LITERAL -> . INTEGER
    (94) LITERAL -> . BOOL
    (95) LITERAL -> . CHAR
    (96) LITERAL -> . STRING

    MINUS           shift and go to state 90
    LAMBDA          shift and go to state 91
    LET             shift and go to state 92
    IF              shift and go to state 93
    MATCH           shift and go to state 94
    TYPENAME        shift and go to state 98
    OPEN_PAREN      shift and go to state 100
    IDENTIFIER      shift and go to state 101
    FLOAT           shift and go to state 25
    INTEGER         shift and go to state 21
    BOOL            shift and go to state 28
    CHAR            shift and go to state 29
    STRING          shift and go to state 30

    LEXP                           shift and go to state 89
    INFIX_EXP                      shift and go to state 142
    FEXP                           shift and go to state 95
    AEXP                           shift and go to state 96
    USED_VAR                       shift and go to state 97
    LITERAL                        shift and go to state 99

state 121

    (74) OP -> VAROP .

    MINUS           reduce using rule 74 (OP -> VAROP .)
    LAMBDA          reduce using rule 74 (OP -> VAROP .)
    LET             reduce using rule 74 (OP -> VAROP .)
    IF              reduce using rule 74 (OP -> VAROP .)
    MATCH           reduce using rule 74 (OP -> VAROP .)
    TYPENAME        reduce using rule 74 (OP -> VAROP .)
    OPEN_PAREN      reduce using rule 74 (OP -> VAROP .)
    IDENTIFIER      reduce using rule 74 (OP -> VAROP .)
    FLOAT           reduce using rule 74 (OP -> VAROP .)
    INTEGER         reduce using rule 74 (OP -> VAROP .)
    BOOL            reduce using rule 74 (OP -> VAROP .)
    CHAR            reduce using rule 74 (OP -> VAROP .)
    STRING          reduce using rule 74 (OP -> VAROP .)
    CLOSE_BRACE     reduce using rule 74 (OP -> VAROP .)
    ENDSTATEMENT    reduce using rule 74 (OP -> VAROP .)


state 122

    (45) INFIX_EXP -> MINUS INFIX_EXP .

    WHERE           reduce using rule 45 (INFIX_EXP -> MINUS INFIX_EXP .)
    CLOSE_BRACE     reduce using rule 45 (INFIX_EXP -> MINUS INFIX_EXP .)
    ENDSTATEMENT    reduce using rule 45 (INFIX_EXP -> MINUS INFIX_EXP .)
    EQUALS          reduce using rule 45 (INFIX_EXP -> MINUS INFIX_EXP .)
    THEN            reduce using rule 45 (INFIX_EXP -> MINUS INFIX_EXP .)
    OF              reduce using rule 45 (INFIX_EXP -> MINUS INFIX_EXP .)
    CLOSE_PAREN     reduce using rule 45 (INFIX_EXP -> MINUS INFIX_EXP .)
    PIPE            reduce using rule 45 (INFIX_EXP -> MINUS INFIX_EXP .)
    BACKTICK        reduce using rule 45 (INFIX_EXP -> MINUS INFIX_EXP .)
    PLUS            reduce using rule 45 (INFIX_EXP -> MINUS INFIX_EXP .)
    MINUS           reduce using rule 45 (INFIX_EXP -> MINUS INFIX_EXP .)
    TIMES           reduce using rule 45 (INFIX_EXP -> MINUS INFIX_EXP .)
    DIVIDE          reduce using rule 45 (INFIX_EXP -> MINUS INFIX_EXP .)
    MODULO          reduce using rule 45 (INFIX_EXP -> MINUS INFIX_EXP .)
    POW             reduce using rule 45 (INFIX_EXP -> MINUS INFIX_EXP .)
    EQUALITY        reduce using rule 45 (INFIX_EXP -> MINUS INFIX_EXP .)
    INEQUALITY      reduce using rule 45 (INFIX_EXP -> MINUS INFIX_EXP .)
    LESS            reduce using rule 45 (INFIX_EXP -> MINUS INFIX_EXP .)
    LEQ             reduce using rule 45 (INFIX_EXP -> MINUS INFIX_EXP .)
    GREATER         reduce using rule 45 (INFIX_EXP -> MINUS INFIX_EXP .)
    GEQ             reduce using rule 45 (INFIX_EXP -> MINUS INFIX_EXP .)
    AND             reduce using rule 45 (INFIX_EXP -> MINUS INFIX_EXP .)
    OR              reduce using rule 45 (INFIX_EXP -> MINUS INFIX_EXP .)
    LIST_CONSTRUCTOR reduce using rule 45 (INFIX_EXP -> MINUS INFIX_EXP .)
    ELSE            reduce using rule 45 (INFIX_EXP -> MINUS INFIX_EXP .)


state 123

    (47) LEXP -> LAMBDA APAT . APATS ARROW EXP
    (75) APATS -> . APAT APATS
    (76) APATS -> .
    (68) APAT -> . PARAM
    (69) APAT -> . TYPENAME
    (70) APAT -> . LITERAL
    (71) APAT -> . OPEN_PAREN LPAT CLOSE_PAREN
    (98) PARAM -> . IDENTIFIER
    (92) LITERAL -> . FLOAT
    (93) LITERAL -> . INTEGER
    (94) LITERAL -> . BOOL
    (95) LITERAL -> . CHAR
    (96) LITERAL -> . STRING

    ARROW           reduce using rule 76 (APATS -> .)
    TYPENAME        shift and go to state 38
    OPEN_PAREN      shift and go to state 39
    IDENTIFIER      shift and go to state 35
    FLOAT           shift and go to state 25
    INTEGER         shift and go to state 21
    BOOL            shift and go to state 28
    CHAR            shift and go to state 29
    STRING          shift and go to state 30

    APAT                           shift and go to state 81
    APATS                          shift and go to state 143
    PARAM                          shift and go to state 26
    LITERAL                        shift and go to state 27

state 124

    (48) LEXP -> LET DECLARATIONS . IN EXP

    IN              shift and go to state 144


state 125

    (15) DECLARATIONS -> OPEN_BRACE . DECLARATIONS_LIST CLOSE_BRACE
    (16) DECLARATIONS -> OPEN_BRACE . CLOSE_BRACE
    (17) DECLARATIONS_LIST -> . DECLARATION ENDSTATEMENT DECLARATIONS_LIST
    (18) DECLARATIONS_LIST -> . DECLARATION
    (19) DECLARATION -> . GEN_DECLARATION
    (20) DECLARATION -> . FUNCTION_LHS RHS
    (21) DECLARATION -> . LPAT RHS
    (22) GEN_DECLARATION -> . IDENTIFIER TYPESIG TYPE
    (23) GEN_DECLARATION -> . SETFIX ASSOCIATIVITY INTEGER OP
    (24) GEN_DECLARATION -> .
    (34) FUNCTION_LHS -> . IDENTIFIER APAT APATS
    (35) FUNCTION_LHS -> . LPAT VAROP LPAT
    (36) FUNCTION_LHS -> . OPEN_PAREN FUNCTION_LHS CLOSE_PAREN APAT APATS
    (64) LPAT -> . APAT
    (65) LPAT -> . MINUS OPEN_PAREN INTEGER CLOSE_PAREN
    (66) LPAT -> . MINUS OPEN_PAREN FLOAT CLOSE_PAREN
    (67) LPAT -> . TYPENAME APAT APATS
    (68) APAT -> . PARAM
    (69) APAT -> . TYPENAME
    (70) APAT -> . LITERAL
    (71) APAT -> . OPEN_PAREN LPAT CLOSE_PAREN
    (98) PARAM -> . IDENTIFIER
    (92) LITERAL -> . FLOAT
    (93) LITERAL -> . INTEGER
    (94) LITERAL -> . BOOL
    (95) LITERAL -> . CHAR
    (96) LITERAL -> . STRING

  ! shift/reduce conflict for CLOSE_BRACE resolved as shift
    CLOSE_BRACE     shift and go to state 146
    IDENTIFIER      shift and go to state 12
    SETFIX          shift and go to state 20
    ENDSTATEMENT    reduce using rule 24 (GEN_DECLARATION -> .)
    OPEN_PAREN      shift and go to state 23
    MINUS           shift and go to state 24
    TYPENAME        shift and go to state 14
    FLOAT           shift and go to state 25
    INTEGER         shift and go to state 21
    BOOL            shift and go to state 28
    CHAR            shift and go to state 29
    STRING          shift and go to state 30

  ! CLOSE_BRACE     [ reduce using rule 24 (GEN_DECLARATION -> .) ]

    DECLARATIONS_LIST              shift and go to state 145
    DECLARATION                    shift and go to state 147
    GEN_DECLARATION                shift and go to state 17
    FUNCTION_LHS                   shift and go to state 18
    LPAT                           shift and go to state 19
    APAT                           shift and go to state 22
    PARAM                          shift and go to state 26
    LITERAL                        shift and go to state 27

state 126

    (49) LEXP -> IF EXP . THEN EXP ELSE EXP

    THEN            shift and go to state 148


state 127

    (50) LEXP -> MATCH EXP . OF OPEN_BRACE ALTS CLOSE_BRACE

    OF              shift and go to state 149


state 128

    (52) FEXP -> FEXP AEXP .

    TYPENAME        reduce using rule 52 (FEXP -> FEXP AEXP .)
    OPEN_PAREN      reduce using rule 52 (FEXP -> FEXP AEXP .)
    IDENTIFIER      reduce using rule 52 (FEXP -> FEXP AEXP .)
    FLOAT           reduce using rule 52 (FEXP -> FEXP AEXP .)
    INTEGER         reduce using rule 52 (FEXP -> FEXP AEXP .)
    BOOL            reduce using rule 52 (FEXP -> FEXP AEXP .)
    CHAR            reduce using rule 52 (FEXP -> FEXP AEXP .)
    STRING          reduce using rule 52 (FEXP -> FEXP AEXP .)
    BACKTICK        reduce using rule 52 (FEXP -> FEXP AEXP .)
    PLUS            reduce using rule 52 (FEXP -> FEXP AEXP .)
    MINUS           reduce using rule 52 (FEXP -> FEXP AEXP .)
    TIMES           reduce using rule 52 (FEXP -> FEXP AEXP .)
    DIVIDE          reduce using rule 52 (FEXP -> FEXP AEXP .)
    MODULO          reduce using rule 52 (FEXP -> FEXP AEXP .)
    POW             reduce using rule 52 (FEXP -> FEXP AEXP .)
    EQUALITY        reduce using rule 52 (FEXP -> FEXP AEXP .)
    INEQUALITY      reduce using rule 52 (FEXP -> FEXP AEXP .)
    LESS            reduce using rule 52 (FEXP -> FEXP AEXP .)
    LEQ             reduce using rule 52 (FEXP -> FEXP AEXP .)
    GREATER         reduce using rule 52 (FEXP -> FEXP AEXP .)
    GEQ             reduce using rule 52 (FEXP -> FEXP AEXP .)
    AND             reduce using rule 52 (FEXP -> FEXP AEXP .)
    OR              reduce using rule 52 (FEXP -> FEXP AEXP .)
    LIST_CONSTRUCTOR reduce using rule 52 (FEXP -> FEXP AEXP .)
    WHERE           reduce using rule 52 (FEXP -> FEXP AEXP .)
    CLOSE_BRACE     reduce using rule 52 (FEXP -> FEXP AEXP .)
    ENDSTATEMENT    reduce using rule 52 (FEXP -> FEXP AEXP .)
    EQUALS          reduce using rule 52 (FEXP -> FEXP AEXP .)
    THEN            reduce using rule 52 (FEXP -> FEXP AEXP .)
    OF              reduce using rule 52 (FEXP -> FEXP AEXP .)
    CLOSE_PAREN     reduce using rule 52 (FEXP -> FEXP AEXP .)
    PIPE            reduce using rule 52 (FEXP -> FEXP AEXP .)
    ELSE            reduce using rule 52 (FEXP -> FEXP AEXP .)


state 129

    (57) AEXP -> OPEN_PAREN EXP . CLOSE_PAREN

    CLOSE_PAREN     shift and go to state 150


state 130

    (40) RHS -> GDRHS WHERE DECLARATIONS .

    CLOSE_BRACE     reduce using rule 40 (RHS -> GDRHS WHERE DECLARATIONS .)
    ENDSTATEMENT    reduce using rule 40 (RHS -> GDRHS WHERE DECLARATIONS .)


state 131

    (41) GDRHS -> PIPE EXP EQUALS . EXP
    (42) GDRHS -> PIPE EXP EQUALS . EXP GDRHS
    (43) EXP -> . INFIX_EXP
    (44) INFIX_EXP -> . LEXP OP INFIX_EXP
    (45) INFIX_EXP -> . MINUS INFIX_EXP
    (46) INFIX_EXP -> . LEXP
    (47) LEXP -> . LAMBDA APAT APATS ARROW EXP
    (48) LEXP -> . LET DECLARATIONS IN EXP
    (49) LEXP -> . IF EXP THEN EXP ELSE EXP
    (50) LEXP -> . MATCH EXP OF OPEN_BRACE ALTS CLOSE_BRACE
    (51) LEXP -> . FEXP
    (52) FEXP -> . FEXP AEXP
    (53) FEXP -> . AEXP
    (54) AEXP -> . USED_VAR
    (55) AEXP -> . TYPENAME
    (56) AEXP -> . LITERAL
    (57) AEXP -> . OPEN_PAREN EXP CLOSE_PAREN
    (97) USED_VAR -> . IDENTIFIER
    (92) LITERAL -> . FLOAT
    (93) LITERAL -> . INTEGER
    (94) LITERAL -> . BOOL
    (95) LITERAL -> . CHAR
    (96) LITERAL -> . STRING

    MINUS           shift and go to state 90
    LAMBDA          shift and go to state 91
    LET             shift and go to state 92
    IF              shift and go to state 93
    MATCH           shift and go to state 94
    TYPENAME        shift and go to state 98
    OPEN_PAREN      shift and go to state 100
    IDENTIFIER      shift and go to state 101
    FLOAT           shift and go to state 25
    INTEGER         shift and go to state 21
    BOOL            shift and go to state 28
    CHAR            shift and go to state 29
    STRING          shift and go to state 30

    EXP                            shift and go to state 151
    INFIX_EXP                      shift and go to state 88
    LEXP                           shift and go to state 89
    FEXP                           shift and go to state 95
    AEXP                           shift and go to state 96
    USED_VAR                       shift and go to state 97
    LITERAL                        shift and go to state 99

state 132

    (73) VAROP -> BACKTICK IDENTIFIER BACKTICK .

    MINUS           reduce using rule 73 (VAROP -> BACKTICK IDENTIFIER BACKTICK .)
    TYPENAME        reduce using rule 73 (VAROP -> BACKTICK IDENTIFIER BACKTICK .)
    OPEN_PAREN      reduce using rule 73 (VAROP -> BACKTICK IDENTIFIER BACKTICK .)
    IDENTIFIER      reduce using rule 73 (VAROP -> BACKTICK IDENTIFIER BACKTICK .)
    FLOAT           reduce using rule 73 (VAROP -> BACKTICK IDENTIFIER BACKTICK .)
    INTEGER         reduce using rule 73 (VAROP -> BACKTICK IDENTIFIER BACKTICK .)
    BOOL            reduce using rule 73 (VAROP -> BACKTICK IDENTIFIER BACKTICK .)
    CHAR            reduce using rule 73 (VAROP -> BACKTICK IDENTIFIER BACKTICK .)
    STRING          reduce using rule 73 (VAROP -> BACKTICK IDENTIFIER BACKTICK .)
    LAMBDA          reduce using rule 73 (VAROP -> BACKTICK IDENTIFIER BACKTICK .)
    LET             reduce using rule 73 (VAROP -> BACKTICK IDENTIFIER BACKTICK .)
    IF              reduce using rule 73 (VAROP -> BACKTICK IDENTIFIER BACKTICK .)
    MATCH           reduce using rule 73 (VAROP -> BACKTICK IDENTIFIER BACKTICK .)
    CLOSE_BRACE     reduce using rule 73 (VAROP -> BACKTICK IDENTIFIER BACKTICK .)
    ENDSTATEMENT    reduce using rule 73 (VAROP -> BACKTICK IDENTIFIER BACKTICK .)


state 133

    (23) GEN_DECLARATION -> SETFIX ASSOCIATIVITY INTEGER OP .

    CLOSE_BRACE     reduce using rule 23 (GEN_DECLARATION -> SETFIX ASSOCIATIVITY INTEGER OP .)
    ENDSTATEMENT    reduce using rule 23 (GEN_DECLARATION -> SETFIX ASSOCIATIVITY INTEGER OP .)


state 134

    (36) FUNCTION_LHS -> OPEN_PAREN FUNCTION_LHS CLOSE_PAREN APAT . APATS
    (75) APATS -> . APAT APATS
    (76) APATS -> .
    (68) APAT -> . PARAM
    (69) APAT -> . TYPENAME
    (70) APAT -> . LITERAL
    (71) APAT -> . OPEN_PAREN LPAT CLOSE_PAREN
    (98) PARAM -> . IDENTIFIER
    (92) LITERAL -> . FLOAT
    (93) LITERAL -> . INTEGER
    (94) LITERAL -> . BOOL
    (95) LITERAL -> . CHAR
    (96) LITERAL -> . STRING

    EQUALS          reduce using rule 76 (APATS -> .)
    PIPE            reduce using rule 76 (APATS -> .)
    CLOSE_PAREN     reduce using rule 76 (APATS -> .)
    TYPENAME        shift and go to state 38
    OPEN_PAREN      shift and go to state 39
    IDENTIFIER      shift and go to state 35
    FLOAT           shift and go to state 25
    INTEGER         shift and go to state 21
    BOOL            shift and go to state 28
    CHAR            shift and go to state 29
    STRING          shift and go to state 30

    APAT                           shift and go to state 81
    APATS                          shift and go to state 152
    PARAM                          shift and go to state 26
    LITERAL                        shift and go to state 27

state 135

    (65) LPAT -> MINUS OPEN_PAREN INTEGER CLOSE_PAREN .

    EQUALS          reduce using rule 65 (LPAT -> MINUS OPEN_PAREN INTEGER CLOSE_PAREN .)
    BACKTICK        reduce using rule 65 (LPAT -> MINUS OPEN_PAREN INTEGER CLOSE_PAREN .)
    PIPE            reduce using rule 65 (LPAT -> MINUS OPEN_PAREN INTEGER CLOSE_PAREN .)
    PLUS            reduce using rule 65 (LPAT -> MINUS OPEN_PAREN INTEGER CLOSE_PAREN .)
    MINUS           reduce using rule 65 (LPAT -> MINUS OPEN_PAREN INTEGER CLOSE_PAREN .)
    TIMES           reduce using rule 65 (LPAT -> MINUS OPEN_PAREN INTEGER CLOSE_PAREN .)
    DIVIDE          reduce using rule 65 (LPAT -> MINUS OPEN_PAREN INTEGER CLOSE_PAREN .)
    MODULO          reduce using rule 65 (LPAT -> MINUS OPEN_PAREN INTEGER CLOSE_PAREN .)
    POW             reduce using rule 65 (LPAT -> MINUS OPEN_PAREN INTEGER CLOSE_PAREN .)
    EQUALITY        reduce using rule 65 (LPAT -> MINUS OPEN_PAREN INTEGER CLOSE_PAREN .)
    INEQUALITY      reduce using rule 65 (LPAT -> MINUS OPEN_PAREN INTEGER CLOSE_PAREN .)
    LESS            reduce using rule 65 (LPAT -> MINUS OPEN_PAREN INTEGER CLOSE_PAREN .)
    LEQ             reduce using rule 65 (LPAT -> MINUS OPEN_PAREN INTEGER CLOSE_PAREN .)
    GREATER         reduce using rule 65 (LPAT -> MINUS OPEN_PAREN INTEGER CLOSE_PAREN .)
    GEQ             reduce using rule 65 (LPAT -> MINUS OPEN_PAREN INTEGER CLOSE_PAREN .)
    AND             reduce using rule 65 (LPAT -> MINUS OPEN_PAREN INTEGER CLOSE_PAREN .)
    OR              reduce using rule 65 (LPAT -> MINUS OPEN_PAREN INTEGER CLOSE_PAREN .)
    LIST_CONSTRUCTOR reduce using rule 65 (LPAT -> MINUS OPEN_PAREN INTEGER CLOSE_PAREN .)
    CLOSE_PAREN     reduce using rule 65 (LPAT -> MINUS OPEN_PAREN INTEGER CLOSE_PAREN .)
    ARROW           reduce using rule 65 (LPAT -> MINUS OPEN_PAREN INTEGER CLOSE_PAREN .)


state 136

    (66) LPAT -> MINUS OPEN_PAREN FLOAT CLOSE_PAREN .

    EQUALS          reduce using rule 66 (LPAT -> MINUS OPEN_PAREN FLOAT CLOSE_PAREN .)
    BACKTICK        reduce using rule 66 (LPAT -> MINUS OPEN_PAREN FLOAT CLOSE_PAREN .)
    PIPE            reduce using rule 66 (LPAT -> MINUS OPEN_PAREN FLOAT CLOSE_PAREN .)
    PLUS            reduce using rule 66 (LPAT -> MINUS OPEN_PAREN FLOAT CLOSE_PAREN .)
    MINUS           reduce using rule 66 (LPAT -> MINUS OPEN_PAREN FLOAT CLOSE_PAREN .)
    TIMES           reduce using rule 66 (LPAT -> MINUS OPEN_PAREN FLOAT CLOSE_PAREN .)
    DIVIDE          reduce using rule 66 (LPAT -> MINUS OPEN_PAREN FLOAT CLOSE_PAREN .)
    MODULO          reduce using rule 66 (LPAT -> MINUS OPEN_PAREN FLOAT CLOSE_PAREN .)
    POW             reduce using rule 66 (LPAT -> MINUS OPEN_PAREN FLOAT CLOSE_PAREN .)
    EQUALITY        reduce using rule 66 (LPAT -> MINUS OPEN_PAREN FLOAT CLOSE_PAREN .)
    INEQUALITY      reduce using rule 66 (LPAT -> MINUS OPEN_PAREN FLOAT CLOSE_PAREN .)
    LESS            reduce using rule 66 (LPAT -> MINUS OPEN_PAREN FLOAT CLOSE_PAREN .)
    LEQ             reduce using rule 66 (LPAT -> MINUS OPEN_PAREN FLOAT CLOSE_PAREN .)
    GREATER         reduce using rule 66 (LPAT -> MINUS OPEN_PAREN FLOAT CLOSE_PAREN .)
    GEQ             reduce using rule 66 (LPAT -> MINUS OPEN_PAREN FLOAT CLOSE_PAREN .)
    AND             reduce using rule 66 (LPAT -> MINUS OPEN_PAREN FLOAT CLOSE_PAREN .)
    OR              reduce using rule 66 (LPAT -> MINUS OPEN_PAREN FLOAT CLOSE_PAREN .)
    LIST_CONSTRUCTOR reduce using rule 66 (LPAT -> MINUS OPEN_PAREN FLOAT CLOSE_PAREN .)
    CLOSE_PAREN     reduce using rule 66 (LPAT -> MINUS OPEN_PAREN FLOAT CLOSE_PAREN .)
    ARROW           reduce using rule 66 (LPAT -> MINUS OPEN_PAREN FLOAT CLOSE_PAREN .)


state 137

    (29) TYPE -> ATYPE ARROW TYPE .

    CLOSE_BRACE     reduce using rule 29 (TYPE -> ATYPE ARROW TYPE .)
    ENDSTATEMENT    reduce using rule 29 (TYPE -> ATYPE ARROW TYPE .)
    CLOSE_PAREN     reduce using rule 29 (TYPE -> ATYPE ARROW TYPE .)


state 138

    (33) ATYPE -> OPEN_PAREN TYPE CLOSE_PAREN .

    ARROW           reduce using rule 33 (ATYPE -> OPEN_PAREN TYPE CLOSE_PAREN .)
    CLOSE_BRACE     reduce using rule 33 (ATYPE -> OPEN_PAREN TYPE CLOSE_PAREN .)
    ENDSTATEMENT    reduce using rule 33 (ATYPE -> OPEN_PAREN TYPE CLOSE_PAREN .)
    CLOSE_PAREN     reduce using rule 33 (ATYPE -> OPEN_PAREN TYPE CLOSE_PAREN .)
    TYPENAME        reduce using rule 33 (ATYPE -> OPEN_PAREN TYPE CLOSE_PAREN .)
    OPEN_PAREN      reduce using rule 33 (ATYPE -> OPEN_PAREN TYPE CLOSE_PAREN .)
    PIPE            reduce using rule 33 (ATYPE -> OPEN_PAREN TYPE CLOSE_PAREN .)


state 139

    (14) CONSTRUCTOR -> TYPENAME ATYPES .
    (30) ATYPES -> ATYPES . ATYPE
    (32) ATYPE -> . TYPENAME
    (33) ATYPE -> . OPEN_PAREN TYPE CLOSE_PAREN

    PIPE            reduce using rule 14 (CONSTRUCTOR -> TYPENAME ATYPES .)
    CLOSE_BRACE     reduce using rule 14 (CONSTRUCTOR -> TYPENAME ATYPES .)
    ENDSTATEMENT    reduce using rule 14 (CONSTRUCTOR -> TYPENAME ATYPES .)
    TYPENAME        shift and go to state 79
    OPEN_PAREN      shift and go to state 80

    ATYPE                          shift and go to state 153

state 140

    (12) CONSTRUCTORS -> CONSTRUCTORS PIPE . CONSTRUCTOR
    (14) CONSTRUCTOR -> . TYPENAME ATYPES

    TYPENAME        shift and go to state 116

    CONSTRUCTOR                    shift and go to state 154

state 141

    (38) RHS -> EQUALS EXP WHERE DECLARATIONS .

    CLOSE_BRACE     reduce using rule 38 (RHS -> EQUALS EXP WHERE DECLARATIONS .)
    ENDSTATEMENT    reduce using rule 38 (RHS -> EQUALS EXP WHERE DECLARATIONS .)


state 142

    (44) INFIX_EXP -> LEXP OP INFIX_EXP .

    WHERE           reduce using rule 44 (INFIX_EXP -> LEXP OP INFIX_EXP .)
    CLOSE_BRACE     reduce using rule 44 (INFIX_EXP -> LEXP OP INFIX_EXP .)
    ENDSTATEMENT    reduce using rule 44 (INFIX_EXP -> LEXP OP INFIX_EXP .)
    EQUALS          reduce using rule 44 (INFIX_EXP -> LEXP OP INFIX_EXP .)
    THEN            reduce using rule 44 (INFIX_EXP -> LEXP OP INFIX_EXP .)
    OF              reduce using rule 44 (INFIX_EXP -> LEXP OP INFIX_EXP .)
    CLOSE_PAREN     reduce using rule 44 (INFIX_EXP -> LEXP OP INFIX_EXP .)
    PIPE            reduce using rule 44 (INFIX_EXP -> LEXP OP INFIX_EXP .)
    BACKTICK        reduce using rule 44 (INFIX_EXP -> LEXP OP INFIX_EXP .)
    PLUS            reduce using rule 44 (INFIX_EXP -> LEXP OP INFIX_EXP .)
    MINUS           reduce using rule 44 (INFIX_EXP -> LEXP OP INFIX_EXP .)
    TIMES           reduce using rule 44 (INFIX_EXP -> LEXP OP INFIX_EXP .)
    DIVIDE          reduce using rule 44 (INFIX_EXP -> LEXP OP INFIX_EXP .)
    MODULO          reduce using rule 44 (INFIX_EXP -> LEXP OP INFIX_EXP .)
    POW             reduce using rule 44 (INFIX_EXP -> LEXP OP INFIX_EXP .)
    EQUALITY        reduce using rule 44 (INFIX_EXP -> LEXP OP INFIX_EXP .)
    INEQUALITY      reduce using rule 44 (INFIX_EXP -> LEXP OP INFIX_EXP .)
    LESS            reduce using rule 44 (INFIX_EXP -> LEXP OP INFIX_EXP .)
    LEQ             reduce using rule 44 (INFIX_EXP -> LEXP OP INFIX_EXP .)
    GREATER         reduce using rule 44 (INFIX_EXP -> LEXP OP INFIX_EXP .)
    GEQ             reduce using rule 44 (INFIX_EXP -> LEXP OP INFIX_EXP .)
    AND             reduce using rule 44 (INFIX_EXP -> LEXP OP INFIX_EXP .)
    OR              reduce using rule 44 (INFIX_EXP -> LEXP OP INFIX_EXP .)
    LIST_CONSTRUCTOR reduce using rule 44 (INFIX_EXP -> LEXP OP INFIX_EXP .)
    ELSE            reduce using rule 44 (INFIX_EXP -> LEXP OP INFIX_EXP .)


state 143

    (47) LEXP -> LAMBDA APAT APATS . ARROW EXP

    ARROW           shift and go to state 155


state 144

    (48) LEXP -> LET DECLARATIONS IN . EXP
    (43) EXP -> . INFIX_EXP
    (44) INFIX_EXP -> . LEXP OP INFIX_EXP
    (45) INFIX_EXP -> . MINUS INFIX_EXP
    (46) INFIX_EXP -> . LEXP
    (47) LEXP -> . LAMBDA APAT APATS ARROW EXP
    (48) LEXP -> . LET DECLARATIONS IN EXP
    (49) LEXP -> . IF EXP THEN EXP ELSE EXP
    (50) LEXP -> . MATCH EXP OF OPEN_BRACE ALTS CLOSE_BRACE
    (51) LEXP -> . FEXP
    (52) FEXP -> . FEXP AEXP
    (53) FEXP -> . AEXP
    (54) AEXP -> . USED_VAR
    (55) AEXP -> . TYPENAME
    (56) AEXP -> . LITERAL
    (57) AEXP -> . OPEN_PAREN EXP CLOSE_PAREN
    (97) USED_VAR -> . IDENTIFIER
    (92) LITERAL -> . FLOAT
    (93) LITERAL -> . INTEGER
    (94) LITERAL -> . BOOL
    (95) LITERAL -> . CHAR
    (96) LITERAL -> . STRING

    MINUS           shift and go to state 90
    LAMBDA          shift and go to state 91
    LET             shift and go to state 92
    IF              shift and go to state 93
    MATCH           shift and go to state 94
    TYPENAME        shift and go to state 98
    OPEN_PAREN      shift and go to state 100
    IDENTIFIER      shift and go to state 101
    FLOAT           shift and go to state 25
    INTEGER         shift and go to state 21
    BOOL            shift and go to state 28
    CHAR            shift and go to state 29
    STRING          shift and go to state 30

    EXP                            shift and go to state 156
    INFIX_EXP                      shift and go to state 88
    LEXP                           shift and go to state 89
    FEXP                           shift and go to state 95
    AEXP                           shift and go to state 96
    USED_VAR                       shift and go to state 97
    LITERAL                        shift and go to state 99

state 145

    (15) DECLARATIONS -> OPEN_BRACE DECLARATIONS_LIST . CLOSE_BRACE

    CLOSE_BRACE     shift and go to state 157


state 146

    (16) DECLARATIONS -> OPEN_BRACE CLOSE_BRACE .

    IN              reduce using rule 16 (DECLARATIONS -> OPEN_BRACE CLOSE_BRACE .)
    CLOSE_BRACE     reduce using rule 16 (DECLARATIONS -> OPEN_BRACE CLOSE_BRACE .)
    ENDSTATEMENT    reduce using rule 16 (DECLARATIONS -> OPEN_BRACE CLOSE_BRACE .)


state 147

    (17) DECLARATIONS_LIST -> DECLARATION . ENDSTATEMENT DECLARATIONS_LIST
    (18) DECLARATIONS_LIST -> DECLARATION .

    ENDSTATEMENT    shift and go to state 158
    CLOSE_BRACE     reduce using rule 18 (DECLARATIONS_LIST -> DECLARATION .)


state 148

    (49) LEXP -> IF EXP THEN . EXP ELSE EXP
    (43) EXP -> . INFIX_EXP
    (44) INFIX_EXP -> . LEXP OP INFIX_EXP
    (45) INFIX_EXP -> . MINUS INFIX_EXP
    (46) INFIX_EXP -> . LEXP
    (47) LEXP -> . LAMBDA APAT APATS ARROW EXP
    (48) LEXP -> . LET DECLARATIONS IN EXP
    (49) LEXP -> . IF EXP THEN EXP ELSE EXP
    (50) LEXP -> . MATCH EXP OF OPEN_BRACE ALTS CLOSE_BRACE
    (51) LEXP -> . FEXP
    (52) FEXP -> . FEXP AEXP
    (53) FEXP -> . AEXP
    (54) AEXP -> . USED_VAR
    (55) AEXP -> . TYPENAME
    (56) AEXP -> . LITERAL
    (57) AEXP -> . OPEN_PAREN EXP CLOSE_PAREN
    (97) USED_VAR -> . IDENTIFIER
    (92) LITERAL -> . FLOAT
    (93) LITERAL -> . INTEGER
    (94) LITERAL -> . BOOL
    (95) LITERAL -> . CHAR
    (96) LITERAL -> . STRING

    MINUS           shift and go to state 90
    LAMBDA          shift and go to state 91
    LET             shift and go to state 92
    IF              shift and go to state 93
    MATCH           shift and go to state 94
    TYPENAME        shift and go to state 98
    OPEN_PAREN      shift and go to state 100
    IDENTIFIER      shift and go to state 101
    FLOAT           shift and go to state 25
    INTEGER         shift and go to state 21
    BOOL            shift and go to state 28
    CHAR            shift and go to state 29
    STRING          shift and go to state 30

    EXP                            shift and go to state 159
    INFIX_EXP                      shift and go to state 88
    LEXP                           shift and go to state 89
    FEXP                           shift and go to state 95
    AEXP                           shift and go to state 96
    USED_VAR                       shift and go to state 97
    LITERAL                        shift and go to state 99

state 149

    (50) LEXP -> MATCH EXP OF . OPEN_BRACE ALTS CLOSE_BRACE

    OPEN_BRACE      shift and go to state 160


state 150

    (57) AEXP -> OPEN_PAREN EXP CLOSE_PAREN .

    TYPENAME        reduce using rule 57 (AEXP -> OPEN_PAREN EXP CLOSE_PAREN .)
    OPEN_PAREN      reduce using rule 57 (AEXP -> OPEN_PAREN EXP CLOSE_PAREN .)
    IDENTIFIER      reduce using rule 57 (AEXP -> OPEN_PAREN EXP CLOSE_PAREN .)
    FLOAT           reduce using rule 57 (AEXP -> OPEN_PAREN EXP CLOSE_PAREN .)
    INTEGER         reduce using rule 57 (AEXP -> OPEN_PAREN EXP CLOSE_PAREN .)
    BOOL            reduce using rule 57 (AEXP -> OPEN_PAREN EXP CLOSE_PAREN .)
    CHAR            reduce using rule 57 (AEXP -> OPEN_PAREN EXP CLOSE_PAREN .)
    STRING          reduce using rule 57 (AEXP -> OPEN_PAREN EXP CLOSE_PAREN .)
    BACKTICK        reduce using rule 57 (AEXP -> OPEN_PAREN EXP CLOSE_PAREN .)
    PLUS            reduce using rule 57 (AEXP -> OPEN_PAREN EXP CLOSE_PAREN .)
    MINUS           reduce using rule 57 (AEXP -> OPEN_PAREN EXP CLOSE_PAREN .)
    TIMES           reduce using rule 57 (AEXP -> OPEN_PAREN EXP CLOSE_PAREN .)
    DIVIDE          reduce using rule 57 (AEXP -> OPEN_PAREN EXP CLOSE_PAREN .)
    MODULO          reduce using rule 57 (AEXP -> OPEN_PAREN EXP CLOSE_PAREN .)
    POW             reduce using rule 57 (AEXP -> OPEN_PAREN EXP CLOSE_PAREN .)
    EQUALITY        reduce using rule 57 (AEXP -> OPEN_PAREN EXP CLOSE_PAREN .)
    INEQUALITY      reduce using rule 57 (AEXP -> OPEN_PAREN EXP CLOSE_PAREN .)
    LESS            reduce using rule 57 (AEXP -> OPEN_PAREN EXP CLOSE_PAREN .)
    LEQ             reduce using rule 57 (AEXP -> OPEN_PAREN EXP CLOSE_PAREN .)
    GREATER         reduce using rule 57 (AEXP -> OPEN_PAREN EXP CLOSE_PAREN .)
    GEQ             reduce using rule 57 (AEXP -> OPEN_PAREN EXP CLOSE_PAREN .)
    AND             reduce using rule 57 (AEXP -> OPEN_PAREN EXP CLOSE_PAREN .)
    OR              reduce using rule 57 (AEXP -> OPEN_PAREN EXP CLOSE_PAREN .)
    LIST_CONSTRUCTOR reduce using rule 57 (AEXP -> OPEN_PAREN EXP CLOSE_PAREN .)
    WHERE           reduce using rule 57 (AEXP -> OPEN_PAREN EXP CLOSE_PAREN .)
    CLOSE_BRACE     reduce using rule 57 (AEXP -> OPEN_PAREN EXP CLOSE_PAREN .)
    ENDSTATEMENT    reduce using rule 57 (AEXP -> OPEN_PAREN EXP CLOSE_PAREN .)
    EQUALS          reduce using rule 57 (AEXP -> OPEN_PAREN EXP CLOSE_PAREN .)
    THEN            reduce using rule 57 (AEXP -> OPEN_PAREN EXP CLOSE_PAREN .)
    OF              reduce using rule 57 (AEXP -> OPEN_PAREN EXP CLOSE_PAREN .)
    CLOSE_PAREN     reduce using rule 57 (AEXP -> OPEN_PAREN EXP CLOSE_PAREN .)
    PIPE            reduce using rule 57 (AEXP -> OPEN_PAREN EXP CLOSE_PAREN .)
    ELSE            reduce using rule 57 (AEXP -> OPEN_PAREN EXP CLOSE_PAREN .)


state 151

    (41) GDRHS -> PIPE EXP EQUALS EXP .
    (42) GDRHS -> PIPE EXP EQUALS EXP . GDRHS
    (41) GDRHS -> . PIPE EXP EQUALS EXP
    (42) GDRHS -> . PIPE EXP EQUALS EXP GDRHS

    WHERE           reduce using rule 41 (GDRHS -> PIPE EXP EQUALS EXP .)
    CLOSE_BRACE     reduce using rule 41 (GDRHS -> PIPE EXP EQUALS EXP .)
    ENDSTATEMENT    reduce using rule 41 (GDRHS -> PIPE EXP EQUALS EXP .)
    PIPE            shift and go to state 46

    GDRHS                          shift and go to state 161

state 152

    (36) FUNCTION_LHS -> OPEN_PAREN FUNCTION_LHS CLOSE_PAREN APAT APATS .

    EQUALS          reduce using rule 36 (FUNCTION_LHS -> OPEN_PAREN FUNCTION_LHS CLOSE_PAREN APAT APATS .)
    PIPE            reduce using rule 36 (FUNCTION_LHS -> OPEN_PAREN FUNCTION_LHS CLOSE_PAREN APAT APATS .)
    CLOSE_PAREN     reduce using rule 36 (FUNCTION_LHS -> OPEN_PAREN FUNCTION_LHS CLOSE_PAREN APAT APATS .)


state 153

    (30) ATYPES -> ATYPES ATYPE .

    TYPENAME        reduce using rule 30 (ATYPES -> ATYPES ATYPE .)
    OPEN_PAREN      reduce using rule 30 (ATYPES -> ATYPES ATYPE .)
    PIPE            reduce using rule 30 (ATYPES -> ATYPES ATYPE .)
    CLOSE_BRACE     reduce using rule 30 (ATYPES -> ATYPES ATYPE .)
    ENDSTATEMENT    reduce using rule 30 (ATYPES -> ATYPES ATYPE .)


state 154

    (12) CONSTRUCTORS -> CONSTRUCTORS PIPE CONSTRUCTOR .

    PIPE            reduce using rule 12 (CONSTRUCTORS -> CONSTRUCTORS PIPE CONSTRUCTOR .)
    CLOSE_BRACE     reduce using rule 12 (CONSTRUCTORS -> CONSTRUCTORS PIPE CONSTRUCTOR .)
    ENDSTATEMENT    reduce using rule 12 (CONSTRUCTORS -> CONSTRUCTORS PIPE CONSTRUCTOR .)


state 155

    (47) LEXP -> LAMBDA APAT APATS ARROW . EXP
    (43) EXP -> . INFIX_EXP
    (44) INFIX_EXP -> . LEXP OP INFIX_EXP
    (45) INFIX_EXP -> . MINUS INFIX_EXP
    (46) INFIX_EXP -> . LEXP
    (47) LEXP -> . LAMBDA APAT APATS ARROW EXP
    (48) LEXP -> . LET DECLARATIONS IN EXP
    (49) LEXP -> . IF EXP THEN EXP ELSE EXP
    (50) LEXP -> . MATCH EXP OF OPEN_BRACE ALTS CLOSE_BRACE
    (51) LEXP -> . FEXP
    (52) FEXP -> . FEXP AEXP
    (53) FEXP -> . AEXP
    (54) AEXP -> . USED_VAR
    (55) AEXP -> . TYPENAME
    (56) AEXP -> . LITERAL
    (57) AEXP -> . OPEN_PAREN EXP CLOSE_PAREN
    (97) USED_VAR -> . IDENTIFIER
    (92) LITERAL -> . FLOAT
    (93) LITERAL -> . INTEGER
    (94) LITERAL -> . BOOL
    (95) LITERAL -> . CHAR
    (96) LITERAL -> . STRING

    MINUS           shift and go to state 90
    LAMBDA          shift and go to state 91
    LET             shift and go to state 92
    IF              shift and go to state 93
    MATCH           shift and go to state 94
    TYPENAME        shift and go to state 98
    OPEN_PAREN      shift and go to state 100
    IDENTIFIER      shift and go to state 101
    FLOAT           shift and go to state 25
    INTEGER         shift and go to state 21
    BOOL            shift and go to state 28
    CHAR            shift and go to state 29
    STRING          shift and go to state 30

    EXP                            shift and go to state 162
    INFIX_EXP                      shift and go to state 88
    LEXP                           shift and go to state 89
    FEXP                           shift and go to state 95
    AEXP                           shift and go to state 96
    USED_VAR                       shift and go to state 97
    LITERAL                        shift and go to state 99

state 156

    (48) LEXP -> LET DECLARATIONS IN EXP .

    BACKTICK        reduce using rule 48 (LEXP -> LET DECLARATIONS IN EXP .)
    PLUS            reduce using rule 48 (LEXP -> LET DECLARATIONS IN EXP .)
    MINUS           reduce using rule 48 (LEXP -> LET DECLARATIONS IN EXP .)
    TIMES           reduce using rule 48 (LEXP -> LET DECLARATIONS IN EXP .)
    DIVIDE          reduce using rule 48 (LEXP -> LET DECLARATIONS IN EXP .)
    MODULO          reduce using rule 48 (LEXP -> LET DECLARATIONS IN EXP .)
    POW             reduce using rule 48 (LEXP -> LET DECLARATIONS IN EXP .)
    EQUALITY        reduce using rule 48 (LEXP -> LET DECLARATIONS IN EXP .)
    INEQUALITY      reduce using rule 48 (LEXP -> LET DECLARATIONS IN EXP .)
    LESS            reduce using rule 48 (LEXP -> LET DECLARATIONS IN EXP .)
    LEQ             reduce using rule 48 (LEXP -> LET DECLARATIONS IN EXP .)
    GREATER         reduce using rule 48 (LEXP -> LET DECLARATIONS IN EXP .)
    GEQ             reduce using rule 48 (LEXP -> LET DECLARATIONS IN EXP .)
    AND             reduce using rule 48 (LEXP -> LET DECLARATIONS IN EXP .)
    OR              reduce using rule 48 (LEXP -> LET DECLARATIONS IN EXP .)
    LIST_CONSTRUCTOR reduce using rule 48 (LEXP -> LET DECLARATIONS IN EXP .)
    WHERE           reduce using rule 48 (LEXP -> LET DECLARATIONS IN EXP .)
    CLOSE_BRACE     reduce using rule 48 (LEXP -> LET DECLARATIONS IN EXP .)
    ENDSTATEMENT    reduce using rule 48 (LEXP -> LET DECLARATIONS IN EXP .)
    EQUALS          reduce using rule 48 (LEXP -> LET DECLARATIONS IN EXP .)
    THEN            reduce using rule 48 (LEXP -> LET DECLARATIONS IN EXP .)
    OF              reduce using rule 48 (LEXP -> LET DECLARATIONS IN EXP .)
    CLOSE_PAREN     reduce using rule 48 (LEXP -> LET DECLARATIONS IN EXP .)
    PIPE            reduce using rule 48 (LEXP -> LET DECLARATIONS IN EXP .)
    ELSE            reduce using rule 48 (LEXP -> LET DECLARATIONS IN EXP .)


state 157

    (15) DECLARATIONS -> OPEN_BRACE DECLARATIONS_LIST CLOSE_BRACE .

    IN              reduce using rule 15 (DECLARATIONS -> OPEN_BRACE DECLARATIONS_LIST CLOSE_BRACE .)
    CLOSE_BRACE     reduce using rule 15 (DECLARATIONS -> OPEN_BRACE DECLARATIONS_LIST CLOSE_BRACE .)
    ENDSTATEMENT    reduce using rule 15 (DECLARATIONS -> OPEN_BRACE DECLARATIONS_LIST CLOSE_BRACE .)


state 158

    (17) DECLARATIONS_LIST -> DECLARATION ENDSTATEMENT . DECLARATIONS_LIST
    (17) DECLARATIONS_LIST -> . DECLARATION ENDSTATEMENT DECLARATIONS_LIST
    (18) DECLARATIONS_LIST -> . DECLARATION
    (19) DECLARATION -> . GEN_DECLARATION
    (20) DECLARATION -> . FUNCTION_LHS RHS
    (21) DECLARATION -> . LPAT RHS
    (22) GEN_DECLARATION -> . IDENTIFIER TYPESIG TYPE
    (23) GEN_DECLARATION -> . SETFIX ASSOCIATIVITY INTEGER OP
    (24) GEN_DECLARATION -> .
    (34) FUNCTION_LHS -> . IDENTIFIER APAT APATS
    (35) FUNCTION_LHS -> . LPAT VAROP LPAT
    (36) FUNCTION_LHS -> . OPEN_PAREN FUNCTION_LHS CLOSE_PAREN APAT APATS
    (64) LPAT -> . APAT
    (65) LPAT -> . MINUS OPEN_PAREN INTEGER CLOSE_PAREN
    (66) LPAT -> . MINUS OPEN_PAREN FLOAT CLOSE_PAREN
    (67) LPAT -> . TYPENAME APAT APATS
    (68) APAT -> . PARAM
    (69) APAT -> . TYPENAME
    (70) APAT -> . LITERAL
    (71) APAT -> . OPEN_PAREN LPAT CLOSE_PAREN
    (98) PARAM -> . IDENTIFIER
    (92) LITERAL -> . FLOAT
    (93) LITERAL -> . INTEGER
    (94) LITERAL -> . BOOL
    (95) LITERAL -> . CHAR
    (96) LITERAL -> . STRING

    IDENTIFIER      shift and go to state 12
    SETFIX          shift and go to state 20
    ENDSTATEMENT    reduce using rule 24 (GEN_DECLARATION -> .)
    CLOSE_BRACE     reduce using rule 24 (GEN_DECLARATION -> .)
    OPEN_PAREN      shift and go to state 23
    MINUS           shift and go to state 24
    TYPENAME        shift and go to state 14
    FLOAT           shift and go to state 25
    INTEGER         shift and go to state 21
    BOOL            shift and go to state 28
    CHAR            shift and go to state 29
    STRING          shift and go to state 30

    DECLARATION                    shift and go to state 147
    DECLARATIONS_LIST              shift and go to state 163
    GEN_DECLARATION                shift and go to state 17
    FUNCTION_LHS                   shift and go to state 18
    LPAT                           shift and go to state 19
    APAT                           shift and go to state 22
    PARAM                          shift and go to state 26
    LITERAL                        shift and go to state 27

state 159

    (49) LEXP -> IF EXP THEN EXP . ELSE EXP

    ELSE            shift and go to state 164


state 160

    (50) LEXP -> MATCH EXP OF OPEN_BRACE . ALTS CLOSE_BRACE
    (60) ALTS -> . ALT ENDSTATEMENT ALTS
    (61) ALTS -> . ALT
    (62) ALT -> . LPAT ARROW EXP
    (63) ALT -> .
    (64) LPAT -> . APAT
    (65) LPAT -> . MINUS OPEN_PAREN INTEGER CLOSE_PAREN
    (66) LPAT -> . MINUS OPEN_PAREN FLOAT CLOSE_PAREN
    (67) LPAT -> . TYPENAME APAT APATS
    (68) APAT -> . PARAM
    (69) APAT -> . TYPENAME
    (70) APAT -> . LITERAL
    (71) APAT -> . OPEN_PAREN LPAT CLOSE_PAREN
    (98) PARAM -> . IDENTIFIER
    (92) LITERAL -> . FLOAT
    (93) LITERAL -> . INTEGER
    (94) LITERAL -> . BOOL
    (95) LITERAL -> . CHAR
    (96) LITERAL -> . STRING

    ENDSTATEMENT    reduce using rule 63 (ALT -> .)
    CLOSE_BRACE     reduce using rule 63 (ALT -> .)
    MINUS           shift and go to state 24
    TYPENAME        shift and go to state 14
    OPEN_PAREN      shift and go to state 39
    IDENTIFIER      shift and go to state 35
    FLOAT           shift and go to state 25
    INTEGER         shift and go to state 21
    BOOL            shift and go to state 28
    CHAR            shift and go to state 29
    STRING          shift and go to state 30

    ALTS                           shift and go to state 165
    ALT                            shift and go to state 166
    LPAT                           shift and go to state 167
    APAT                           shift and go to state 22
    PARAM                          shift and go to state 26
    LITERAL                        shift and go to state 27

state 161

    (42) GDRHS -> PIPE EXP EQUALS EXP GDRHS .

    WHERE           reduce using rule 42 (GDRHS -> PIPE EXP EQUALS EXP GDRHS .)
    CLOSE_BRACE     reduce using rule 42 (GDRHS -> PIPE EXP EQUALS EXP GDRHS .)
    ENDSTATEMENT    reduce using rule 42 (GDRHS -> PIPE EXP EQUALS EXP GDRHS .)


state 162

    (47) LEXP -> LAMBDA APAT APATS ARROW EXP .

    BACKTICK        reduce using rule 47 (LEXP -> LAMBDA APAT APATS ARROW EXP .)
    PLUS            reduce using rule 47 (LEXP -> LAMBDA APAT APATS ARROW EXP .)
    MINUS           reduce using rule 47 (LEXP -> LAMBDA APAT APATS ARROW EXP .)
    TIMES           reduce using rule 47 (LEXP -> LAMBDA APAT APATS ARROW EXP .)
    DIVIDE          reduce using rule 47 (LEXP -> LAMBDA APAT APATS ARROW EXP .)
    MODULO          reduce using rule 47 (LEXP -> LAMBDA APAT APATS ARROW EXP .)
    POW             reduce using rule 47 (LEXP -> LAMBDA APAT APATS ARROW EXP .)
    EQUALITY        reduce using rule 47 (LEXP -> LAMBDA APAT APATS ARROW EXP .)
    INEQUALITY      reduce using rule 47 (LEXP -> LAMBDA APAT APATS ARROW EXP .)
    LESS            reduce using rule 47 (LEXP -> LAMBDA APAT APATS ARROW EXP .)
    LEQ             reduce using rule 47 (LEXP -> LAMBDA APAT APATS ARROW EXP .)
    GREATER         reduce using rule 47 (LEXP -> LAMBDA APAT APATS ARROW EXP .)
    GEQ             reduce using rule 47 (LEXP -> LAMBDA APAT APATS ARROW EXP .)
    AND             reduce using rule 47 (LEXP -> LAMBDA APAT APATS ARROW EXP .)
    OR              reduce using rule 47 (LEXP -> LAMBDA APAT APATS ARROW EXP .)
    LIST_CONSTRUCTOR reduce using rule 47 (LEXP -> LAMBDA APAT APATS ARROW EXP .)
    WHERE           reduce using rule 47 (LEXP -> LAMBDA APAT APATS ARROW EXP .)
    CLOSE_BRACE     reduce using rule 47 (LEXP -> LAMBDA APAT APATS ARROW EXP .)
    ENDSTATEMENT    reduce using rule 47 (LEXP -> LAMBDA APAT APATS ARROW EXP .)
    EQUALS          reduce using rule 47 (LEXP -> LAMBDA APAT APATS ARROW EXP .)
    THEN            reduce using rule 47 (LEXP -> LAMBDA APAT APATS ARROW EXP .)
    OF              reduce using rule 47 (LEXP -> LAMBDA APAT APATS ARROW EXP .)
    CLOSE_PAREN     reduce using rule 47 (LEXP -> LAMBDA APAT APATS ARROW EXP .)
    PIPE            reduce using rule 47 (LEXP -> LAMBDA APAT APATS ARROW EXP .)
    ELSE            reduce using rule 47 (LEXP -> LAMBDA APAT APATS ARROW EXP .)


state 163

    (17) DECLARATIONS_LIST -> DECLARATION ENDSTATEMENT DECLARATIONS_LIST .

    CLOSE_BRACE     reduce using rule 17 (DECLARATIONS_LIST -> DECLARATION ENDSTATEMENT DECLARATIONS_LIST .)


state 164

    (49) LEXP -> IF EXP THEN EXP ELSE . EXP
    (43) EXP -> . INFIX_EXP
    (44) INFIX_EXP -> . LEXP OP INFIX_EXP
    (45) INFIX_EXP -> . MINUS INFIX_EXP
    (46) INFIX_EXP -> . LEXP
    (47) LEXP -> . LAMBDA APAT APATS ARROW EXP
    (48) LEXP -> . LET DECLARATIONS IN EXP
    (49) LEXP -> . IF EXP THEN EXP ELSE EXP
    (50) LEXP -> . MATCH EXP OF OPEN_BRACE ALTS CLOSE_BRACE
    (51) LEXP -> . FEXP
    (52) FEXP -> . FEXP AEXP
    (53) FEXP -> . AEXP
    (54) AEXP -> . USED_VAR
    (55) AEXP -> . TYPENAME
    (56) AEXP -> . LITERAL
    (57) AEXP -> . OPEN_PAREN EXP CLOSE_PAREN
    (97) USED_VAR -> . IDENTIFIER
    (92) LITERAL -> . FLOAT
    (93) LITERAL -> . INTEGER
    (94) LITERAL -> . BOOL
    (95) LITERAL -> . CHAR
    (96) LITERAL -> . STRING

    MINUS           shift and go to state 90
    LAMBDA          shift and go to state 91
    LET             shift and go to state 92
    IF              shift and go to state 93
    MATCH           shift and go to state 94
    TYPENAME        shift and go to state 98
    OPEN_PAREN      shift and go to state 100
    IDENTIFIER      shift and go to state 101
    FLOAT           shift and go to state 25
    INTEGER         shift and go to state 21
    BOOL            shift and go to state 28
    CHAR            shift and go to state 29
    STRING          shift and go to state 30

    EXP                            shift and go to state 168
    INFIX_EXP                      shift and go to state 88
    LEXP                           shift and go to state 89
    FEXP                           shift and go to state 95
    AEXP                           shift and go to state 96
    USED_VAR                       shift and go to state 97
    LITERAL                        shift and go to state 99

state 165

    (50) LEXP -> MATCH EXP OF OPEN_BRACE ALTS . CLOSE_BRACE

    CLOSE_BRACE     shift and go to state 169


state 166

    (60) ALTS -> ALT . ENDSTATEMENT ALTS
    (61) ALTS -> ALT .

    ENDSTATEMENT    shift and go to state 170
    CLOSE_BRACE     reduce using rule 61 (ALTS -> ALT .)


state 167

    (62) ALT -> LPAT . ARROW EXP

    ARROW           shift and go to state 171


state 168

    (49) LEXP -> IF EXP THEN EXP ELSE EXP .

    BACKTICK        reduce using rule 49 (LEXP -> IF EXP THEN EXP ELSE EXP .)
    PLUS            reduce using rule 49 (LEXP -> IF EXP THEN EXP ELSE EXP .)
    MINUS           reduce using rule 49 (LEXP -> IF EXP THEN EXP ELSE EXP .)
    TIMES           reduce using rule 49 (LEXP -> IF EXP THEN EXP ELSE EXP .)
    DIVIDE          reduce using rule 49 (LEXP -> IF EXP THEN EXP ELSE EXP .)
    MODULO          reduce using rule 49 (LEXP -> IF EXP THEN EXP ELSE EXP .)
    POW             reduce using rule 49 (LEXP -> IF EXP THEN EXP ELSE EXP .)
    EQUALITY        reduce using rule 49 (LEXP -> IF EXP THEN EXP ELSE EXP .)
    INEQUALITY      reduce using rule 49 (LEXP -> IF EXP THEN EXP ELSE EXP .)
    LESS            reduce using rule 49 (LEXP -> IF EXP THEN EXP ELSE EXP .)
    LEQ             reduce using rule 49 (LEXP -> IF EXP THEN EXP ELSE EXP .)
    GREATER         reduce using rule 49 (LEXP -> IF EXP THEN EXP ELSE EXP .)
    GEQ             reduce using rule 49 (LEXP -> IF EXP THEN EXP ELSE EXP .)
    AND             reduce using rule 49 (LEXP -> IF EXP THEN EXP ELSE EXP .)
    OR              reduce using rule 49 (LEXP -> IF EXP THEN EXP ELSE EXP .)
    LIST_CONSTRUCTOR reduce using rule 49 (LEXP -> IF EXP THEN EXP ELSE EXP .)
    WHERE           reduce using rule 49 (LEXP -> IF EXP THEN EXP ELSE EXP .)
    CLOSE_BRACE     reduce using rule 49 (LEXP -> IF EXP THEN EXP ELSE EXP .)
    ENDSTATEMENT    reduce using rule 49 (LEXP -> IF EXP THEN EXP ELSE EXP .)
    EQUALS          reduce using rule 49 (LEXP -> IF EXP THEN EXP ELSE EXP .)
    THEN            reduce using rule 49 (LEXP -> IF EXP THEN EXP ELSE EXP .)
    OF              reduce using rule 49 (LEXP -> IF EXP THEN EXP ELSE EXP .)
    CLOSE_PAREN     reduce using rule 49 (LEXP -> IF EXP THEN EXP ELSE EXP .)
    PIPE            reduce using rule 49 (LEXP -> IF EXP THEN EXP ELSE EXP .)
    ELSE            reduce using rule 49 (LEXP -> IF EXP THEN EXP ELSE EXP .)


state 169

    (50) LEXP -> MATCH EXP OF OPEN_BRACE ALTS CLOSE_BRACE .

    BACKTICK        reduce using rule 50 (LEXP -> MATCH EXP OF OPEN_BRACE ALTS CLOSE_BRACE .)
    PLUS            reduce using rule 50 (LEXP -> MATCH EXP OF OPEN_BRACE ALTS CLOSE_BRACE .)
    MINUS           reduce using rule 50 (LEXP -> MATCH EXP OF OPEN_BRACE ALTS CLOSE_BRACE .)
    TIMES           reduce using rule 50 (LEXP -> MATCH EXP OF OPEN_BRACE ALTS CLOSE_BRACE .)
    DIVIDE          reduce using rule 50 (LEXP -> MATCH EXP OF OPEN_BRACE ALTS CLOSE_BRACE .)
    MODULO          reduce using rule 50 (LEXP -> MATCH EXP OF OPEN_BRACE ALTS CLOSE_BRACE .)
    POW             reduce using rule 50 (LEXP -> MATCH EXP OF OPEN_BRACE ALTS CLOSE_BRACE .)
    EQUALITY        reduce using rule 50 (LEXP -> MATCH EXP OF OPEN_BRACE ALTS CLOSE_BRACE .)
    INEQUALITY      reduce using rule 50 (LEXP -> MATCH EXP OF OPEN_BRACE ALTS CLOSE_BRACE .)
    LESS            reduce using rule 50 (LEXP -> MATCH EXP OF OPEN_BRACE ALTS CLOSE_BRACE .)
    LEQ             reduce using rule 50 (LEXP -> MATCH EXP OF OPEN_BRACE ALTS CLOSE_BRACE .)
    GREATER         reduce using rule 50 (LEXP -> MATCH EXP OF OPEN_BRACE ALTS CLOSE_BRACE .)
    GEQ             reduce using rule 50 (LEXP -> MATCH EXP OF OPEN_BRACE ALTS CLOSE_BRACE .)
    AND             reduce using rule 50 (LEXP -> MATCH EXP OF OPEN_BRACE ALTS CLOSE_BRACE .)
    OR              reduce using rule 50 (LEXP -> MATCH EXP OF OPEN_BRACE ALTS CLOSE_BRACE .)
    LIST_CONSTRUCTOR reduce using rule 50 (LEXP -> MATCH EXP OF OPEN_BRACE ALTS CLOSE_BRACE .)
    WHERE           reduce using rule 50 (LEXP -> MATCH EXP OF OPEN_BRACE ALTS CLOSE_BRACE .)
    CLOSE_BRACE     reduce using rule 50 (LEXP -> MATCH EXP OF OPEN_BRACE ALTS CLOSE_BRACE .)
    ENDSTATEMENT    reduce using rule 50 (LEXP -> MATCH EXP OF OPEN_BRACE ALTS CLOSE_BRACE .)
    EQUALS          reduce using rule 50 (LEXP -> MATCH EXP OF OPEN_BRACE ALTS CLOSE_BRACE .)
    THEN            reduce using rule 50 (LEXP -> MATCH EXP OF OPEN_BRACE ALTS CLOSE_BRACE .)
    OF              reduce using rule 50 (LEXP -> MATCH EXP OF OPEN_BRACE ALTS CLOSE_BRACE .)
    CLOSE_PAREN     reduce using rule 50 (LEXP -> MATCH EXP OF OPEN_BRACE ALTS CLOSE_BRACE .)
    PIPE            reduce using rule 50 (LEXP -> MATCH EXP OF OPEN_BRACE ALTS CLOSE_BRACE .)
    ELSE            reduce using rule 50 (LEXP -> MATCH EXP OF OPEN_BRACE ALTS CLOSE_BRACE .)


state 170

    (60) ALTS -> ALT ENDSTATEMENT . ALTS
    (60) ALTS -> . ALT ENDSTATEMENT ALTS
    (61) ALTS -> . ALT
    (62) ALT -> . LPAT ARROW EXP
    (63) ALT -> .
    (64) LPAT -> . APAT
    (65) LPAT -> . MINUS OPEN_PAREN INTEGER CLOSE_PAREN
    (66) LPAT -> . MINUS OPEN_PAREN FLOAT CLOSE_PAREN
    (67) LPAT -> . TYPENAME APAT APATS
    (68) APAT -> . PARAM
    (69) APAT -> . TYPENAME
    (70) APAT -> . LITERAL
    (71) APAT -> . OPEN_PAREN LPAT CLOSE_PAREN
    (98) PARAM -> . IDENTIFIER
    (92) LITERAL -> . FLOAT
    (93) LITERAL -> . INTEGER
    (94) LITERAL -> . BOOL
    (95) LITERAL -> . CHAR
    (96) LITERAL -> . STRING

    ENDSTATEMENT    reduce using rule 63 (ALT -> .)
    CLOSE_BRACE     reduce using rule 63 (ALT -> .)
    MINUS           shift and go to state 24
    TYPENAME        shift and go to state 14
    OPEN_PAREN      shift and go to state 39
    IDENTIFIER      shift and go to state 35
    FLOAT           shift and go to state 25
    INTEGER         shift and go to state 21
    BOOL            shift and go to state 28
    CHAR            shift and go to state 29
    STRING          shift and go to state 30

    ALT                            shift and go to state 166
    ALTS                           shift and go to state 172
    LPAT                           shift and go to state 167
    APAT                           shift and go to state 22
    PARAM                          shift and go to state 26
    LITERAL                        shift and go to state 27

state 171

    (62) ALT -> LPAT ARROW . EXP
    (43) EXP -> . INFIX_EXP
    (44) INFIX_EXP -> . LEXP OP INFIX_EXP
    (45) INFIX_EXP -> . MINUS INFIX_EXP
    (46) INFIX_EXP -> . LEXP
    (47) LEXP -> . LAMBDA APAT APATS ARROW EXP
    (48) LEXP -> . LET DECLARATIONS IN EXP
    (49) LEXP -> . IF EXP THEN EXP ELSE EXP
    (50) LEXP -> . MATCH EXP OF OPEN_BRACE ALTS CLOSE_BRACE
    (51) LEXP -> . FEXP
    (52) FEXP -> . FEXP AEXP
    (53) FEXP -> . AEXP
    (54) AEXP -> . USED_VAR
    (55) AEXP -> . TYPENAME
    (56) AEXP -> . LITERAL
    (57) AEXP -> . OPEN_PAREN EXP CLOSE_PAREN
    (97) USED_VAR -> . IDENTIFIER
    (92) LITERAL -> . FLOAT
    (93) LITERAL -> . INTEGER
    (94) LITERAL -> . BOOL
    (95) LITERAL -> . CHAR
    (96) LITERAL -> . STRING

    MINUS           shift and go to state 90
    LAMBDA          shift and go to state 91
    LET             shift and go to state 92
    IF              shift and go to state 93
    MATCH           shift and go to state 94
    TYPENAME        shift and go to state 98
    OPEN_PAREN      shift and go to state 100
    IDENTIFIER      shift and go to state 101
    FLOAT           shift and go to state 25
    INTEGER         shift and go to state 21
    BOOL            shift and go to state 28
    CHAR            shift and go to state 29
    STRING          shift and go to state 30

    EXP                            shift and go to state 173
    INFIX_EXP                      shift and go to state 88
    LEXP                           shift and go to state 89
    FEXP                           shift and go to state 95
    AEXP                           shift and go to state 96
    USED_VAR                       shift and go to state 97
    LITERAL                        shift and go to state 99

state 172

    (60) ALTS -> ALT ENDSTATEMENT ALTS .

    CLOSE_BRACE     reduce using rule 60 (ALTS -> ALT ENDSTATEMENT ALTS .)


state 173

    (62) ALT -> LPAT ARROW EXP .

    ENDSTATEMENT    reduce using rule 62 (ALT -> LPAT ARROW EXP .)
    CLOSE_BRACE     reduce using rule 62 (ALT -> LPAT ARROW EXP .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for BACKTICK in state 89 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 89 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 89 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 89 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 89 resolved as shift
WARNING: shift/reduce conflict for MODULO in state 89 resolved as shift
WARNING: shift/reduce conflict for POW in state 89 resolved as shift
WARNING: shift/reduce conflict for EQUALITY in state 89 resolved as shift
WARNING: shift/reduce conflict for INEQUALITY in state 89 resolved as shift
WARNING: shift/reduce conflict for LESS in state 89 resolved as shift
WARNING: shift/reduce conflict for LEQ in state 89 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 89 resolved as shift
WARNING: shift/reduce conflict for GEQ in state 89 resolved as shift
WARNING: shift/reduce conflict for AND in state 89 resolved as shift
WARNING: shift/reduce conflict for OR in state 89 resolved as shift
WARNING: shift/reduce conflict for LIST_CONSTRUCTOR in state 89 resolved as shift
WARNING: shift/reduce conflict for CLOSE_BRACE in state 125 resolved as shift
