# code generated by funky py_compiler
# generated 2019-02-05 at 16:53:54

# section: code_runtime
class ADT:
    """Superclass for all ADTs."""

    def __init__(self, params):
        self.params = params

def __eq(a):
    return lambda x: a == x

def __neq(a):
    return lambda x: a != x

def __less(a):
    return lambda x: a < x

def __leq(a):
    return lambda x: a <= x

def __greater(a):
    return lambda x: a > x

def __geq(a):
    return lambda x: a >= x

def __pow(a):
    return lambda x: a ** x

def __add(a):
    return lambda x: a + x

def __sub(a):
    return lambda x: a - x

def __negate(a):
    return -a

def __mul(a):
    return lambda x: a * x

def __div(a):
    if isinstance(a, int):
        return lambda x: a // x
    else:
        return lambda x: a / x

def __mod(a):
    return lambda x: a % x

def __logical_and(a):
    return lambda x: a and x

def __logical_or(a):
    return lambda x: a or x

def __match(scrutinee, outcomes, default):
    if isinstance(scrutinee, ADT):
        ans = __match_adt(scrutinee, outcomes)
        if ans is not None:
            args = [p for p in scrutinee.params]
            if args:
                return ans(*args)
            else:
                return ans()
    else:
        ans = __match_literal(scrutinee, outcomes)
        if ans is not None:
            return ans()

    return __lazy(default)

def __match_adt(scrutinee, outcomes):
    return outcomes.get(scrutinee.__class__, None)

def __match_literal(scrutinee, outcomes):
    for alt, expr in outcomes.items():
        if scrutinee == alt:
            return expr

def __lazy(f):
    return f()

# section: create_adts
class ADTList(ADT):
    """ADT superclass."""
    pass

class ADTCons(ADTList):

    def __init__(self, v0, v1):
        super().__init__([v0, v1])

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        return all(x == y for x, y in zip(self.params, other.params))

    def __str__(self):
        name = type(self).__name__[3:]
        vars = [str(x) for x in self.params]
        return "({} {})".format(name, " ".join(vars))

Cons = lambda v0: lambda v1: ADTCons(v0, v1)

class ADTNil(ADTList):

    def __init__(self):
        super().__init__([])

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        return all(x == y for x, y in zip(self.params, other.params))

    def __str__(self):
        name = type(self).__name__[3:]
        return name

Nil = ADTNil()

def v0(v0_0):
    v1 = ((__mod)(((__mul)(7))(v0_0)))(101)
    v2 = ((__add)(((__mod)(((__sub)(v1))(1)))(10)))(1)
    return v2

v3 = True
def v4(v4_0):
    def lam(v4_1):
        def m0(Cons_v4_1_0, Cons_v4_1_1):
            def m0():
                return Cons_v4_1_0
            def m1():
                return ((v4)(((__sub)(v4_0))(1)))(Cons_v4_1_1)
            return __match(v4_0, {0 : m0}, m1)
        return __match(v4_1, {ADTCons : m0}, None)
    return lam

def v5(v5_0):
    def m0():
        return 0
    def m1():
        def m0(Cons_v5_0_0, Cons_v5_0_1):
            return ((__add)(1))((v5)(Cons_v5_0_1))
        return __match(v5_0, {ADTCons : m0}, None)
    return __match(v5_0, {ADTNil : m0}, m1)

def v6(v6_0):
    v7 = ((__div)((v5)(v6_0)))(2)
    return ((v4)(v7))(v6_0)

def v8(v8_0):
    def lam(v8_1):
        def m0(Cons_v8_0_0, Cons_v8_0_1):
            return ((Cons)(Cons_v8_0_0))(((v8)(Cons_v8_0_1))(v8_1))
        def m1():
            def m0():
                return v8_0
            def m1():
                def m0():
                    return v8_1
                return __match(v8_0, {ADTNil : m0}, None)
            return __match(v8_1, {ADTNil : m0}, m1)
        return __match(v8_0, {ADTCons : m0}, m1)
    return lam

def v9(v9_0):
    def lam(v9_1):
        def m0():
            return Nil
        def m1():
            def m0(Cons_v9_1_0, Cons_v9_1_1):
                def m0():
                    return ((Cons)(Cons_v9_1_0))(((v9)(v9_0))(Cons_v9_1_1))
                def m1():
                    def m0():
                        return ((v9)(v9_0))(Cons_v9_1_1)
                    return __match(v3, {True : m0}, None)
                return __match((v9_0)(Cons_v9_1_0), {True : m0, False : m1}, None)
            return __match(v9_1, {ADTCons : m0}, None)
        return __match(v9_1, {ADTNil : m0}, m1)
    return lam

def v10(v10_0):
    def m0():
        return Nil
    def m1():
        def m0(Cons_v10_0_0, Cons_v10_0_1):
            def lam(v12):
                return ((__leq)(v12))(Cons_v10_0_0)
            v11 = ((v9)(lam))(Cons_v10_0_1)
            def lam(v14):
                return ((__greater)(v14))(Cons_v10_0_0)
            v13 = ((v9)(lam))(Cons_v10_0_1)
            return ((v8)(((v8)((v10)(v11)))(((Cons)(Cons_v10_0_0))(Nil))))((v10)(v13))
        return __match(v10_0, {ADTCons : m0}, None)
    return __match(v10_0, {ADTNil : m0}, m1)

def v15(v15_0):
    def lam(v15_1):
        def lam(v15_2):
            def m0():
                return v15_1
            def m1():
                def m0(Cons_v15_2_0, Cons_v15_2_1):
                    return ((v15_0)(Cons_v15_2_0))((((v15)(v15_0))(v15_1))(Cons_v15_2_1))
                return __match(v15_2, {ADTCons : m0}, None)
            return __match(v15_2, {ADTNil : m0}, m1)
        return lam
    return lam

def v16(v16_0):
    def lam(v16_1):
        def m0():
            return Nil
        def m1():
            v17 = (v0)(v16_0)
            return ((Cons)((v0)(v17)))(((v16)(v17))(((__sub)(v16_1))(1)))
        return __match(v16_1, {0 : m0}, m1)
    return lam

# section: emit_main
def main():
    print((v10)(((v16)(50))(10)))

if __name__ == "__main__":
    main()
