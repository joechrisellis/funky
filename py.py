# code generated by funky's python generator
# timestamp: 2019-03-11 at 14:31:48

# base runtime
import sys
import inspect
REC_LIMIT = 10000
sys.setrecursionlimit(REC_LIMIT)

def trampoline(bouncer):
    while callable(bouncer) and not inspect.isclass(bouncer) \
        and len(inspect.signature(bouncer).parameters) == 0:
        bouncer = bouncer()
    return bouncer

class ADT:
    """Superclass for all ADTs."""

    def __init__(self, params):
        self.params = params

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        return all(x == y for x, y in zip(self.params, other.params))

    def __repr__(self):
        return self.to_str()

    def to_str(self, toplevel=True):
        name = type(self).__name__[3:]

        if not self.params:
            return name

        wrap = "({})".format
        
        vars = []
        for p in self.params:
            p = trampoline(p)
            if isinstance(p, ADT):
                vars.append(p.to_str(toplevel=False))
            else:
                vars.append(repr(p))

        s = "{} {}".format(name, " ".join(vars))
        if not toplevel:
            s = wrap(s) 

        return s

class FunkyRuntimeError(Exception):

    def __init__(self, message, *args, **kwargs):
        message = "Funky runtime error: {}".format(message)
        super().__init__(message, *args, **kwargs)

class InexhaustivePatternMatchError(FunkyRuntimeError):

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)

def __match(scrutinee, outcomes, default):
    if isinstance(scrutinee, ADT):
        ans = __match_adt(scrutinee, outcomes)
        if ans is not None:
            args = [p for p in scrutinee.params]
            if args:
                return ans(*args)
            else:
                return ans()
    else:
        ans = __match_literal(scrutinee, outcomes)
        if ans is not None:
            return ans()

    if default:
        return default()
    else:
        raise InexhaustivePatternMatchError("Inexhaustive pattern match, cannot "
                                            "continue.")

def __match_adt(scrutinee, outcomes):
    return outcomes.get(scrutinee.__class__, None)

def __match_literal(scrutinee, outcomes):
    for alt, expr in outcomes.items():
        if scrutinee == alt:
            return expr

# runtime
def __sub(a):
    return lambda x: lambda: trampoline(a) - trampoline(x)

def __add(a):
    return lambda x: lambda: trampoline(a) + trampoline(x)

# algebraic data types
class ADTList(ADT):
    pass

class ADTCons(ADTList):

    def __init__(self, v0, v1):
        super().__init__([v0, v1])

Cons = lambda v0: lambda v1: ADTCons(v0, v1)

class ADTNil(ADTList):

    def __init__(self):
        super().__init__([])

Nil = ADTNil()

# core code
def v0(v0_0):
    def lam10(v0_1):
        def lam11(v0_2):
            def m0(Cons_v0_1_0, Cons_v0_1_1):
                def m0(Cons_v0_2_0, Cons_v0_2_1):
                    return lambda: (trampoline((trampoline(Cons))((trampoline((trampoline(v0_0))(Cons_v0_1_0)))(Cons_v0_2_0))))((trampoline((trampoline((trampoline(v0))(v0_0)))(Cons_v0_1_1)))(Cons_v0_2_1))
                def m1():
                    return lambda: Nil
                return lambda: lambda: __match(trampoline(v0_2), {trampoline(ADTCons) : m0}, m1)
            def m1():
                return lambda: Nil
            return lambda: __match(trampoline(v0_1), {trampoline(ADTCons) : m0}, m1)
        return lam11
    return lambda: lam10

def v3(v3_0):
    def lam12(v3_1):
        def m0():
            return lambda: Nil
        def m1():
            def m0(Cons_v3_1_0, Cons_v3_1_1):
                return lambda: (trampoline((trampoline(Cons))(Cons_v3_1_0)))((trampoline((trampoline(v3))((trampoline((trampoline(__sub))(v3_0)))(1))))(Cons_v3_1_1))
            return lambda: lambda: __match(trampoline(v3_1), {trampoline(ADTCons) : m0}, None)
        return lambda: __match(trampoline(v3_0), {trampoline(0) : m0}, m1)
    return lambda: lam12

def v1(v1_0):
    def m0(_0, Cons_v1_0_1):
        return lambda: Cons_v1_0_1
    def m1():
        return lambda: Nil
    return lambda: lambda: __match(trampoline(v1_0), {trampoline(ADTCons) : m0}, m1)

v2 = lambda: (trampoline((trampoline(Cons))(0)))((trampoline((trampoline(Cons))(1)))((trampoline((trampoline((trampoline(v0))(__add)))(v2)))((trampoline(v1))(v2))))
# main method
def main():
    print(trampoline((trampoline((trampoline(v3))(20)))(v2)))

if __name__ == "__main__":
    main()
