# code generated by funky's python generator
# timestamp: 2019-02-25 at 18:27:47

# section: code_runtime
class ADT:
    """Superclass for all ADTs."""

    def __init__(self, params):
        self.params = params

class InexhaustivePatternMatchError(Exception):
    pass

def __eq(a):
    return lambda x: a == x

def __neq(a):
    return lambda x: a != x

def __less(a):
    return lambda x: a < x

def __leq(a):
    return lambda x: a <= x

def __greater(a):
    return lambda x: a > x

def __geq(a):
    return lambda x: a >= x

def __pow(a):
    return lambda x: a ** x

def __add(a):
    return lambda x: a + x

def __concat(a):
    return lambda x: a + x

def __sub(a):
    return lambda x: a - x

def __negate(a):
    return -a

def __mul(a):
    return lambda x: a * x

def __div(a):
    if isinstance(a, int):
        return lambda x: a // x
    else:
        return lambda x: a / x

def __mod(a):
    return lambda x: a % x

def __logical_and(a):
    return lambda x: a and x

def __logical_or(a):
    return lambda x: a or x

def __match(scrutinee, outcomes, default):
    if isinstance(scrutinee, ADT):
        ans = __match_adt(scrutinee, outcomes)
        if ans is not None:
            args = [p for p in scrutinee.params]
            if args:
                return ans(*args)
            else:
                return ans()
    else:
        ans = __match_literal(scrutinee, outcomes)
        if ans is not None:
            return ans()

    if default:
        return default()
    else:
        raise InexhaustivePatternMatchError("Inexhaustive pattern match, cannot "
                                            "continue.")

def __match_adt(scrutinee, outcomes):
    return outcomes.get(scrutinee.__class__, None)

def __match_literal(scrutinee, outcomes):
    for alt, expr in outcomes.items():
        if scrutinee == alt:
            return expr

# section: create_adts
class ADTIList(ADT):
    """ADT superclass."""
    pass

class ADTICons(ADTIList):

    def __init__(self, v0, v1):
        super().__init__([v0, v1])

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        return all(x == y for x, y in zip(self.params, other.params))

    def __repr__(self):
        name = type(self).__name__[3:]
        vars = [repr(x) for x in self.params]
        return "({} {})".format(name, " ".join(vars))

ICons = lambda v0: lambda v1: ADTICons(v0, v1)

class ADTINil(ADTIList):

    def __init__(self):
        super().__init__([])

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        return all(x == y for x, y in zip(self.params, other.params))

    def __repr__(self):
        name = type(self).__name__[3:]
        return name

INil = ADTINil()

class ADTSList(ADT):
    """ADT superclass."""
    pass

class ADTSCons(ADTSList):

    def __init__(self, v0, v1):
        super().__init__([v0, v1])

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        return all(x == y for x, y in zip(self.params, other.params))

    def __repr__(self):
        name = type(self).__name__[3:]
        vars = [repr(x) for x in self.params]
        return "({} {})".format(name, " ".join(vars))

SCons = lambda v0: lambda v1: ADTSCons(v0, v1)

class ADTSNil(ADTSList):

    def __init__(self):
        super().__init__([])

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        return all(x == y for x, y in zip(self.params, other.params))

    def __repr__(self):
        name = type(self).__name__[3:]
        return name

SNil = ADTSNil()

def v15(v15_0):
    def lam17(v15_1):
        def m0():
            return SNil
        def m1():
            def m0(ICons_v15_1_0, ICons_v15_1_1):
                return ((SCons)((v15_0)(ICons_v15_1_0)))(((v15)(v15_0))(ICons_v15_1_1))
            return __match(v15_1, {ADTICons : m0}, None)
        return __match(v15_1, {ADTINil : m0}, m1)
    return lam17

def v14(v14_0):
    def m0():
        return "zero"
    def m1():
        def m0():
            return "one"
        def m1():
            def m0():
                return "two"
            def m1():
                def m0():
                    return "three"
                def m1():
                    def m0():
                        return "four"
                    def m1():
                        def m0():
                            return "five"
                        def m1():
                            def m0():
                                return "six"
                            def m1():
                                def m0():
                                    return "seven"
                                def m1():
                                    def m0():
                                        return "eight"
                                    def m1():
                                        def m0():
                                            return "nine"
                                        def m1():
                                            return "undefined"
                                        return __match(v14_0, {9 : m0}, m1)
                                    return __match(v14_0, {8 : m0}, m1)
                                return __match(v14_0, {7 : m0}, m1)
                            return __match(v14_0, {6 : m0}, m1)
                        return __match(v14_0, {5 : m0}, m1)
                    return __match(v14_0, {4 : m0}, m1)
                return __match(v14_0, {3 : m0}, m1)
            return __match(v14_0, {2 : m0}, m1)
        return __match(v14_0, {1 : m0}, m1)
    return __match(v14_0, {0 : m0}, m1)

v16 = ((ICons)(5))(((ICons)(1))(((ICons)(7))(((ICons)(7))(((ICons)(3))(INil)))))
# section: emit_main
def main():
    print(((v15)(v14))(v16))

if __name__ == "__main__":
    main()
